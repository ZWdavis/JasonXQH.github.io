<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0208面试题环路检测</title>
    <url>/2020/04/19/0208%E9%9D%A2%E8%AF%95%E9%A2%98%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="02-08面试题-环路检测"><a href="#02-08面试题-环路检测" class="headerlink" title="02.08面试题 环路检测"></a>02.08面试题 环路检测</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/19/0208%E9%9D%A2%E8%AF%95%E9%A2%98%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/.%5C0208%E9%9D%A2%E8%AF%95%E9%A2%98%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B%5C1.png" alt></p>
<h3 id="这题和141-环形链表相近，但是需要考虑更多"><a href="#这题和141-环形链表相近，但是需要考虑更多" class="headerlink" title="这题和141.环形链表相近，但是需要考虑更多"></a>这题和141.环形链表相近，但是需要考虑更多</h3><p>有俩个指针 fast ,slow分别的从起点a 开始走，slow走一步，fast走里俩步。如果过程中 快fast走到null,说明不存在环。否则fast和slow一定会相遇，相遇后，slow待在原地不动，将 fast放回原点。然后俩个指针每次都走一步，每次都走一步，每次都走一步。当俩个指针相遇的时候，就是环的入口。</p>
<p><img src="/2020/04/19/0208%E9%9D%A2%E8%AF%95%E9%A2%98%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/D:%5Cprojects%5CJasonXQH.github.io%5Csource%5Cimages%5C02.08%E9%9D%A2%E8%AF%95%E9%A2%98%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B%E5%9B%BE%E8%A7%A3.png" alt="02.08面试题环路检测图解"></p>
<p>证明：如上图所示，a是起点，b是环的入口，c是俩个指针相遇点，ab之间距离为x，bc之间距离是 y。<br>当slow 走到 b 时，由于fast 比 slow 走的快，所以fast 已经从 b 开始在环上走了 x 步，可能是多余一圈，距离 b 还差 y 步(解释：我们知道俩个指针相遇的点在c，我们让 slow 退回到b，fast 则会退回 2y 步，所以就是距离b 还差y 步，不会可以画图模拟一下)。知道了 fast 距离 b 还差 y 步，上面知道了 fast 从 b 开始在环上走了 x步。所以环的长度的倍数为 x+y。所以当俩个指针相遇时，把 fast 放回原点，slow 在 c点不动。然后每次都走一步，下一次相遇的时候就是b 点环的入口。</p>
<p>用下面的数学公式比较直观， 相遇的时候， y 走了2*（x+y) , x 走了 （x+y）， x 比y 多走了m个圈圈</p>
<p>（x+y）* 2= m * cycle+y+x         x+y=m * cycle          m * cycle-y=x</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur1 = head ;<span class="comment">//cur1 是快指针</span></span><br><span class="line">        ListNode *cur2 = head;<span class="comment">//cur2 是慢指针</span></span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)<span class="comment">//如果头节点就是空，那就直接输出false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1&amp;&amp;cur1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            cur1 = cur1-&gt;next-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">			<span class="comment">//相等的时候，我们进行快节点指向头部，慢节点不动，然后一起走的操作</span></span><br><span class="line">            <span class="keyword">if</span>(cur1==cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                cur1 = head;</span><br><span class="line">                <span class="keyword">while</span>(cur1!=cur2)</span><br><span class="line">                &#123;</span><br><span class="line">                   cur1= cur1-&gt;next;</span><br><span class="line">                    cur2=cur2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="keyword">return</span>  cur2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>1047删除字符串中所有的相邻重复项</title>
    <url>/2020/04/22/1047%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="1047删除字符串中所有的相邻重复项"><a href="#1047删除字符串中所有的相邻重复项" class="headerlink" title="1047删除字符串中所有的相邻重复项"></a>1047删除字符串中所有的相邻重复项</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/22/1047%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/.%5C1047%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9%5C1047.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="这里给出两个解法，第一种是我自己想出来的原始解法，第二种是高人做的"><a href="#这里给出两个解法，第一种是我自己想出来的原始解法，第二种是高人做的" class="headerlink" title="这里给出两个解法，第一种是我自己想出来的原始解法，第二种是高人做的"></a>这里给出两个解法，第一种是我自己想出来的原始解法，第二种是高人做的</h4><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;s;</span><br><span class="line">        <span class="comment">//首先压栈，如果有元素和栈顶重复，那么需要pop</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> n:S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty()&amp;&amp;n==s.top())</span><br><span class="line">                s.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.push(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="comment">//把栈里面的元素赋值给字符串，使用头插法</span></span><br><span class="line">        <span class="comment">//直接赋值再使用reverse函数会导致超时</span></span><br><span class="line">        <span class="comment">//即使这样，运行时长也很多</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123; </span><br><span class="line">            temp=ans;</span><br><span class="line">            ans=s.top();</span><br><span class="line">            ans+=temp;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//短小且精悍</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//同样的是遍历S，不过他用在原字符串的基础上改，而不是另起炉灶</span></span><br><span class="line">        <span class="comment">//这个top可以看作是“新”字符串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : S) &#123;</span><br><span class="line">            <span class="comment">//如果“新“字符串长度为0或者相邻数字是不重复的，那么将修改</span></span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">0</span> || S[top<span class="number">-1</span>] != ch) S[top++] = ch;</span><br><span class="line">            <span class="comment">//否则，如果相邻数字是重复的话，那么长度-1，下次修改string的时候</span></span><br><span class="line">            <span class="comment">//会直接覆盖掉原来重复的第一个数字！妙</span></span><br><span class="line">            <span class="keyword">else</span> top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后，重新规定S的长度，让他等于新字符串的长度，鸠占鹊巢</span></span><br><span class="line">        S.resize(top);</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1019链表中的下一个更大元素</title>
    <url>/2020/04/19/1019%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="1019-链表中的下一个更大元素"><a href="#1019-链表中的下一个更大元素" class="headerlink" title="1019.链表中的下一个更大元素"></a>1019.链表中的下一个更大元素</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里用最普通的思路，和用栈模拟的方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个思路就时很简单，用两个迭代器，每次更新一个迭代器，都把他们后面的所有元素遍历一遍</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">          ListNode*cur1 = head;</span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">          <span class="keyword">while</span>(cur1-&gt;next)</span><br><span class="line">          &#123;</span><br><span class="line">            ListNode *cur2 = cur1-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur2-&gt;val&gt;cur1-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    v.push_back(cur2-&gt;val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur2=cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!cur2)</span><br><span class="line">                    v.push_back(<span class="number">0</span>);</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">        v.push_back(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用栈来做，思维要求比较高"><a href="#用栈来做，思维要求比较高" class="headerlink" title="用栈来做，思维要求比较高"></a>用栈来做，思维要求比较高</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将链表放入结果数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从右往左遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = res.at(i); <span class="comment">//先暂存当前元素</span></span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; cur &gt;= <span class="built_in">stack</span>.top()) </span><br><span class="line">            <span class="comment">//注意: 等于号不能少 等于时也需要出栈 这里是找严格大于的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop();  <span class="comment">//淘汰小的 留下更大的</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.at(i) = (<span class="built_in">stack</span>.empty() ? <span class="number">0</span> : <span class="built_in">stack</span>.top()); </span><br><span class="line">            <span class="comment">//栈空 右边没有更大的</span></span><br><span class="line">            <span class="built_in">stack</span>.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//我们不妨拿一组数据来模拟一下 2 7 2 3  </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1： res[3]= 3 ，cur = 3 ， stack 内的元素 ：0 =&gt;&gt;&gt;&gt;&gt; res[3]=0 stack 内的元素: 3</span></span><br><span class="line"><span class="comment">2： res[2]= 2 ，cur = 2 ， stack 内的元素 ：3 =&gt;&gt;&gt;&gt;&gt; res[2]=3 stack 内的元素: 3</span></span><br><span class="line"><span class="comment">3： res[1]= 7 ，cur = 7 ， stack 内的元素 ：3 =&gt;&gt;&gt;&gt;&gt; stack 出栈res[1]=0 stack 内的元素:7</span></span><br><span class="line"><span class="comment">4： res[0]= 2 ，cur = 2 ， stack 内的元素 ：7 =&gt;&gt;&gt;&gt;&gt; res[0]=7 stack 内的元素: 7</span></span><br><span class="line"><span class="comment">然后输出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1021删除最外层得括号</title>
    <url>/2020/04/22/1021%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E5%BE%97%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="1021-删除最外层的括号"><a href="#1021-删除最外层的括号" class="headerlink" title="1021 删除最外层的括号"></a>1021 删除最外层的括号</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/22/1021%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E5%BE%97%E6%8B%AC%E5%8F%B7/.%5C1021%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E5%BE%97%E6%8B%AC%E5%8F%B7%5C1021.png" alt></p>
<h3 id="下面是模板"><a href="#下面是模板" class="headerlink" title="下面是模板"></a>下面是模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="我自己是没有办法想出很妙的算法的"><a href="#我自己是没有办法想出很妙的算法的" class="headerlink" title="我自己是没有办法想出很妙的算法的"></a>我自己是没有办法想出很妙的算法的</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">1</span>;<span class="keyword">int</span> R=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="comment">//因为我们的前提是：S是一个有效括号的字符串，所以不存在(()之类的情况</span></span><br><span class="line">        <span class="comment">//所以说，括号之内的部分，都是一一匹配的</span></span><br><span class="line">        <span class="comment">//这样，只要没遍历到最外层的括号，那么里面的左右括号数目都是相等的</span></span><br><span class="line">        <span class="comment">//如果左右括号一一匹配，那么L,R的永远不可能相等，这时候把内容压入数组中</span></span><br><span class="line">        <span class="comment">//什么时候会相等？就是当读到最外层括号的时候，R++</span></span><br><span class="line">        <span class="comment">//这时候，L==R就说明了已经匹配到，可以进行下一次匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;S.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">'('</span>)</span><br><span class="line">                L++;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//因为不是左括号就是右括号</span></span><br><span class="line">                R++;</span><br><span class="line">            <span class="keyword">if</span>(R!=L)</span><br><span class="line">                ans.push_back(S[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//重置。进行下一次寻找</span></span><br><span class="line">                i++;L=<span class="number">1</span>;R=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="万变不离其宗，其他方法也是如此，但我认为还是第一种方法最简洁"><a href="#万变不离其宗，其他方法也是如此，但我认为还是第一种方法最简洁" class="headerlink" title="万变不离其宗，其他方法也是如此，但我认为还是第一种方法最简洁"></a>万变不离其宗，其他方法也是如此，但我认为还是第一种方法最简洁</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c:S) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果看到左括号，cnt++，否则cnt--,相当于上面的L++,R++</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="comment">//这里特别要注意，当读取到第一个左括号的时候，就直接continue，不让他压入数组</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt--;</span><br><span class="line">            <span class="comment">//当cnt再次回到0的时候，就是读取到最外层的括号的时候，所以两种情况不会进行下一步</span></span><br><span class="line">            <span class="comment">//一种就是读取最外层（ 时，直接continue；还有是读取）时，cnt=0。</span></span><br><span class="line">            <span class="keyword">if</span>(cnt != <span class="number">0</span>)res.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>109有序链表转换二叉搜索树</title>
    <url>/2020/04/19/109%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a>109. 有序链表转换二叉搜索树</h1><p><img src="/2020/04/19/109%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/1.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="对于这题，最简单的就是递归构建树"><a href="#对于这题，最简单的就是递归构建树" class="headerlink" title="对于这题，最简单的就是递归构建树"></a>对于这题，最简单的就是递归构建树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先我们写一个构造树的函数，通过递归来实现。 </span></span><br><span class="line"><span class="comment">//然后用vector存储链表，用来构建树</span></span><br><span class="line"><span class="comment">//因为已经是升序链表了，所以没必要再排序，如果是无序链表构建二叉搜索树，我们需要对vector进行再排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="comment">//建立一个数组来存储所有的数据</span></span><br><span class="line">       ListNode *cur = head;</span><br><span class="line">       <span class="keyword">while</span>(cur)</span><br><span class="line">       &#123;</span><br><span class="line">           v.push_back(cur-&gt;val);</span><br><span class="line">           cur = cur-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//用递归来解决</span></span><br><span class="line">       <span class="keyword">return</span> buildTree(v,<span class="number">0</span>,v.<span class="built_in">size</span>());       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v,<span class="keyword">int</span> <span class="built_in">begin</span>,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span>==<span class="built_in">end</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = (<span class="built_in">begin</span>+<span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(v[middle]);</span><br><span class="line">        root-&gt;left = buildTree(v,<span class="built_in">begin</span>,middle);</span><br><span class="line">        root-&gt;right = buildTree(v,middle+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="但是上面这种方法消耗了很多时间和空间，能不能用更快的方法呢？"><a href="#但是上面这种方法消耗了很多时间和空间，能不能用更快的方法呢？" class="headerlink" title="但是上面这种方法消耗了很多时间和空间，能不能用更快的方法呢？"></a>但是上面这种方法消耗了很多时间和空间，能不能用更快的方法呢？</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> [<span class="number">-10</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = p;</span><br><span class="line">        ListNode* pre = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用快慢指针，找到链表的中间节点</span></span><br><span class="line">        <span class="keyword">while</span> (q &amp;&amp; q-&gt;next) &#123;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时候，pre是p的前驱，pre为-3，p为0</span></span><br><span class="line">        <span class="keyword">if</span> (pre) pre-&gt;next = <span class="number">0</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(p-&gt;val);</span><br><span class="line">        node-&gt;left = sortedListToBST(head == p ? pre : head);</span><br><span class="line">        node-&gt;right = sortedListToBST(p-&gt;next);<span class="comment">//继续递归</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1171从链表中删除总和值为0的连续节点</title>
    <url>/2020/04/19/1171%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA0%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="1171-从链表中删去总和值为零的连续节点"><a href="#1171-从链表中删去总和值为零的连续节点" class="headerlink" title="1171. 从链表中删去总和值为零的连续节点"></a>1171. 从链表中删去总和值为零的连续节点</h1><h2 id="下面是题目-需要注意的是，题目说的是总和为0的连续结点"><a href="#下面是题目-需要注意的是，题目说的是总和为0的连续结点" class="headerlink" title="下面是题目,需要注意的是，题目说的是总和为0的连续结点"></a>下面是题目,需要注意的是，题目说的是总和为0的连续结点</h2><h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="昨天只看了题解，还是没看懂，今天自己解了一边，再看题解，发现了几个细节点值得注意"><a href="#昨天只看了题解，还是没看懂，今天自己解了一边，再看题解，发现了几个细节点值得注意" class="headerlink" title="昨天只看了题解，还是没看懂，今天自己解了一边，再看题解，发现了几个细节点值得注意"></a>昨天只看了题解，还是没看懂，今天自己解了一边，再看题解，发现了几个细节点值得注意</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这题的原理很简单，就是通过记录序列和，来达到判断是否要删除节点</span></span><br><span class="line"><span class="comment">	比如拿1，2，3，-3，4来说</span></span><br><span class="line"><span class="comment">	其序列和就是1，3，6，3，7</span></span><br><span class="line"><span class="comment">	我们看见第二个和第四个是相同的，说明3，4的两个节点的和为0，我们要做一个对3，4的删除</span></span><br><span class="line"><span class="comment">	那么如何能做到这个删除呢？其实用无序图存储数据即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里是第一个小细节，我们要用无序图来存储，否则会打乱我们存储的数据顺序</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,ListNode*&gt;mp;</span><br><span class="line">        <span class="comment">//因为头节点可能会被删除，所以我们要用哑头节点</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *p = dummy;</span><br><span class="line">        <span class="keyword">int</span> val ;</span><br><span class="line">        <span class="comment">//这里是第二个小细节，也是我们一定要养成的习惯，就是能初始化的就要初始化！</span></span><br><span class="line">        mp[<span class="number">0</span>] = p;<span class="comment">//对于图中第一个元素，先把哑节点存储进去</span></span><br><span class="line">        <span class="keyword">int</span> curval=<span class="number">0</span>,tempval=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里需要定两个值，一个来记录当前的序列和，并且做存储，一个用来删除节点</span></span><br><span class="line">        <span class="comment">//然后就开始迭代</span></span><br><span class="line">        <span class="keyword">while</span>(p=p-&gt;next)<span class="comment">//p = p-&gt;next这句话在，就不用在循环的最后写p=p-&gt;next了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//curval用来计算序列和</span></span><br><span class="line">            curval+=p-&gt;val;</span><br><span class="line">            <span class="comment">//因为图中只能存储相同的键值，所以，如果重复的话，mp.find(curval)就不会返回end()</span></span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(curval)!=mp.<span class="built_in">end</span>())<span class="comment">//所以把这个当作判定条件</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//这里，我们仍然用1 2 3 -3 4 来做判断</span></span><br><span class="line">         	<span class="comment">//前三个节点和为1，3，6，都已经存储在map中，现在的curval又等于3，所以执行此操作</span></span><br><span class="line">            <span class="comment">//这时候，先定义一个temp数组，让他指向第mp[3]的后一个节点，也就是第三个节点3</span></span><br><span class="line">                ListNode* temp = mp[curval]-&gt;next;</span><br><span class="line">            <span class="comment">//然后用mp[3]节点指向当前p节点的下一个节点，也就是第五个节点4，从而实现1，2，4相连，并删除中间的两个节点</span></span><br><span class="line">                mp[curval]-&gt;next= p-&gt;next;</span><br><span class="line">				<span class="comment">//但是，光节点指一下是不够的，mp[6]仍然在图中，如果下面的节点还是3，岂不是也要被删除？所以，为了避免这种干扰，我们要将mp[6]删除！怎么删除呢，tempval和temp节点的作用就在此 </span></span><br><span class="line">                tempval=curval；<span class="comment">//这时，tempval = 3</span></span><br><span class="line">                <span class="keyword">while</span>(temp!=p)<span class="comment">//判断条件就是，temp节点到p节点之间存储在mp中的项全部删光</span></span><br><span class="line">                    <span class="comment">//因为这时候p节点还没有入图，所以不用删除</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//现在经过下一步操作tempval = 6</span></span><br><span class="line">                    tempval += temp-&gt;val;</span><br><span class="line">                    <span class="comment">//然后移除mp中所有的，key值为6的项，（其实只有一项，mp中的key不可以重复）</span></span><br><span class="line">                    mp.erase(tempval);</span><br><span class="line">                    <span class="comment">//继续</span></span><br><span class="line">                    temp=temp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span><span class="comment">//如果这个序列和没有在图内找到，说明是个新的序列和，把他加入到图中</span></span><br><span class="line">            &#123;</span><br><span class="line">                mp[curval]=p;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1190.反转每对括号间的字符串</title>
    <url>/2020/04/28/1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="1190反转每对括号间的字符串"><a href="#1190反转每对括号间的字符串" class="headerlink" title="1190反转每对括号间的字符串"></a>1190反转每对括号间的字符串</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/28/1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/.%5C1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%5C1.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解题思路和394字符串解码一样"><a href="#解题思路和394字符串解码一样" class="headerlink" title="解题思路和394字符串解码一样"></a>解题思路和394字符串解码一样</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是字母，就加到res字符串里去</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i]))&#123;</span><br><span class="line">                res.push_back(s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">'('</span>)</span><br><span class="line">            <span class="comment">//如果是出现左括号，那么入栈+更新res</span></span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(res);</span><br><span class="line">                res = <span class="string">""</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//如果是右括号，把现有的res反转，然后加给栈头</span></span><br><span class="line">             <span class="comment">//出栈，更新res = 栈头 </span></span><br><span class="line">                  reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">                  stk.top()+=res;</span><br><span class="line">                  res=stk.top();</span><br><span class="line">                  stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="reverse-函数的用法"><a href="#reverse-函数的用法" class="headerlink" title="reverse()函数的用法"></a>reverse()函数的用法</h4><h5 id="反转string"><a href="#反转string" class="headerlink" title="反转string"></a>反转string</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> N;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">	reverse(N.<span class="built_in">begin</span>(), N.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;N&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="反转字符数组"><a href="#反转字符数组" class="headerlink" title="反转字符数组"></a>反转字符数组</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">101</span>];</span><br><span class="line">	<span class="built_in">cin</span>.getline(a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="keyword">int</span> m=<span class="built_in">strlen</span>(a);</span><br><span class="line">	reverse(a,a+m);</span><br><span class="line">	<span class="built_in">puts</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1209删除字符串中所有相邻重复项II</title>
    <url>/2020/04/29/1209%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9II/</url>
    <content><![CDATA[<h1 id="1209删除字符串中所有相邻重复项II"><a href="#1209删除字符串中所有相邻重复项II" class="headerlink" title="1209删除字符串中所有相邻重复项II"></a>1209删除字符串中所有相邻重复项II</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/29/1209%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9II/1.png" alt></p>
<h3 id="下面是代码模板"><a href="#下面是代码模板" class="headerlink" title="下面是代码模板"></a>下面是代码模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    string removeDuplicates(string s, int k) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="下面是一种好方法"><a href="#下面是一种好方法" class="headerlink" title="下面是一种好方法"></a>下面是一种好方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//并不能用map&lt;pair&lt;char,int&gt;&gt;来存储，否 则 s= yhhswyyyy，k=4 </span></span><br><span class="line"><span class="comment">//这种数据，就会出来yhhsy,而不是yhhsw..你懂吧</span></span><br><span class="line"><span class="comment">//用vector，允许重复出现，就不会在原来int的基础上叠加</span></span><br><span class="line">      <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty() &amp;&amp; st.back().first == i)&#123;</span><br><span class="line"><span class="comment">//如果这一个数据到达k了，直接删除就完事了，如果用stack存储还要再做一个循环pop()       </span></span><br><span class="line">                <span class="keyword">if</span>(++st.back().second == k)&#123;</span><br><span class="line">                    st.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.push_back(make_pair(i,<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="comment">//最后时复盘阶段，就是按照pair&lt;char,int&gt;输出int个char</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : st)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = i.second;</span><br><span class="line">            <span class="keyword">while</span>(l--)</span><br><span class="line">                res += i.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归大法好"><a href="#递归大法好" class="headerlink" title="递归大法好"></a>递归大法好</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,len=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                len=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len==k)&#123;</span><br><span class="line">      <span class="comment">//龙珠大法好！，如果中间那部分要删除，那么为什么不把头尾两段连起来再搞一次呢</span></span><br><span class="line">              <span class="keyword">return</span> removeDuplicates(s.substr(<span class="number">0</span>,i-k+<span class="number">1</span>)+s.substr(i+<span class="number">1</span>),k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="用stack也是很香的啊，为啥我想不到呢？"><a href="#用stack也是很香的啊，为啥我想不到呢？" class="headerlink" title="用stack也是很香的啊，为啥我想不到呢？"></a>用stack也是很香的啊，为啥我想不到呢？</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">  <span class="comment">//和用vector存储不同，stack仅仅存储数字，而在s上之间用erase修改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || s[i] != s[i<span class="number">-1</span>])&#123;</span><br><span class="line">                cnt.push(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt.top() += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> <span class="comment">//如果发现栈顶=k，就说明要删除了，删除部分就是s从i-k+1开始，删除k个字符</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.top() == k)&#123;</span><br><span class="line">                cnt.pop();</span><br><span class="line">                s.erase(i-k+<span class="number">1</span>,k);</span><br><span class="line"><span class="comment">//别忘了把i-k，因为现在的s[i]已经不是刚才的s[i]了</span></span><br><span class="line">                i = i - k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="我提交的几个方法和错误点"><a href="#我提交的几个方法和错误点" class="headerlink" title="我提交的几个方法和错误点"></a>我提交的几个方法和错误点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;stk;</span><br><span class="line">        <span class="built_in">map</span> &lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(c)==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                mp.insert(make_pair(c,<span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                mp[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            <span class="keyword">if</span>(mp[c]==k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i; i--) &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res.insert(<span class="number">0</span>,<span class="number">1</span>,stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">"pbbcggttciiippooaais"</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">"ppis"</span></span><br><span class="line"><span class="comment">预期：</span></span><br><span class="line"><span class="comment">"ps"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//iiippooaai这里，中间的删掉以后，无法判断i之前出现过几次</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;stk;</span><br><span class="line">        <span class="built_in">map</span> &lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(c)==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                mp.insert(make_pair(c,temp));</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                mp[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            <span class="keyword">if</span>(mp[c]==k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i; i--) &#123;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                mp[c]-=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res.insert(<span class="number">0</span>,<span class="number">1</span>,stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">"yfttttfbbbbnnnnffbgffffgbbbbgssssgthyyyy"</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">"ybty"</span></span><br><span class="line"><span class="comment">预期：</span></span><br><span class="line"><span class="comment">"ybth"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//并不能用map&lt;pair&lt;char,int&gt;&gt;来存储，否 则 s= yhhswyyyy，k=4</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1249移除无效的括号</title>
    <url>/2020/04/30/1249%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="1249移除无效的括号"><a href="#1249移除无效的括号" class="headerlink" title="1249移除无效的括号"></a>1249移除无效的括号</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/30/1249%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/1.png" alt></p>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1367二叉树中的链表</title>
    <url>/2020/04/19/1367%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="1367二叉树中的链表"><a href="#1367二叉树中的链表" class="headerlink" title="1367二叉树中的链表"></a>1367二叉树中的链表</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><h3 id="下面是题目给出的代码模板"><a href="#下面是题目给出的代码模板" class="headerlink" title="下面是题目给出的代码模板"></a>下面是题目给出的代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="这种题目一般都有极其极其复杂的数据，所以递归是跑不了了"><a href="#这种题目一般都有极其极其复杂的数据，所以递归是跑不了了" class="headerlink" title="这种题目一般都有极其极其复杂的数据，所以递归是跑不了了"></a>这种题目一般都有极其极其复杂的数据，所以递归是跑不了了</h3><h5 id="这是第一种解法，利用dfs来判断"><a href="#这是第一种解法，利用dfs来判断" class="headerlink" title="这是第一种解法，利用dfs来判断"></a>这是第一种解法，利用dfs来判断</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	首先，isSubPath是主函数，主函数的作用就是判断整树是否符合条件</span></span><br><span class="line"><span class="comment">	isSUb是判断函数，也会自身调用判断，用来判断这个树的根节点是否符合条件（可能是子树的根节点）</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	因为树有很多分叉点，所以我们在没找到是否存在之前需要把所有的节点都判断一遍</span></span><br><span class="line"><span class="comment">	 return isSub(head,root)||isSubPath(head,root-&gt;left)||isSubPath(head,root-&gt;right);的作用就在于此，</span></span><br><span class="line"><span class="comment">	 我照着思路写的时候，一开始写的是isSub(head,root-&gt;left)||isSub(head,root-&gt;right)</span></span><br><span class="line"><span class="comment">	 这样是会报错的，因为这样只判断的这棵树的头节点和他的左右孩子节点，等于只判断了3个节点</span></span><br><span class="line"><span class="comment">	 但是我们题目中存在的情况可能是孩子结点的孩子节点是链表的头节点，这时候就出错了</span></span><br><span class="line"><span class="comment">	 所以我们要写isSubPath,这是判断整个子树的函数</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSub</span><span class="params">(ListNode *head,TreeNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果头节点为空，说明链表已经遍历完成，可以return true</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果node为空，那么说明这颗树的根是空的，不构成判断条件，return false</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果树根和链表val值不相等，从一开始就错了，那么这个节点就废了，return false</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val!=node-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//走到这一步，说明这个节点起码是符合的，所以我们要判断链表的下一个节点是否和这个树节点的左孩子或者右孩子相等</span></span><br><span class="line">        <span class="keyword">return</span> isSub(head-&gt;next,node-&gt;left)||isSub(head-&gt;next,node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head== <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//这里要做 大树的根节点的判断，然后要做两棵子树的判断</span></span><br><span class="line">        <span class="keyword">return</span> isSub(head,root)||isSubPath(head,root-&gt;left)||isSubPath(head,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>141环形链表</title>
    <url>/2020/04/20/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141环形链表"><a href="#141环形链表" class="headerlink" title="141环形链表"></a>141环形链表</h1><p><strong>写在前面</strong></p>
<p>因为原稿在操作时不慎丢失，所以忍痛再写！肯定不会比之前详细了</p>
<h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/20/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/1.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下面是题解"><a href="#下面是题解" class="headerlink" title="下面是题解"></a>下面是题解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *cur1 &#123;head&#125; ;<span class="comment">//cur1 是快指针</span></span><br><span class="line">        ListNode *cur2 &#123;head&#125;;<span class="comment">//cur2 是慢指针</span></span><br><span class="line">        <span class="keyword">if</span>(head||head-&gt;next)<span class="comment">//如果头节点就是空，那就直接输出false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 &amp;&amp;cur2 )</span><br><span class="line">         <span class="comment">// 当当前的快指针和快指针指向的空间不为空，那么就可以进行一种“追赶操作“，此外，在同一链表中使用快慢指针，可以确定链表的中心所在节点</span></span><br><span class="line">         <span class="comment">//这里需要注意，只能是先cur1！=NULL再写cur1-&gt;next!=NULL，这是有顺序的，反过来会报错！</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            cur1 = cur1-&gt;next;<span class="comment">//每次执行，快指针指向后面第二个空间</span></span><br><span class="line">            cur2 = cur2-&gt;next;<span class="comment">//慢指针指向后面第一个空间</span></span><br><span class="line">            <span class="comment">//如果这是一个循环链表，那么cur1，cur2一直处于一个循环的状态</span></span><br><span class="line">            <span class="comment">//而因为cur1跑得比cur2快，所以最终会追上cur2</span></span><br><span class="line">            <span class="comment">//所以当他们重合时，就是我们要证明的——是循环链表。</span></span><br><span class="line">            <span class="keyword">if</span>(cur1)</span><br><span class="line">            &#123;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur1 ==cur2)</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果到最后cur1指向的区域为NULL，那么很遗憾吗，跳出了循环，直接输出false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>1410HTML实体解析器</title>
    <url>/2020/05/04/1410HTML%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1410HTML实体解析器"><a href="#1410HTML实体解析器" class="headerlink" title="1410HTML实体解析器"></a>1410HTML实体解析器</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/05/04/1410HTML%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8/1.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="我最先想到的就是图存储"><a href="#我最先想到的就是图存储" class="headerlink" title="我最先想到的就是图存储"></a>我最先想到的就是图存储</h4><ul>
<li>先把元素一一对应</li>
<li>然后遍历text字符串</li>
<li>如果正常，就直接加在答案上</li>
<li>如果出现了&amp;,那么把从&amp;开始到; 的字符串交给新的字符串</li>
<li>判断字符串是否在map中存储<ul>
<li>如果发现了，那么改成对应的符号</li>
<li>否则保持原样，加在答案上</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> result=<span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;mp;</span><br><span class="line">    mp[<span class="string">"&amp;quot;"</span>]=<span class="string">"\""</span>;<span class="comment">//有个转移符号，很骚</span></span><br><span class="line">    mp[<span class="string">"&amp;apos;"</span>]=<span class="string">"'"</span>;</span><br><span class="line">    mp[<span class="string">"&amp;amp;"</span>]=<span class="string">"&amp;"</span>;</span><br><span class="line">    mp[<span class="string">"&amp;gt;"</span>]=<span class="string">"&gt;"</span>;</span><br><span class="line">    mp[<span class="string">"&amp;lt;"</span>]=<span class="string">"&lt;"</span>;</span><br><span class="line">    mp[<span class="string">"&amp;frasl;"</span>]=<span class="string">"/"</span>;</span><br><span class="line">    <span class="comment">//通过一个flag判断从&amp;开始到;结束中的字符串</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:<span class="built_in">text</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; c!=<span class="string">'&amp;'</span>)</span><br><span class="line">            result += c ;</span><br><span class="line">        <span class="comment">//如果没到底，那么继续加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag &amp;&amp; c!=<span class="string">';'</span>)</span><br><span class="line">            temp += c;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'&amp;'</span>)</span><br><span class="line">            flag=<span class="literal">true</span>,temp+=c;</span><br><span class="line">        <span class="comment">//加到底了，进行一个判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">';'</span>&amp;&amp; flag) &#123;</span><br><span class="line">            temp += c;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(temp) != mp.<span class="built_in">end</span>())</span><br><span class="line">                result += mp[temp];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += temp;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            temp = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>148链表排序</title>
    <url>/2020/04/19/148%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><h3 id="下面是题目给出的代码模板"><a href="#下面是题目给出的代码模板" class="headerlink" title="下面是题目给出的代码模板"></a>下面是题目给出的代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="因为我自己不会直接在链表上操作，所以我用了multiset存储"><a href="#因为我自己不会直接在链表上操作，所以我用了multiset存储" class="headerlink" title="因为我自己不会直接在链表上操作，所以我用了multiset存储"></a>因为我自己不会直接在链表上操作，所以我用了multiset存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">        ListNode*cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//首先，把所有的链表信息都存放在multiset中，因为multiset会自己排序</span></span><br><span class="line">            st.insert(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">         ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">         ListNode *head2 = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第二步，就是每次从set中取出一个数据，建立新的节点，然后尾插法</span></span><br><span class="line">            ListNode *newNode = <span class="keyword">new</span> ListNode(*it);</span><br><span class="line">            dummy-&gt;next= newNode;</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>147链表插入排序</title>
    <url>/2020/04/19/147%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="147-链表插入排序"><a href="#147-链表插入排序" class="headerlink" title="147.链表插入排序"></a>147.链表插入排序</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下面是对一个优质解答的分析"><a href="#下面是对一个优质解答的分析" class="headerlink" title="下面是对一个优质解答的分析"></a>下面是对一个优质解答的分析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	ListNode *dummyhead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//伪头指针</span></span><br><span class="line">	dummyhead-&gt;next = head;</span><br><span class="line">	ListNode *prev = head;</span><br><span class="line">	ListNode *node = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (node)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;val &lt; prev-&gt;val)</span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* temp = dummyhead;<span class="comment">//！！temp要等于dummyhead，这样才可以比较第一个元素</span></span><br><span class="line">			<span class="keyword">while</span> (temp-&gt;next-&gt;val &lt; node-&gt;val)<span class="comment">//！！！这里是temp-&gt;next：因为要修改前面的temp的指向</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp = temp-&gt;next;<span class="comment">//指针后移</span></span><br><span class="line">			&#125;</span><br><span class="line">			prev-&gt;next = node-&gt;next;</span><br><span class="line">			node-&gt;next = temp-&gt;next;</span><br><span class="line">			temp-&gt;next = node;</span><br><span class="line">			node = prev-&gt;next;<span class="comment">//此时不用改变prev指向！因为prev没有变，只是待排序元素变了位置。</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			prev = prev-&gt;next;</span><br><span class="line">			node = node-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummyhead-&gt;next;<span class="comment">//!!!不能返回head！！因为后面会改变head所指向内存的位置！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>155最小栈</title>
    <url>/2020/04/22/155%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="155最小栈"><a href="#155最小栈" class="headerlink" title="155最小栈"></a>155最小栈</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/22/155%E6%9C%80%E5%B0%8F%E6%A0%88/155.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="优质解答分析"><a href="#优质解答分析" class="headerlink" title="优质解答分析"></a>优质解答分析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目要求我们来写一个类，我们就在类里面写方法，把这个类想成一个黑匣子</span></span><br><span class="line"><span class="comment">//外面的人想要什么，调用这个类里的方法，我们就返回什么，我们怎么返回的，外面管不着</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="comment">//于是我们想到用对去构造一个栈，每次把&lt;当前栈的最小值，当前栈的顶部&gt;入栈</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = INT_MAX;</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; minStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果出现了新的最小值，那么把min更新</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">min</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//每次压入当前的最小值，栈顶这一个对</span></span><br><span class="line">        minStack.push(make_pair(<span class="built_in">min</span>, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line"><span class="comment">//每次pop需要判断栈是否为空，如果栈空，那么把最小值设为无限大</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.empty()) &#123;</span><br><span class="line">            <span class="built_in">min</span> = INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则，把最小值设置为栈顶的min值</span></span><br><span class="line"><span class="comment">//这样，如果刚才被pop掉的不是最小值，那么min不变，否则变成倒数第二小的</span></span><br><span class="line">            <span class="built_in">min</span> = minStack.top().first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top().second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>143重排链表</title>
    <url>/2020/04/19/143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="143-重排列表"><a href="#143-重排列表" class="headerlink" title="143.重排列表"></a>143.重排列表</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/19/143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/1.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>我首先想到了反转链表，然后拉链法互相指，在原理上是可行的，但是需要两根链表，题目只给我们一根，如果要再建立一根一模一样的再反转，显然太麻烦。所以我看了解题思路。</li>
</ul>
<h4 id="第一种，就是多次遍历"><a href="#第一种，就是多次遍历" class="headerlink" title="第一种，就是多次遍历"></a>第一种，就是多次遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *first = head;</span><br><span class="line">        ListNode *last = head;</span><br><span class="line">        <span class="comment">//首先让头尾节点都指向头，然后呢，每次都将尾节点移到末尾，让头节点指向尾节点。然后更新头节点</span></span><br><span class="line">        <span class="keyword">while</span>(first&amp;&amp;first-&gt;next&amp;&amp;first-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在这里新建一个临时节点，它的作用就是指向最后一个节点的前一个节点，然后“脱钩”</span></span><br><span class="line">            ListNode *temp ;</span><br><span class="line">            <span class="keyword">while</span>(last-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                temp= last ;</span><br><span class="line">                last =last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时候，尾节点是独立出来的，倒数第二个节点成为了尾节点</span></span><br><span class="line">            <span class="comment">//这时候尾节点已经不是原来的尾节点了！实现了尾节点的更新</span></span><br><span class="line">            temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//现在，让尾节点和头节点的next相连</span></span><br><span class="line">            last-&gt;next = first -&gt;next;</span><br><span class="line">            <span class="comment">//让头结点指向尾节点</span></span><br><span class="line">            first-&gt;next = last;</span><br><span class="line">            <span class="comment">//更新头结点的操作，然后进行下一次操作</span></span><br><span class="line">            first = first-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="第二种，把链表一分二，拉链法"><a href="#第二种，把链表一分二，拉链法" class="headerlink" title="第二种，把链表一分二，拉链法"></a>第二种，把链表一分二，拉链法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种方法很巧妙，我虽然想到了拉链法，但我的出发点是建立两个链表，然后拉链法都取一半</span></span><br><span class="line"><span class="comment">//其实只要再向前想一部就好了，可以先利用快慢节点找到链表的中间位置，然后砍断</span></span><br><span class="line"><span class="comment">//再反转后半链表，形成新的链表</span></span><br><span class="line"><span class="comment">//然后继续拉链法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> p;</span><br><span class="line">        ListNode *p3=p-&gt;next;</span><br><span class="line">        ListNode *p2=reverse(p-&gt;next);</span><br><span class="line">        p3-&gt;next=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">      	<span class="comment">//这个判断条件一定要写</span></span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next||!head-&gt;next-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 利用快慢节点</span></span><br><span class="line">        <span class="comment">//当偶数时，fast最终是NULL，slow 最后是一半之前的那个节点</span></span><br><span class="line">        <span class="comment">//当奇数时，fast最终是最后一个节点，slow正好指向正中间</span></span><br><span class="line">       <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast节点没有利用价值，新链表是从慢节点的下一个节点开始的</span></span><br><span class="line">        ListNode*head2 = slow-&gt;next;</span><br><span class="line">        <span class="comment">//这一句很重要，标志着一分为二</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//对新链表进行反转</span></span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        <span class="comment">//因为是void操作，所以要保留head，用迭代器操作</span></span><br><span class="line">        ListNode *p1 = head,*p2 = head2;        </span><br><span class="line">        <span class="comment">//当有一方指向NULL，就说明操作结束了</span></span><br><span class="line">        <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">        &#123;</span><br><span class="line">	<span class="comment">// 		需要建立两个临时节点</span></span><br><span class="line">            ListNode *tempH1 = p1-&gt;next;</span><br><span class="line">            ListNode *tempH2 = p2-&gt;next;</span><br><span class="line">            p1-&gt;next = p2;</span><br><span class="line">            p2-&gt;next = tempH1;、</span><br><span class="line">           <span class="comment">//更新两个节点位置</span></span><br><span class="line">            p1 = tempH1;</span><br><span class="line">            p2 = tempH2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>160相交lianbiao</title>
    <url>/2020/04/20/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/20/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先我们要明白一个概念，什么是题目给出的相交节点？那就是地址是一样的，而不是val值一样的节点，这点非常关键，那么我们就要去找一下地址重合的那个节点</li>
</ul>
<p><img src="/2020/04/20/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160%E6%80%9D%E8%B7%AF.png" alt></p>
<h4 id="下面是给出的解"><a href="#下面是给出的解" class="headerlink" title="下面是给出的解"></a>下面是给出的解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *commonNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> countA = <span class="number">0</span>, countB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//老样子，双指针，解法</span></span><br><span class="line">        <span class="keyword">if</span>(headA!=<span class="literal">nullptr</span>&amp;&amp;headB!= <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//首先，我们要分别计算两个链表的长度</span></span><br><span class="line">            <span class="keyword">int</span> countA = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> countB = <span class="number">0</span>;</span><br><span class="line">            ListNode *ptA = headA;</span><br><span class="line">            ListNode *ptB = headB;</span><br><span class="line">            <span class="keyword">while</span>(ptA!= <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ptA=ptA-&gt;next;</span><br><span class="line">                countA++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(ptB!= <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ptB=ptB-&gt;next;</span><br><span class="line">                countB++;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//计算完成后，两个都从头开始</span></span><br><span class="line">             ptA = headA;</span><br><span class="line">             ptB = headB;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">abs</span>(countA-countB);</span><br><span class="line">            <span class="keyword">if</span>(countA&gt;countB)<span class="comment">//如果A比B长，那么A先走多出来的步数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;temp;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                   ptA =ptA-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span><span class="comment">//否则，B先走多出来的步数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;temp;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptB =ptB-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//现在两条链表的后续长度是一样的了，他们会同时走到commonnode，这时候我们只要</span></span><br><span class="line">            <span class="comment">//简单的做一个判断，就可以返回了！</span></span><br><span class="line">            <span class="keyword">while</span> (ptA!= <span class="literal">nullptr</span> &amp;&amp;ptB!= <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">if</span>(ptA==ptB)</span><br><span class="line">                 &#123;</span><br><span class="line">                     commonNode =ptA;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 ptA=ptA-&gt;next;</span><br><span class="line">                 ptB=ptB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当然，如果上面没找到，呢么commonnode肯定是NULL了，直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> commonNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>17.09第k个数</title>
    <url>/2020/04/20/17-09%E7%AC%ACk%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/20/17-09%E7%AC%ACk%E4%B8%AA%E6%95%B0/k.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用BFS-set可以完美遍历，真的太爽了"><a href="#用BFS-set可以完美遍历，真的太爽了" class="headerlink" title="用BFS+set可以完美遍历，真的太爽了"></a>用BFS+set可以完美遍历，真的太爽了</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	  <span class="function"><span class="keyword">int</span> <span class="title">getKthMagicNumber</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//有个小细节需要注意，那就是s.begin（）返回的是迭代器     //如果要在迭代器中取物，那么就要用 *     </span></span><br><span class="line"><span class="comment">//可能数字会很大，我们用long long 存储</span></span><br><span class="line">    	  <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;s;</span><br><span class="line">          s.insert(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span>(k--)</span><br><span class="line">          &#123;</span><br><span class="line"><span class="comment">//利用set，完美解决了去重复、小到大排序的问题              </span></span><br><span class="line">              ans = *s.<span class="built_in">begin</span>();</span><br><span class="line">              s.erase(s.<span class="built_in">begin</span>);</span><br><span class="line">              s.insert(ans*<span class="number">3</span>);</span><br><span class="line">              s.insert(ans*<span class="number">5</span>);</span><br><span class="line">              s.insert(ans*<span class="number">7</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Queue</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>19删除链表的倒数第N个节点</title>
    <url>/2020/04/19/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/19/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="我自己做的时候，用了一种不太美观的代码搞出来了"><a href="#我自己做的时候，用了一种不太美观的代码搞出来了" class="headerlink" title="我自己做的时候，用了一种不太美观的代码搞出来了"></a>我自己做的时候，用了一种不太美观的代码搞出来了</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为分了很多类别，我不想过细的去讨论这个代码</span></span><br><span class="line"><span class="comment">//但整体的思路，就是先遍历一遍取节点个数，再遍历一遍找到节点，删除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode*cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>&amp;&amp;n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count<span class="number">-2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cur= cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count-n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *toDelete = <span class="literal">NULL</span>;</span><br><span class="line">            toDelete = cur-&gt;next;</span><br><span class="line">            cur-&gt;val = toDelete-&gt;val;</span><br><span class="line">            cur-&gt;next = toDelete-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> toDelete;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下面是改良版，看这个！"><a href="#下面是改良版，看这个！" class="headerlink" title="下面是改良版，看这个！"></a>下面是改良版，看这个！</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经过改良之后，会有更简单的 出现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先仍然是统计长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode *cur = head, *toDelete = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在 len = 总长度-1；</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">//这里，len+2-n 就是需要循环的次数。也就是说，n越大，需要循环次数越少</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len+<span class="number">2</span>-n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果第一个节点就是要求被删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(len+<span class="number">1</span>==n) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">            <span class="comment">//这个代码需要画一下，就是说，如果当前节点的下一个节点是要被删除的</span></span><br><span class="line">            <span class="comment">//完整版就是 i+1 == len + 1 - n; 简化后，就是i == len - n;</span></span><br><span class="line">            <span class="keyword">if</span>(i==len-n)</span><br><span class="line">            &#123;</span><br><span class="line">                toDelete = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = toDelete -&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> toDelete ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="用快慢指针的方法，只需要循环一次就能办到"><a href="#用快慢指针的方法，只需要循环一次就能办到" class="headerlink" title="用快慢指针的方法，只需要循环一次就能办到"></a>用快慢指针的方法，只需要循环一次就能办到</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先建立一个dummyNode </span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//然后建立两个节点：快捷点和慢节点。</span></span><br><span class="line">        ListNode *second = dummyNode;</span><br><span class="line">        ListNode *first = dummyNode;</span><br><span class="line">        dummyNode -&gt;next = head;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	敲桌板的东西来了</span></span><br><span class="line"><span class="comment">        	设 链表的节点数为len</span></span><br><span class="line"><span class="comment">        	我们知道，在建立了dummyNode后，从dummyNode走到NUll 需要走len+1布</span></span><br><span class="line"><span class="comment">        	现在，让快捷点先走n+1 步</span></span><br><span class="line"><span class="comment">        	然后，快慢节点同时运动，一直到快节点指向NULL时停止</span></span><br><span class="line"><span class="comment">        	可知：现在慢节点走了 len-n 步，也就是说，位于第len-n个节点（0节点也包含在内）</span></span><br><span class="line"><span class="comment">        	要知道，要删除的节点n位于的时第len-n+1个节点</span></span><br><span class="line"><span class="comment">        	所以说，现在只要删除慢节点后面那个节点，就大功告成了！！！！！！！！！！</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first)</span><br><span class="line">        &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp = second-&gt;next;</span><br><span class="line">        second-&gt;next= second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="comment">//下面其实可有可无，只是要不要保留dummyNode 的问题</span></span><br><span class="line">        ListNode *res = dummyNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyNode;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>206反转链表</title>
    <url>/2020/04/20/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206反转链表"><a href="#206反转链表" class="headerlink" title="206反转链表"></a>206反转链表</h1><p><strong>写在前面</strong></p>
<ul>
<li>这篇的原文也在搭建博客中不幸牺牲</li>
<li>但是我还会简单注释一下</li>
<li>反转链表的作用很多，可以当作别的题目的子函数，比如回文，分隔等等</li>
</ul>
<h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/20/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/206.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里我会给出三种解法，分别是迭代法，递归法和双指针法</li>
</ul>
<h4 id="1-迭代法"><a href="#1-迭代法" class="headerlink" title="1.迭代法"></a>1.迭代法</h4><p><img src="/2020/04/20/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/206%E8%BF%AD%E4%BB%A3%E6%B3%95.gif" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//首先令一个临时节点指向 p后面的一个节点</span></span><br><span class="line">            ListNode *temp = p-&gt;next;</span><br><span class="line">            <span class="comment">//然后改变p的指针，当p为头节点的时候，那么p指向空。最后，原来的头节点就是尾巴节点</span></span><br><span class="line">            <span class="comment">//原来的尾节点就是新链表的头节点</span></span><br><span class="line">            p-&gt;next =cur;</span><br><span class="line">            <span class="comment">//然后每次要更新cur节点和p节点</span></span><br><span class="line">            cur=p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2. 递归法"></a>2. 递归法</h4><p><img src="/2020/04/20/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/206%E9%80%92%E5%BD%92%E6%B3%95.gif" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next ==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode*ret = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-双指针法"><a href="#3-双指针法" class="headerlink" title="3.双指针法"></a>3.双指针法</h4><p><img src="/2020/04/20/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/206%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针法比较巧妙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *cur =head;</span><br><span class="line">    <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;<span class="comment">//接下来的注释是基于第一次变换的</span></span><br><span class="line">        <span class="comment">//仍然令一个临时节点，让他指向头结点的下下个节点，方便节点更新</span></span><br><span class="line">        <span class="comment">//注意，这时候原链表的结构还没有发生改变</span></span><br><span class="line">        ListNode*t =head-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">//然后这个操作是让第二个节点指向cur，在这里暂时形成了一个闭环</span></span><br><span class="line">        head-&gt;next-&gt;next = cur;</span><br><span class="line">        <span class="comment">//然后实现head指针的断裂，这时候其实是一个自环</span></span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        <span class="comment">//最后，更新head的指针，让他指向t</span></span><br><span class="line">        head-&gt;next = t;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//接下来的每一次循环，都实现了一次链表的暂时闭环和cur节点的移动</span></span><br><span class="line"><span class="comment">//同时，head-&gt;next也一步步指向尾节点</span></span><br><span class="line"><span class="comment">//最后，cur节点成功成为尾节点，并且cur前面的所有指针都实现了反指</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>20有效的括号</title>
    <url>/2020/04/22/20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h1><p><img src="/2020/04/22/20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/20.png" alt></p>
<h2 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="我第一时间觉得既然（）-需要相互配对，为什么不用map存储呢？"><a href="#我第一时间觉得既然（）-需要相互配对，为什么不用map存储呢？" class="headerlink" title="我第一时间觉得既然（）{} []需要相互配对，为什么不用map存储呢？"></a>我第一时间觉得既然（）{} []需要相互配对，为什么不用map存储呢？</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经过几次修改后，时间空间100%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt;m;</span><br><span class="line">        m.insert(pair&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt;(<span class="string">'['</span>,<span class="string">']'</span>));</span><br><span class="line">        m.insert(pair&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt;(<span class="string">'('</span>,<span class="string">')'</span>));</span><br><span class="line">        m.insert(pair&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt;(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>));</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> n : s)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//如果是左半部分的括号的话，那么我们先把它入栈</span></span><br><span class="line">            <span class="keyword">if</span>(n==<span class="string">'&#123;'</span>||n==<span class="string">'['</span>||n==<span class="string">'('</span>)</span><br><span class="line">                a.push(n);</span><br><span class="line"><span class="comment">//如果是右半部分的括号，先别着急，我们还要判断栈里面是不是有元素            </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="string">'&#125;'</span>||n==<span class="string">']'</span>||n==<span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="comment">//有元素而且匹配上了，那么才能出栈</span></span><br><span class="line">                <span class="keyword">if</span> (!a.empty()&amp;&amp;n==m[a.top()])</span><br><span class="line">                &#123;</span><br><span class="line">                    a.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//任何一个条件不满足的话，就直接返回false</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后判断是否非空，如果栈内还有元素，说明false，要不然说明都对齐消除了</span></span><br><span class="line">        <span class="keyword">return</span> !a.empty()? <span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>21合并两个有序链表</title>
    <url>/2020/04/19/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><p><img src="/2020/04/19/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/21.png" alt></p>
<p>该很简单，但是如何写的优雅呢？</p>
<p>这是leetcode给出的默认代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们可以看到返回值是ListNode*，那么我们最好要创建一个新的链表来存储两个链表的值。因为先存储再排序很麻烦，我们直接来实现每当插入一个数的时候，进行一个判断。这样，直接return 新链表的节点就可以了</p>
</li>
<li><pre><code class="C++"><span class="comment">/**</span>
<span class="comment"> * Definition for singly-linked list.</span>
<span class="comment"> * struct ListNode {</span>
<span class="comment"> *     int val;</span>
<span class="comment"> *     ListNode *next;</span>
<span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span>
<span class="comment"> * };</span>
<span class="comment"> */</span>
<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>
<span class="keyword">public</span>:
    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{
        ListNode *mix = <span class="keyword">new</span> ListNode(<span class="number">0</span>);
        ListNode *cur = mix;
        <span class="keyword">while</span>(l1&amp;&amp;l2)
        {
            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<span class="comment">//当l1的值小于l2的节点值得时候，把l1插入新链表</span>
            {
                cur-&gt;next = l1;
                l1=l1-&gt;next;
            } <span class="keyword">else</span><span class="comment">//否则，插入l2 得节点值</span>
            {
                cur-&gt;next =l2;
                l2 = l2-&gt;next;
            }
            cur = cur-&gt;next;<span class="comment">//每次插入后，把节点指向下一个空间</span>
        }
        cur-&gt;next = l1?l1:l2;<span class="comment">//如果l1，l2有一个被读完了，就会跳出循环</span>
        <span class="comment">//那么，剩下的所有节点都插入到新的链表当中去</span>
        <span class="comment">//就是说，如果cur-&gt;next = l1 的话，</span>
        <span class="keyword">return</span> mix-&gt;next;
    }

};</code></pre>
</li>
<li><p>当然，这个解法存在内存泄露的缺点。</p>
</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>225用队列实现栈</title>
    <url>/2020/04/22/225%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>232用栈实现队列</title>
    <url>/2020/04/22/232%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>24亮亮交换链表中的节点</title>
    <url>/2020/04/19/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><h3 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h3><h3 id="下面是给出的代码模板"><a href="#下面是给出的代码模板" class="headerlink" title="下面是给出的代码模板"></a>下面是给出的代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="我们用两种方法来解决这道题目"><a href="#我们用两种方法来解决这道题目" class="headerlink" title="我们用两种方法来解决这道题目"></a>我们用两种方法来解决这道题目</h3><h4 id="第一种，迭代法"><a href="#第一种，迭代法" class="headerlink" title="第一种，迭代法"></a>第一种，迭代法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里，我们新建一个列表，来存储改变后的链表</span></span><br><span class="line">        ListNode* p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//p是有0节点的，p-&gt;next 是 head的头节点</span></span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        <span class="comment">// 再新建一个节点，让他等于p的头节点</span></span><br><span class="line">        ListNode*cur = p;</span><br><span class="line">        <span class="comment">//下面开始迭代</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立两个节点，分别是左节点和右节点。</span></span><br><span class="line">            ListNode *leftNode = head;</span><br><span class="line">            ListNode*rightNode = head-&gt;next;</span><br><span class="line">            <span class="comment">//在交换之前，我们要考虑一个问题，怎么让p保存每个节点的值？</span></span><br><span class="line">            <span class="comment">//所以，我们先用cur节点指向右节点，当节点交换后，cur节点指向的就是新链表的第一个节点了</span></span><br><span class="line">            cur-&gt;next = rightNode ;</span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            leftNode-&gt;next = rightNode-&gt;next;</span><br><span class="line">            rightNode-&gt;next = leftNode;</span><br><span class="line">            <span class="comment">//把cur想象成一个迭代器，然后每次在执行完p链表中更新两个节点</span></span><br><span class="line">            <span class="comment">//现在，完成任务后，把cur指向最后一个节点</span></span><br><span class="line">            cur = leftNode;</span><br><span class="line">            <span class="comment">//最后，把head指向更新完后的节点的下一节点</span></span><br><span class="line">            head = leftNode-&gt;next;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="第二种，递归法"><a href="#第二种，递归法" class="headerlink" title="第二种，递归法"></a>第二种，递归法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断head和head-&gt;next 是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//新建p节点，让p指向第二个节点 </span></span><br><span class="line">           ListNode*p = head-&gt;next;</span><br><span class="line">        <span class="comment">//然后，需要截取p后的链表</span></span><br><span class="line">           ListNode *temp = p-&gt;next;</span><br><span class="line">        <span class="comment">//进行两个节点的交换</span></span><br><span class="line">           p-&gt;next =head;</span><br><span class="line">        <span class="comment">//然后，head要指向交换完后的temp链表</span></span><br><span class="line">           head-&gt;next = swapPairs(temp);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>2两数相加</title>
    <url>/2020/04/19/2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="两数相加I-和II"><a href="#两数相加I-和II" class="headerlink" title="两数相加I 和II"></a>两数相加I 和II</h1><h2 id="下面是题目I-和题目II"><a href="#下面是题目I-和题目II" class="headerlink" title="下面是题目I 和题目II"></a>下面是题目I 和题目II</h2><p><img src="/2020/04/19/2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0I.png" alt></p>
<ul>
<li>这题比较折磨我，因为我一开始的思路，是用一个整型直接存储两个链表的数字，然后加起来，后来发现有类似于10000000000000这样的数据。让我不管取多大的，都会被越界。后来找了题解，给出几种解法</li>
</ul>
<h4 id="1-1利用位数补齐的方法。然后分别计算位数"><a href="#1-1利用位数补齐的方法。然后分别计算位数" class="headerlink" title="1-1利用位数补齐的方法。然后分别计算位数"></a>1-1利用位数补齐的方法。然后分别计算位数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们首先要明白l1，l2 都是倒序，所以补齐的时候只要再尾部插0就行了</span></span><br><span class="line"><span class="comment">//输出也是倒叙，所以从第一位开始加，进行计算就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">1</span>;</span><br><span class="line">        ListNode *p1 = l1;</span><br><span class="line">        ListNode *p2 = l2;</span><br><span class="line">        <span class="comment">//首先我们来计算位数！</span></span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p1= p1-&gt;next;</span><br><span class="line">            len1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            len2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当l1比l2长的时候，在l2 后面补上0</span></span><br><span class="line">        <span class="keyword">if</span>(len1&gt;len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=len1-len2;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p2-&gt;next =<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">               p2 = p2 -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span><span class="comment">//否则，就再l1 后面补0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=len2-len1;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                p1= p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p1= l1; p2 = l2;</span><br><span class="line">        <span class="keyword">bool</span> count = <span class="literal">false</span>;<span class="comment">//count计算进位</span></span><br><span class="line">        ListNode *l3 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//新建链表</span></span><br><span class="line">        ListNode *cur = l3;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对于每个位，都计算，注意，如果count为1，就说明上一位有进位，所以要加上1</span></span><br><span class="line">            i = p1-&gt;val+p2-&gt;val+count;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(i%<span class="number">10</span>);</span><br><span class="line">            count= i&gt;=<span class="number">10</span>? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果末位还有进位，那么要再尾插一个1，因为两&lt;10整数相加最大为18</span></span><br><span class="line">        <span class="keyword">if</span>(count)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-不使用补齐的方法，来试试"><a href="#1-2-不使用补齐的方法，来试试" class="headerlink" title="1-2 不使用补齐的方法，来试试"></a>1-2 不使用补齐的方法，来试试</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *l3 =  <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = l3;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">bool</span> count = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//这里，让l1或者l2不为空，就进行操作</span></span><br><span class="line">        <span class="comment">//其余的方法，和补齐的一样</span></span><br><span class="line">        <span class="keyword">while</span>(l1||l2)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum+ l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum+l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count)</span><br><span class="line">                sum++;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>) ;</span><br><span class="line">            count = sum&gt;=<span class="number">10</span>? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count)</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="/2020/04/19/2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/D:%5Cprojects%5CJasonXQH.github.io%5Csource%5Cimages%5C2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II.png" alt="2.两数相加II"></p>
<h3 id="这个题，用老思路也是可以做的，但是。。确实麻烦"><a href="#这个题，用老思路也是可以做的，但是。。确实麻烦" class="headerlink" title="这个题，用老思路也是可以做的，但是。。确实麻烦"></a>这个题，用老思路也是可以做的，但是。。确实麻烦</h3><ol>
<li>反转两个链表</li>
<li>把两个链表安位次相加，得到新链表</li>
<li>把新链表反转后输出。</li>
<li>累死，还不一定对</li>
<li>但是，我们已经写好了反转链表的函数，和相加链表的函数。所以我们直接拿来用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这是 206 反转链表的代码</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是问题I中的代码</span></span><br><span class="line">     <span class="function">ListNode* <span class="title">add_Two_Numbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *l3 =  <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = l3;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">bool</span> count = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum+ l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum+l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count)</span><br><span class="line">                sum++;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>) ;</span><br><span class="line">            count = sum&gt;=<span class="number">10</span>? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count)</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后来写II的代码，那就很简单了</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先反转l1，l2</span></span><br><span class="line">        l1 = reverseList(l1);</span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        <span class="comment">//然后进行相加操作</span></span><br><span class="line">        ListNode *head = add_Two_Numbers(l1,l2);</span><br><span class="line">        l1 = reverseList(l1);</span><br><span class="line">        l2  = reverseList(l2);</span><br><span class="line">        <span class="comment">//最后，把相加后的返回</span></span><br><span class="line">        <span class="keyword">return</span> reverseList(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="虽然上面思路简单，但是太过于笨重，下面用两个链表的新的栈来实现"><a href="#虽然上面思路简单，但是太过于笨重，下面用两个链表的新的栈来实现" class="headerlink" title="虽然上面思路简单，但是太过于笨重，下面用两个链表的新的栈来实现"></a>虽然上面思路简单，但是太过于笨重，下面用两个链表的新的栈来实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//首先，建立两个栈，然后把l1，l2 中的所有节点值入栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="keyword">while</span> (l1)</span><br><span class="line">    &#123;</span><br><span class="line">        stack1.push(l1-&gt;val);</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">    <span class="keyword">while</span> (l2)</span><br><span class="line">    &#123;</span><br><span class="line">        stack2.push(l2-&gt;val);</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* newList = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//然后进行每个栈的top 元素相加</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty() || !stack2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = stack1.empty() ? <span class="number">0</span> : stack1.top();</span><br><span class="line">        <span class="keyword">int</span> y = stack2.empty() ? <span class="number">0</span> : stack2.top();</span><br><span class="line">        <span class="keyword">if</span> (!stack1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val = x + y + carry;</span><br><span class="line">        carry = val / <span class="number">10</span>;<span class="comment">//判断是否要进位</span></span><br><span class="line">		<span class="comment">//先让一个临时节点指向原节点</span></span><br><span class="line">        temp= newList;</span><br><span class="line">        <span class="comment">//然后再新建一个节点，让他等于要头插的元素</span></span><br><span class="line">        newList = <span class="keyword">new</span> ListNode(val % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最后让这个新的节点指向原链表</span></span><br><span class="line">        newList-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果最后一位要进1，再头插一个1</span></span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = newList;</span><br><span class="line">        newList = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        newList-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//最后返回新链表</span></span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>328奇偶链表</title>
    <url>/2020/04/19/328%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328.奇偶链表"></a>328.奇偶链表</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="看了几种方法，都大同小异，无非是代码量的区别，这里给出一种简单易懂的代码"><a href="#看了几种方法，都大同小异，无非是代码量的区别，这里给出一种简单易懂的代码" class="headerlink" title="看了几种方法，都大同小异，无非是代码量的区别，这里给出一种简单易懂的代码"></a>看了几种方法，都大同小异，无非是代码量的区别，这里给出一种简单易懂的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *even = head-&gt;next;</span><br><span class="line">        ListNode *even_head = head-&gt;next;</span><br><span class="line">        ListNode *odd = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(even==<span class="literal">NULL</span>||even-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;<span class="comment">//遍历完成后，把odd和even的头节点连起来，再return head</span></span><br><span class="line">                odd-&gt;next = even_head;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交错插入，形象的说法就是拉链算法</span></span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>331验证二叉树的前序序列化</title>
    <url>/2020/04/22/331%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>341扁平化嵌套列表迭代器</title>
    <url>/2020/04/22/341%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>385迷你语法分析器</title>
    <url>/2020/04/22/385%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>394字符串解码</title>
    <url>/2020/04/22/394%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394 字符串解码"></a>394 字符串解码</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/22/394%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/.%5C394%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%5C394.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><ol>
<li>这题不看题解我真滴很难做，思路是有一点，但是要把它编程代码其实不简单！贴一下大佬的代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; pis;</span><br><span class="line">    <span class="comment">//将字符串str重复times次</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">repeat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> retString = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i) retString += str;</span><br><span class="line">        <span class="keyword">return</span> retString;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先思考：栈应存储什么元素，何时进栈、出栈</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> repeatTims = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pis&gt; vecStack;   <span class="comment">//用vector代替stack，更高效，因为stack底层可以是vector</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="comment">//计算字符串需要重复的次数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">'0'</span>&lt;=i &amp;&amp; i&lt;=<span class="string">'9'</span>) repeatTims = (repeatTims*<span class="number">10</span>)+(i-<span class="string">'0'</span>);  </span><br><span class="line">            <span class="comment">//如果遇到[的话，我们要把现有的res和需要重复[]中元素的次数 入栈，res可以为""</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="string">'['</span>) &#123;</span><br><span class="line">                vecStack.push_back(&#123;repeatTims,res&#125;);</span><br><span class="line"><span class="comment">//进栈后要更新res和repeatTimes，并不担心最后返回的res为空，因为之前更新的res在遇到'['又会被进栈</span></span><br><span class="line">                <span class="comment">//不懂这问题的可以手动模拟一下这个样例：3[a]2[bc]ef</span></span><br><span class="line">                <span class="comment">//实现下一层遍历之前，要初始化res和repeatTimes</span></span><br><span class="line">                res = <span class="string">""</span>;</span><br><span class="line">                repeatTims = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是]的话，这时候的res就是[]中的字符串了，我们要把他重复</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="comment">//把相当于取top()</span></span><br><span class="line">                pis tmp = vecStack[vecStack.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">                vecStack.pop_back();</span><br><span class="line">                res = tmp.second + (tmp.first==<span class="number">0</span> ? <span class="string">""</span> : repeat(res, tmp.first));a</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*我们拿s = "3[a2[c]]"手动模拟一遍</span></span><br><span class="line"><span class="comment">拿到3，repeattime = 3</span></span><br><span class="line"><span class="comment">拿到[,把(3,"")入栈，res="",repeattime = 0</span></span><br><span class="line"><span class="comment">拿到a，res=a</span></span><br><span class="line"><span class="comment">拿到2，repeattime=2</span></span><br><span class="line"><span class="comment">拿到[,把(2,a)入栈，res="",repeattime = 0</span></span><br><span class="line"><span class="comment">拿到c.res=c</span></span><br><span class="line"><span class="comment">拿到],res=a+repeat(c,2)=acc</span></span><br><span class="line"><span class="comment">拿到],res=""+repeat(acc,3)=accaccacc</span></span><br><span class="line"><span class="comment">结束</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">再拿2[abc]3[cd]ef举例子</span></span><br><span class="line"><span class="comment">拿到2，repreattime = 2</span></span><br><span class="line"><span class="comment">拿到[,把(2,"")入栈，res="",repeattime = 0;</span></span><br><span class="line"><span class="comment">拿到a,res=a</span></span><br><span class="line"><span class="comment">拿到b，res=ab</span></span><br><span class="line"><span class="comment">拿到c，res=abc</span></span><br><span class="line"><span class="comment">拿到],把(2,"")出栈，res=""+repeat(2,"abc")=abcabc</span></span><br><span class="line"><span class="comment">拿到3，repeattime = 3</span></span><br><span class="line"><span class="comment">拿到[，把(3,"abcabc")入栈，res="",repeattime = 0;</span></span><br><span class="line"><span class="comment">拿到c，res= c;</span></span><br><span class="line"><span class="comment">拿到d，res=cd;</span></span><br><span class="line"><span class="comment">拿到],把(3,"abcabc")出栈，res=abcabc+repeat(3,cd)=abcabccdcdcd</span></span><br><span class="line"><span class="comment">拿到e，res=abcabccdcdcde</span></span><br><span class="line"><span class="comment">拿到f，res=abcabccdcdcdef</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="利用栈解法"><a href="#利用栈解法" class="headerlink" title="利用栈解法"></a>利用栈解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用辅助栈的解法，同样用两个例子分析</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; numStack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; resStack;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">            res.push_back(s[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">            resStack.push(res);</span><br><span class="line">            res = <span class="string">""</span>;</span><br><span class="line">            numStack.push(num);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numStack.top(); j++) &#123;</span><br><span class="line">                resStack.top() += res;</span><br><span class="line">            &#125;</span><br><span class="line">            numStack.pop();</span><br><span class="line">            res = resStack.top();</span><br><span class="line">            resStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们拿s = "3[a2[c]]"手动模拟一遍</span></span><br><span class="line"><span class="comment">拿到3，发现是数字，于是num=3</span></span><br><span class="line"><span class="comment">拿到[，resStack.push(""),numstack.push(3),num=0;</span></span><br><span class="line"><span class="comment">拿到a，是字符，那么res=a</span></span><br><span class="line"><span class="comment">拿到2，是数字，那么sum=2</span></span><br><span class="line"><span class="comment">拿到[,resStack.push("a"),numstack.push(2),num=0,res=""</span></span><br><span class="line"><span class="comment">拿到c，res=c</span></span><br><span class="line"><span class="comment">拿到],resStack.top()=a+2*c=acc ,res=resStack.top()=acc,resStack.pop()</span></span><br><span class="line"><span class="comment">拿到],resStack.top()=""+3*acc=accaccacc,res=resStack.top()=acc,resStack.pop()</span></span><br><span class="line"><span class="comment">最后，return res</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="综上，我们可以看到其实这两种方法的本质都是相似的，只是一个利用pair存储，一个用两个栈分别存储数字和字符串"><a href="#综上，我们可以看到其实这两种方法的本质都是相似的，只是一个利用pair存储，一个用两个栈分别存储数字和字符串" class="headerlink" title="综上，我们可以看到其实这两种方法的本质都是相似的，只是一个利用pair存储，一个用两个栈分别存储数字和字符串"></a>综上，我们可以看到其实这两种方法的本质都是相似的，只是一个利用pair存储，一个用两个栈分别存储数字和字符串</h3>]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>402移掉K位数字</title>
    <url>/2020/04/22/402%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>496下一个更大的数</title>
    <url>/2020/04/21/496%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="496下一个更大的数"><a href="#496下一个更大的数" class="headerlink" title="496下一个更大的数"></a>496下一个更大的数</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/21/496%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0/.%5C496%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0%5C496.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="先讲讲我拿到这道题的思路"><a href="#先讲讲我拿到这道题的思路" class="headerlink" title="先讲讲我拿到这道题的思路"></a>先讲讲我拿到这道题的思路</h4><ul>
<li>像我这种基本数据结构都不太会用的垃圾，拿到这种题最先想到的就是BF，但是我没想到自己得BF功底都这么差，写完以后 运行时间达到了惊人的100ms和27MB，着实显示了我的无能！</li>
</ul>
<h4 id="其实BF也可以很好看很简单的！我的解法过于丑陋，就不在这展示了"><a href="#其实BF也可以很好看很简单的！我的解法过于丑陋，就不在这展示了" class="headerlink" title="其实BF也可以很好看很简单的！我的解法过于丑陋，就不在这展示了"></a>其实BF也可以很好看很简单的！我的解法过于丑陋，就不在这展示了</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里想把vector遍历拓展一下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	一般我们遍历vector容器都会使用方括号或者迭代器，但是这里出现了一种新方法</span></span><br><span class="line"><span class="comment">	那就是for(int n : v ) 其中v是vector容器</span></span><br><span class="line"><span class="comment">	这句话等价于：for(int i=0;i&lt;v.size();i++)</span></span><br><span class="line"><span class="comment">				&#123;</span></span><br><span class="line"><span class="comment">					int i = v[n];</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">	所以说 n 就是等于把所有vector中的元素都遍历一遍 相当于for/of(js语法)</span></span><br><span class="line"><span class="comment">	后一种常用的则是把所有 vector中的索引都遍历一遍	相当于for/in(js语法)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: nums1)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums2[i] != n) i++;</span><br><span class="line">            <span class="comment">//每次都找到nums1中的元素在nums2中的索引</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//从这个索引开始向后遍历</span></span><br><span class="line">            <span class="keyword">for</span>(;i&lt;nums2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums2[i] &gt; n)&#123;</span><br><span class="line">                    <span class="comment">//每当找到比nums1种元素大的数边存储</span></span><br><span class="line">                    res.push_back(nums2[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//那么，如果全部遍历完成以后，还是没有，那么这个数后面没有更大的了</span></span><br><span class="line">            <span class="keyword">if</span>(i == nums2.<span class="built_in">size</span>()) res.push_back(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="当然，用栈和无序图来存储也是比较美观的"><a href="#当然，用栈和无序图来存储也是比较美观的" class="headerlink" title="当然，用栈和无序图来存储也是比较美观的"></a>当然，用栈和无序图来存储也是比较美观的</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sk;</span><br><span class="line"><span class="comment">//同样用到了for( : )语法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: nums2)&#123;</span><br><span class="line"><span class="comment">//这时候如果栈是非空的，并且栈顶元素是小于当前的n</span></span><br><span class="line"><span class="comment">//那么我们就在无序图中以key=栈顶，val= n 存储，这时候其实n就是栈顶所对应的更大的数</span></span><br><span class="line">            <span class="keyword">while</span>(!sk.empty() &amp;&amp; sk.top() &lt; n)&#123;</span><br><span class="line">                mp[sk.top()] = n;</span><br><span class="line">                sk.pop();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//否则，我们把n入栈 </span></span><br><span class="line">            sk.push(n);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//那么如果遍历结束以后，栈非空，那么说明说明栈里的元素没有匹配的n</span></span><br><span class="line">        <span class="keyword">while</span>(!sk.empty())&#123;</span><br><span class="line">            mp[sk.top()] = <span class="number">-1</span>;</span><br><span class="line">            sk.pop();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//最后，我们把无序map中所有的val值放入vector并返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: nums1)&#123;</span><br><span class="line">            res.push_back(mp[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>503下一个更大的数II</title>
    <url>/2020/04/26/503%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0II/</url>
    <content><![CDATA[<h1 id="503下一个更大的数II"><a href="#503下一个更大的数II" class="headerlink" title="503下一个更大的数II"></a>503下一个更大的数II</h1><p><img src="/2020/04/26/503%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0II/1.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="我给出-两种解法，栈及其优化，BF"><a href="#我给出-两种解法，栈及其优化，BF" class="headerlink" title="我给出 两种解法，栈及其优化，BF"></a>我给出 两种解法，栈及其优化，BF</h4><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>因为我在<a href="https://jasonxqh.github.io/2020/04/19/1019链表中的下一个更大元素/" target="_blank" rel="noopener">1019链表中下一个更大的数 </a>中介绍过了这种方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//因为这个数组是可循环的，我们不妨直接拉长一倍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="comment">//随后再每个遍历，很傻逼吧？确实！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = nums.at(i); <span class="comment">//先暂存当前元素</span></span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; cur &gt;= s.top())</span><br><span class="line">             <span class="comment">//注意: 等于号不能少 等于时也需要出栈 这里是找严格大于的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();  <span class="comment">//淘汰小的 留下更大的</span></span><br><span class="line">            &#125;</span><br><span class="line">            nums.at(i) = (s.empty() ? <span class="number">-1</span> : s.top()); <span class="comment">//栈空 右边没有更大的</span></span><br><span class="line">            s.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//随后resize一下</span></span><br><span class="line">         nums.resize(tot);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="栈优化"><a href="#栈优化" class="headerlink" title="栈优化"></a>栈优化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="comment">//不用扩充nums，而是把i双倍，并用nums[i%n]实现循环效果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i % n];</span><br><span class="line">            <span class="comment">//如果栈非空并且栈顶&lt;num,那么应该在res中修改</span></span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; nums[st.top()] &lt; num) &#123;</span><br><span class="line">                res[st.top()] = num; </span><br><span class="line">                <span class="comment">//一旦给栈顶所对应的元素，就让他出栈</span></span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把st作为标记栈</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; n) st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(nums[i]);</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=tot<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//每一次都遍历后面tot个数，一旦找到就break;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+tot;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">max</span>=nums[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i]=<span class="built_in">max</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>59-1滑动窗口的最大值</title>
    <url>/2020/04/22/59-1%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="59-1滑动窗口最大值"><a href="#59-1滑动窗口最大值" class="headerlink" title="59-1滑动窗口最大值"></a>59-1滑动窗口最大值</h1><p><img src="/2020/04/22/59-1%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/59-1.png" alt></p>
<h3 id="题目给出的代码"><a href="#题目给出的代码" class="headerlink" title="题目给出的代码"></a>题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="这里给出BF算法和利用deque维护的降序队列算法"><a href="#这里给出BF算法和利用deque维护的降序队列算法" class="headerlink" title="这里给出BF算法和利用deque维护的降序队列算法"></a>这里给出BF算法和利用deque维护的降序队列算法</h4><h4 id="BF是自己写的"><a href="#BF是自己写的" class="headerlink" title="BF是自己写的"></a>BF是自己写的</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()-k+<span class="number">1</span>;i++)<span class="comment">//一共输出n-k+1次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;<span class="comment">//每次都初始化s</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+k;j++)<span class="comment">//每次都从下标i开始</span></span><br><span class="line">            &#123;	</span><br><span class="line">                <span class="keyword">if</span>(s.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    s.push(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">//栈中一直维持着最大值，但这样栈的存在其实就没意思了，定一个max应该就可以</span></span><br><span class="line">                <span class="keyword">if</span>(!s.empty()&amp;&amp;nums[j]&gt;s.top())</span><br><span class="line">                &#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后每次把栈顶放入数组</span></span><br><span class="line">            ans.push_back(s.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="但是用deque维护一个递减栈更好"><a href="#但是用deque维护一个递减栈更好" class="headerlink" title="但是用deque维护一个递减栈更好"></a>但是用deque维护一个递减栈更好</h4><p><img src="/2020/04/22/59-1%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/%E9%A2%98%E8%A7%A3.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">       <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">       <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="comment">//我们要把数组的下标放到deque中去 </span></span><br><span class="line">        <span class="comment">//方便起见，我们把deque中的数代指vector中的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="comment">//每次进来的如果比deque中的所有数要大，尾部比它小的都要清空</span></span><br><span class="line">            <span class="keyword">while</span>(!deq.empty() &amp;&amp; nums[i] &gt; nums[deq.back()])&#123;</span><br><span class="line">                deq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一共要循环i-k+1次，所以当deq.front()到达i-k+1就不再进行循环了</span></span><br><span class="line">            <span class="keyword">if</span> (!deq.empty() &amp;&amp; deq.front() &lt; i - k + <span class="number">1</span>) deq.pop_front();</span><br><span class="line">            <span class="comment">//每次都需要把下标压入deque</span></span><br><span class="line">            deq.push_back(i);</span><br><span class="line">            <span class="comment">//因为前几次，deque.front()还没有移动到vector[0],所以不能算</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k <span class="number">-1</span>) ans.push_back(nums[deq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>59-2队列的最大值</title>
    <url>/2020/05/04/59-2%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="59-2队列的最大值"><a href="#59-2队列的最大值" class="headerlink" title="59-2队列的最大值"></a>59-2队列的最大值</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/05/04/59-2%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/1.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最简单的暴力搜索"><a href="#最简单的暴力搜索" class="headerlink" title="最简单的暴力搜索"></a>最简单的暴力搜索</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line">    <span class="comment">//用数组模拟队列</span></span><br><span class="line">    <span class="keyword">int</span> q[<span class="number">20000</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i != <span class="built_in">end</span>; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, q[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        q[<span class="built_in">end</span>++] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> q[<span class="built_in">begin</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="与155-最小栈不同，我们如果要维护一个最大队列，很难用pair实现"><a href="#与155-最小栈不同，我们如果要维护一个最大队列，很难用pair实现" class="headerlink" title="与155 最小栈不同，我们如果要维护一个最大队列，很难用pair实现"></a>与155 最小栈不同，我们如果要维护一个最大队列，很难用pair实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.empty()?<span class="number">-1</span>:dq.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        que.push(value);</span><br><span class="line"><span class="comment">//更新deque双端队列，把比value小的全部pop，就是在queue队列中的第一大，第二大。。。</span></span><br><span class="line">        <span class="keyword">while</span>(!dq.empty()&amp;&amp;dq.back()&lt;value)</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> t=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line"><span class="comment">//出队列的时候要判断一下是不是把当前的最大值给pop掉了，如果是，那么更新deque</span></span><br><span class="line">        <span class="keyword">if</span>(t==dq.front())</span><br><span class="line">            dq.pop_front();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>61旋转链表</title>
    <url>/2020/04/19/61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/19/61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/61.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="我的思路很简单，就是先计算出要移动几个位置，然后用一个迭代器移动到新的头结点的位置，断开，重连。"><a href="#我的思路很简单，就是先计算出要移动几个位置，然后用一个迭代器移动到新的头结点的位置，断开，重连。" class="headerlink" title="我的思路很简单，就是先计算出要移动几个位置，然后用一个迭代器移动到新的头结点的位置，断开，重连。"></a>我的思路很简单，就是先计算出要移动几个位置，然后用一个迭代器移动到新的头结点的位置，断开，重连。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先还是建立一个dummyNode，因为我不能保证头节点不发生变化</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy -&gt;next = head;</span><br><span class="line">        ListNode *cur = dummy,*cur2 =dummy;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历一边链表，计算出节点数</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            cur= cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//剔除几个特殊情况，当头节点为NULL，直接返回头节点</span></span><br><span class="line">        <span class="comment">//当只有一个节点，或者需要移动的数目是总结点数的倍数的时候,链表不需要发生任何变化</span></span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next||k%i==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//然后移动i-(k%i)格。注意，因为k可能是超过i的所以要用 k%i 而不是直接用k</span></span><br><span class="line">        <span class="keyword">while</span>( j++ &lt; i-(k%i) )</span><br><span class="line">        &#123;         </span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在，cur2移动到了新的尾节点。然后需要做的就是把尾节点cur2断开，并令一个新的头节点</span></span><br><span class="line">        ListNode *head2 = cur2-&gt;next;</span><br><span class="line">        cur2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//然后把原来的尾节点与原来的头节点相连接，并返回新的头节点</span></span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> head2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>621任务调度器</title>
    <url>/2020/04/20/621%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621 任务调度器"></a>621 任务调度器</h1><h3 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h3><p><img src="/2020/04/20/621%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/621.png" alt></p>
<h3 id="下面是题目给出的代码模板"><a href="#下面是题目给出的代码模板" class="headerlink" title="下面是题目给出的代码模板"></a>下面是题目给出的代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="很显然我们要把题目读透"><a href="#很显然我们要把题目读透" class="headerlink" title="很显然我们要把题目读透"></a>很显然我们要把题目读透</h4><ul>
<li>假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为count = 3，所以两个A之间必须间隔2个任务，才能满足题意并且是最短时间（两个A的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的X表示除了A以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个A的间隔的。上面执行顺序的规律是： 有count - 1个A，其中每个A需要搭配n个X，再加上最后一个A，所以总时间为 (count - 1) * (n + 1) + 1</li>
<li>要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个A和一个B，因此最后要加上频率最高的不同任务的个数 maxCount</li>
</ul>
<h3 id="借助桶的思维，我们可以更直观的了解这题目的思路-不是我的题解！"><a href="#借助桶的思维，我们可以更直观的了解这题目的思路-不是我的题解！" class="headerlink" title="借助桶的思维，我们可以更直观的了解这题目的思路(不是我的题解！)"></a>借助桶的思维，我们可以更直观的了解这题目的思路(不是我的题解！)</h3><p><a href="https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/</a>  作者：popopop</p>
<p>上面是原帖，我按照他的基础加上了自己的理解</p>
<ol>
<li>建立大小为n+1的桶子，个数为任务数量最多的那个任务，比如下图，等待时间n=2，A任务个数6个，我们建立6个桶子，每个容量为3：<br>我们可以把一个桶子看作一轮任务</li>
</ol>
<p><img src="/2020/04/20/621%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/621_1.png" alt></p>
<p><img src="/2020/04/20/621%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/621_2.png" alt></p>
<ol>
<li><p>第二列、第三列的空格就是用来填剩下的任务的，这样能保证每个任务之间都间隔n个长度</p>
</li>
<li><p>但是，最后一个任务A的时间后没有了其他任务，所以完成任务A所需的时间应该是（6-1）*3+1=16</p>
</li>
</ol>
<p><strong>如果添加了任务的话，会怎么样呢</strong></p>
<p><img src="/2020/04/20/621%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/621_4.png" alt></p>
<ol>
<li>可以看到C其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；<br>而B和A数量相同，这会导致最后一个桶子中，我们需要多执行一次B任务，现在我们需要的时间是（6-1）*3+2=17</li>
</ol>
<p><strong>前面两种情况，总结起来：总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数</strong></p>
<ol>
<li>当冷却时间不够任务的总数，那么怎么办呢？</li>
</ol>
<p><img src="/2020/04/20/621%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/621_5.png" alt></p>
<p>此时我们可以临时扩充某些桶子的大小，插进任务F，对比一下插入前后的任务执行情况：<br>插入前：ABC | ABC | ABD | ABD | ABD |AB<br>插入后：ABCF | ABCF | ABD | ABD | ABD |AB<br>我们在第一个、第二个桶子里插入了任务F，不难发现无论再继续插入多少任务，我们都可以类似处理，而且新插入元素肯定满足冷却要求<br>继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。<br>也就是说，我们执行任务所需的时间，就是任务的数量</p>
<p><strong>这样按公式算出来，那么所花费的时间是17，但是因为每个任务之间已经不存在空余时间，所以这时候任务所需的时间是19，所以要返回多的</strong></p>
<p><strong>所以，当任务之间存在空闲时间的时候，肯定是公式算出来的时间多，但是当任务之间没有空暇时间，那么任务的数量&gt;=公式的结果</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p[<span class="number">26</span>] ;</span><br><span class="line">        <span class="built_in">memset</span>(p,<span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">		<span class="comment">//第一步，统计各个任务种类的频率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;tasks.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[tasks[i]-<span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二部，将这个数组进行排序</span></span><br><span class="line">        sort(p,p+<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">int</span> maxCount= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为sort函数默认从小到大，所以我们反向遍历，看看有多少任务种类的频率和最大频率相等，需要在最后加上maxCount</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">25</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]!=p[<span class="number">25</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            maxCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后比较大小后返回</span></span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">25</span>]<span class="number">-1</span>)*(n+<span class="number">1</span>)+maxCount&gt;tasks.<span class="built_in">size</span>()?(p[<span class="number">25</span>]<span class="number">-1</span>)*(n+<span class="number">1</span>)+maxCount:tasks.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>medium</tag>
        <tag>leetcode_Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>622设计循环队列</title>
    <url>/2020/04/20/622%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>leetcode_Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>641设计循环双端队列</title>
    <url>/2020/04/20/641%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>leetcode_Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>682棒球比赛</title>
    <url>/2020/04/22/682%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h1><p><img src="/2020/04/22/682%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/.%5C682%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B%5C682.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ops)</span> </span>&#123;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="因为是简单题，而且我思考的时候并没有发生很严重的卡壳，所以我只说几个要注意的细节"><a href="#因为是简单题，而且我思考的时候并没有发生很严重的卡壳，所以我只说几个要注意的细节" class="headerlink" title="因为是简单题，而且我思考的时候并没有发生很严重的卡壳，所以我只说几个要注意的细节"></a>因为是简单题，而且我思考的时候并没有发生很严重的卡壳，所以我只说几个要注意的细节</h4><ul>
<li>是字符串数组！是字符串数组！是字符串数组！ 所以在判断数字的时候还需要用一个字符串转化为数字的方法，我这里用了把数字判断放在最后，然后用stoi函数来解决这个问题</li>
<li>“+” 说的是前两项的和是当前项的值，那么如何才能取得前两项的和呢？我用很蠢的方法，就是先把栈顶的两个数取出来，求和，然后再把它们压栈，最后把他们的和压栈。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ops)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> n : ops)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">           <span class="keyword">if</span>(!s.empty()&amp;&amp;n==<span class="string">"C"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t1=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                sum=sum-t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!s.empty()&amp;&amp;n==<span class="string">"D"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t2 = s.top();</span><br><span class="line">                s.push(t2*<span class="number">2</span>);</span><br><span class="line">                sum=sum+t2*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">"+"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> f1= s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> f2= s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> temp = f1+f2;</span><br><span class="line">                sum+=temp;</span><br><span class="line">                s.push(f2);</span><br><span class="line">                s.push(f1);</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//我最后才判断是否为数字，因为stoi("A")是不成立的！</span></span><br><span class="line">            <span class="keyword">int</span> k = stoi(n);</span><br><span class="line">            <span class="keyword">if</span>(k&gt;= <span class="number">-30000</span>&amp;&amp;k&lt;= <span class="number">30000</span> )</span><br><span class="line">            &#123;            </span><br><span class="line">                s.push(k);</span><br><span class="line">                sum=sum+k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>725分隔链表成几个部分</title>
    <url>/2020/04/19/725%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%E6%88%90%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="725-分割链表"><a href="#725-分割链表" class="headerlink" title="725.分割链表"></a>725.分割链表</h1><h4 id="注：现在开始尽量减少以图片的方式呈现题目了"><a href="#注：现在开始尽量减少以图片的方式呈现题目了" class="headerlink" title="注：现在开始尽量减少以图片的方式呈现题目了"></a>注：现在开始尽量减少以图片的方式呈现题目了</h4><h2 id="以下是题目"><a href="#以下是题目" class="headerlink" title="以下是题目"></a>以下是题目</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回一个符合上述规则的链表的列表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: </span></span><br><span class="line"><span class="comment">root = [1, 2, 3], k = 5</span></span><br><span class="line"><span class="comment">输出: [[1],[2],[3],[],[]]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">输入输出各部分都应该是链表，而不是数组。</span></span><br><span class="line"><span class="comment">例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。</span></span><br><span class="line"><span class="comment">第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。</span></span><br><span class="line"><span class="comment">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入: </span></span><br><span class="line"><span class="comment">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span></span><br><span class="line"><span class="comment">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">root 的长度范围： [0, 1000].</span></span><br><span class="line"><span class="comment">输入的每个节点的大小范围：[0, 999].</span></span><br><span class="line"><span class="comment">k 的取值范围： [1, 50].</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="以下是题目给出的代码"><a href="#以下是题目给出的代码" class="headerlink" title="以下是题目给出的代码"></a>以下是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>很显然，题目的难点就是怎么设置每个存储链表单位的长短，因为他说每部分的长度相差不超过1，每部分的长度大于等于后面部分的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	长度为10，分组为2，那么每个单位存储两个节点，共5个单位</span></span><br><span class="line"><span class="comment">	长度为10，分组为3，那么 4 3 3</span></span><br><span class="line"><span class="comment">	长度为10，分组为4，那么3 3 3 2</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	于是我想用数组来存储，首先均分，然后再把余数均匀分摊到前几项</span></span><br><span class="line"><span class="comment">	我的思考，就是</span></span><br><span class="line"><span class="comment">	1.先用所有数/组 得到 基</span></span><br><span class="line"><span class="comment">	2.再用数%组 得到余数</span></span><br><span class="line"><span class="comment">	3.在前几项的基上+1，一直到余数被分光</span></span><br><span class="line"><span class="comment">	4.把这些项存到一个数组中</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	然后就是断开链表，把头节点放入链表数组中去</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	注意，这里有有几个细节</span></span><br><span class="line"><span class="comment">	1.如果这个组为1长度，直接插入头节点</span></span><br><span class="line"><span class="comment">	2.如果这个组为0长度，插入NULL</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	代码量会长一点，因为能让自己看懂</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode *&gt; parts;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; install;</span><br><span class="line">        ListNode *cur = root,*temphead = root;</span><br><span class="line">      <span class="comment">//这一部分，就是计算链表中节点的个数</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="comment">//这里分两类，当组数大于长度，那么前面几组为1长度，后面为0长度</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;number)</span><br><span class="line">            &#123;</span><br><span class="line">                install.push_back(<span class="number">1</span>);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                install.push_back(<span class="number">0</span>);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> integer = number / k;</span><br><span class="line">            <span class="keyword">int</span> remainder = number % k;</span><br><span class="line">            <span class="keyword">while</span> (remainder) &#123;</span><br><span class="line">                install.push_back(integer + <span class="number">1</span>);</span><br><span class="line">                remainder--;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                install.push_back(integer);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//下面是切割操作，如果组数大于长度，那么如果单位长度为1.返回头节点，同时做头结点的更新，否则在数组中插入NULL节点</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;install.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tempCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(install[i]==<span class="number">0</span>)</span><br><span class="line">                    parts.push_back(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temphead = cur-&gt;next;</span><br><span class="line">                    cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                    parts.push_back(cur);</span><br><span class="line">                    cur = temphead;  </span><br><span class="line">                &#125;</span><br><span class="line">                     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line"><span class="comment">//	   否则，按照每个单位长度来切割链表，我这里用了三个节点，一个节点用来记录头节点，一个用来记录尾节点，还有一个临时节点用来帮助头节点和尾节点完成更新</span></span><br><span class="line">           </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;install.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tempCnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(tempCnt&lt;install[i]<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tempCnt++;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode *next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                parts.push_back(temphead);</span><br><span class="line">                cur = next;</span><br><span class="line">                temphead=next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> parts;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>72Edit_Problem</title>
    <url>/2020/04/27/72Edit-Problem/</url>
    <content><![CDATA[<h1 id="下面是作业题目和力扣上的问题"><a href="#下面是作业题目和力扣上的问题" class="headerlink" title="下面是作业题目和力扣上的问题"></a>下面是作业题目和力扣上的问题</h1><p><img src="/2020/04/27/72Edit-Problem/1.png" alt></p>
<p><img src="/2020/04/27/72Edit-Problem/2.png" alt></p>
<p>动态规划算法，比较困难，这里附上一个比较容易懂的视频链接</p>
<p><a href="https://www.youtube.com/watch?v=MiqoA-yF-0M" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MiqoA-yF-0M</a></p>
<p>这是算法的伪代码</p>
<p><img src="/2020/04/27/72Edit-Problem/3.png" alt></p>
<p>下面我们拿Sundays和Saturday为例，做一个动态规划表</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">“”</th>
<th align="center">s</th>
<th align="center">u</th>
<th align="center">n</th>
<th align="center">d</th>
<th align="center">a</th>
<th align="center">y</th>
<th align="center">s</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“”</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">t</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">6</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">8</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">6</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>我们看到了最后 的交点就是4</p>
<p>这里我贴上花花酱的链接和他的答案</p>
<p><a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/" target="_blank" rel="noopener">https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> l2 = word2.length();</span><br><span class="line">    <span class="comment">// d[i][j] := minDistance(word1[0:i - 1], word2[0:j - 1]);</span></span><br><span class="line">    <span class="comment">//这是个建表操作建立l1+1列，每一列填充vector&lt;int&gt;(l2+1,0)这个数组</span></span><br><span class="line">    <span class="comment">//也就是（l2+1）个0，也就是l2+1行</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">d</span><span class="params">(l1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(l2 + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后给第一行第一列都标上行数列数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l1; ++i)</span><br><span class="line">        d[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= l2; ++j)</span><br><span class="line">        d[<span class="number">0</span>][j] = j;</span><br><span class="line">	<span class="comment">//开始动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l2; ++j) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//这个就是delta如果这两个字符串最后一个数字相等，那么delta=0，否则delta=1</span></span><br><span class="line">            <span class="keyword">int</span> delta = (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这就是最核心的算法           </span></span><br><span class="line"> d[i][j] = <span class="built_in">min</span>(d[i - <span class="number">1</span>][j - <span class="number">1</span>] + delta,<span class="built_in">min</span>(d[i][j - <span class="number">1</span>], d[i - <span class="number">1</span>][j]) + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;=l1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;=l2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>,d[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[l1][l2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> word1,word2;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;word1&gt;&gt;word2;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;minDistance(word1,word2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h3><p><img src="/2020/04/27/72Edit-Problem/4.png" alt></p>
]]></content>
      <tags>
        <tag>discrete mathematics</tag>
        <tag>hard</tag>
        <tag>DP</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>739每日温度</title>
    <url>/2020/05/04/739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="739每日温度"><a href="#739每日温度" class="headerlink" title="739每日温度"></a>739每日温度</h1><p><img src="/2020/05/04/739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/1.png" alt></p>
<h2 id="下面是给出的代码"><a href="#下面是给出的代码" class="headerlink" title="下面是给出的代码"></a>下面是给出的代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="我拿到必用BF"><a href="#我拿到必用BF" class="headerlink" title="我拿到必用BF"></a>我拿到必用BF</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//每次拿到一个i，往后遍历找到比它大的值，然后记录</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(T[j]&gt;T[i])</span><br><span class="line">                &#123;</span><br><span class="line">           		     v[i] = j-i;</span><br><span class="line">              		 <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是很可惜，超出了时间限制</li>
</ul>
<h4 id="所以用递减栈来试试"><a href="#所以用递减栈来试试" class="headerlink" title="所以用递减栈来试试"></a>所以用递减栈来试试</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//栈内存储的是序号，做差获得答案</span></span><br><span class="line">            <span class="keyword">while</span>(!s.empty()&amp;&amp;T[i]&gt;T[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                v[temp] = i-temp;</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>817链表组件</title>
    <url>/2020/04/19/817%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="817链表组件"><a href="#817链表组件" class="headerlink" title="817链表组件"></a>817链表组件</h3><h3 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> a linked list containing unique integer values</span></span><br><span class="line"><span class="comment">给定一个链表（链表结点包含一个整型值）的头结点 head。</span></span><br><span class="line"><span class="comment">同时给定列表 G，该列表是上述链表中整型值的一个子集。</span></span><br><span class="line"><span class="comment">返回列表 G 中组件的个数，这里对组件的定义为：</span></span><br><span class="line"><span class="comment">链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 1：</span></span><br><span class="line"><span class="comment">输入: </span></span><br><span class="line"><span class="comment">head: 0-&gt;1-&gt;2-&gt;3</span></span><br><span class="line"><span class="comment">G = [0, 1, 3]</span></span><br><span class="line"><span class="comment">输出: 2</span></span><br><span class="line"><span class="comment">解释: </span></span><br><span class="line"><span class="comment">链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件</span></span><br><span class="line"><span class="comment">同理 [3] 也是一个组件，故返回 2。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">示例 2：</span></span><br><span class="line"><span class="comment">输入: </span></span><br><span class="line"><span class="comment">head: 0-&gt;1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">G = [0, 3, 1, 4]</span></span><br><span class="line"><span class="comment">输出: 2</span></span><br><span class="line"><span class="comment">解释: </span></span><br><span class="line"><span class="comment">链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意:</span></span><br><span class="line"><span class="comment">	如果 N 是给定链表 head 的长度，1 &lt;= N &lt;= 10000。</span></span><br><span class="line"><span class="comment">	链表中每个结点的值所在范围为 [0, N - 1]。</span></span><br><span class="line"><span class="comment">	1 &lt;= G.length &lt;= 10000</span></span><br><span class="line"><span class="comment">	G 是链表中所有结点的值的一个子集.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="下面是题目给我们的代码模板"><a href="#下面是题目给我们的代码模板" class="headerlink" title="下面是题目给我们的代码模板"></a>下面是题目给我们的代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="思路很简单很简单，就是看看链表中的val在不在vector内，在的话，一直找的不是为止，然后更新组件个数，不在的话节点后移，完成迭代"><a href="#思路很简单很简单，就是看看链表中的val在不在vector内，在的话，一直找的不是为止，然后更新组件个数，不在的话节点后移，完成迭代" class="headerlink" title="思路很简单很简单，就是看看链表中的val在不在vector内，在的话，一直找的不是为止，然后更新组件个数，不在的话节点后移，完成迭代"></a>思路很简单很简单，就是看看链表中的val在不在vector内，在的话，一直找的不是为止，然后更新组件个数，不在的话节点后移，完成迭代</h4><p><strong>但是我自己死活搞不出来！！！！！！！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是我用find函数直接在vector数组中找啊找的代码，基本思路和用set一样，测试点也都过了，但是很可惜超出了时间限制~~~</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        ListNode*cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(G.<span class="built_in">begin</span>(),G.<span class="built_in">end</span>(),cur-&gt;val)!=G.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">find</span>(G.<span class="built_in">begin</span>(),G.<span class="built_in">end</span>(),cur-&gt;val)!=G.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span>(!cur)<span class="keyword">break</span>;</span><br><span class="line">                &#125;             </span><br><span class="line">            &#125; <span class="keyword">else</span>  cur  = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//看了别人的思路后，发现还是要用set或者bool数组才能解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先把数组全部存入---等于去重+排列</span></span><br><span class="line">    	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; m_set;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">size</span>(); ++i )&#123;</span><br><span class="line">        	m_set.insert(G[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Comnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="comment">//一旦找到了，要把左右连续的都遍历光，val不出现在set</span></span><br><span class="line">        	<span class="keyword">if</span>( m_set.<span class="built_in">find</span>(head-&gt;val) != m_set.<span class="built_in">end</span>() )&#123;</span><br><span class="line">        		Comnum++;</span><br><span class="line">        		<span class="keyword">while</span>( m_set.<span class="built_in">find</span>(head-&gt;val) != m_set.<span class="built_in">end</span>() )&#123;</span><br><span class="line">        			head = head-&gt;next;</span><br><span class="line">        			<span class="keyword">if</span>(!head) <span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="keyword">else</span> head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Comnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="还有一种方法，我认为更加巧妙，就是利用bool数组来判断是否存储，空间上应该占用的内存更小"><a href="#还有一种方法，我认为更加巧妙，就是利用bool数组来判断是否存储，空间上应该占用的内存更小" class="headerlink" title="还有一种方法，我认为更加巧妙，就是利用bool数组来判断是否存储，空间上应该占用的内存更小"></a>还有一种方法，我认为更加巧妙，就是利用bool数组来判断是否存储，空间上应该占用的内存更小</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!head)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//首先按照最大的数据建立一个bool数组</span></span><br><span class="line">        <span class="comment">//然后把所有在vector中出现的值全部标成1来达到set的作用</span></span><br><span class="line">         <span class="keyword">bool</span> m[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">             m[G[i]] = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ListNode* p = head;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">bool</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始遍历，当b=0且val值在数组中的映射为1的时候，count++。</span></span><br><span class="line">        <span class="comment">//然后将b设置成m[p-&gt;val]，p = p-&gt;next</span></span><br><span class="line">        <span class="comment">//这样，如果链表中连续的数字出现，那么b=1，就不会进入到判断当中去</span></span><br><span class="line">        <span class="comment">//一直到下一个组件开始的时候 b=0，才会开始下一次判断</span></span><br><span class="line">        <span class="comment">//我认为原理还是一样的，但是这种设置就非常的妙。达到了四两拨千斤的效果</span></span><br><span class="line">         <span class="keyword">while</span> (p) &#123;</span><br><span class="line">             <span class="keyword">if</span> (!b &amp;&amp; m[p-&gt;val]) &#123;</span><br><span class="line">                 count++;</span><br><span class="line">             &#125;</span><br><span class="line">             b = m[p-&gt;val];</span><br><span class="line">             p = p-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>82删除排序链表中的重复元素2</title>
    <url>/2020/04/19/82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p>![](./2两数相加/82. 删除排序链表中的重复元素 II.png)</p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="这里给出两种放法，第一种是我通过模仿1171的思路通过unordered-map存储来实现的，第二种是更快的解题方法"><a href="#这里给出两种放法，第一种是我通过模仿1171的思路通过unordered-map存储来实现的，第二种是更快的解题方法" class="headerlink" title="这里给出两种放法，第一种是我通过模仿1171的思路通过unordered_map存储来实现的，第二种是更快的解题方法"></a>这里给出两种放法，第一种是我通过模仿1171的思路通过unordered_map存储来实现的，第二种是更快的解题方法</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	这道题，我才用遍历两边的思路完成所有重复节点的删除</span></span><br><span class="line"><span class="comment"> 	拿123344556来做实验</span></span><br><span class="line"><span class="comment"> 	第一道遍历，将重复的节点删除，但保留重复的第一个节点，同时把3，4，5存储到set中</span></span><br><span class="line"><span class="comment">比如现在，链表已经变成123456了</span></span><br><span class="line"><span class="comment">	第二道遍历，判断节点值是否在set中出现过，如果出现，则删除，比如3，4，5已经在表中了。现在删除他们 最后的得到126</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode*dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        <span class="comment">//思路差不多，我也是利用unordered_map 来记录一个是否重复的元素</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;judge;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>( p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val==p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                judge.insert(p-&gt;val);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy;</span><br><span class="line">        <span class="comment">//第二段遍历，删除存储在set中的节点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(judge.<span class="built_in">find</span>(p-&gt;next-&gt;val)!=judge.<span class="built_in">end</span>())</span><br><span class="line">              p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个方法也是遍历，但是没有依赖其他容器，而且只遍历了一遍</span></span><br><span class="line"><span class="comment">	思路：</span></span><br><span class="line"><span class="comment">		通过两个指针来实现遍历操作</span></span><br><span class="line"><span class="comment">		下面的题解以12333445为例</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;next-&gt;next) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//这里把p当作第一个重复节点的前一个结点进行运算，现在p为2，但是接下来是三个相同节点345</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//进入if语句后，把i指向第5个节点。如果第五个节点或者后面的节点还是和第3个节点的值一样，那就移动i，直到不一样位置，再把当前的p节点指向i，完成中间所有重复节点的删除</span></span><br><span class="line">                ListNode* i = p-&gt;next-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">                        i = i-&gt;next;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新p后面节点的值，也就是现在p-&gt;next =  4,开始下一轮遍历！</span></span><br><span class="line">                p-&gt;next = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//更新p的值，寻找下个重复的节点</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>83删除排序链表中的重复元素</title>
    <url>/2020/04/19/83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>844比较含退格的字符串</title>
    <url>/2020/04/22/844%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="844比较含退格的字符串"><a href="#844比较含退格的字符串" class="headerlink" title="844比较含退格的字符串"></a>844比较含退格的字符串</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/22/844%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/.%5C844%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%5C844.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><ul>
<li>还是要先判断特殊字符，在判断特殊字符的时候同时要判断栈是不是空的，因为如果是#且栈是空的，那也没有意义了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addchar</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;&amp;s,<span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//因为string也是容器，我们也可以用for( : )来把s中每个元素赋值出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="string">'#'</span>&amp;&amp;!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;=<span class="string">'z'</span>&amp;&amp;i&gt;=<span class="string">'a'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;s;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;t;</span><br><span class="line">        addchar(s,S);</span><br><span class="line">        addchar(t,T);</span><br><span class="line">        <span class="keyword">return</span> s==t? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>86分割链表表_大小分隔</title>
    <url>/2020/04/19/86%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%E8%A1%A8-%E5%A4%A7%E5%B0%8F%E5%88%86%E9%9A%94/</url>
    <content><![CDATA[<h1 id="86-大小分隔"><a href="#86-大小分隔" class="headerlink" title="86.大小分隔"></a>86.大小分隔</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/19/86%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%E8%A1%A8-%E5%A4%A7%E5%B0%8F%E5%88%86%E9%9A%94/D:%5Cprojects%5CJasonXQH.github.io%5Csource%5Cimages%5C86.png" alt="86"></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="我利用了两个队列，实现了这个操作"><a href="#我利用了两个队列，实现了这个操作" class="headerlink" title="我利用了两个队列，实现了这个操作"></a>我利用了两个队列，实现了这个操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	因为这个题目再去想怎么直接在链表上断一断，拼一拼已经是非常困难的了，所以我考虑新建队列</span></span><br><span class="line"><span class="comment">	而且我们又要保持原来的节点的相对位置相同，所以我们要保证一个先进先出的数据结构--队列</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;smaller;<span class="comment">//用来记录小于x的数值</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;larger;<span class="comment">//用来记录大于等于x的数值</span></span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="comment">//首先让链表中的值全部入列</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;val&gt;=x? larger.push(cur-&gt;val):smaller.push(cur-&gt;val);</span><br><span class="line">            cur = cur -&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//然后新建一个dummyNode</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       	head = dummy;<span class="comment">//这里其实就是另起炉灶,让head不再指向原来的链表了</span></span><br><span class="line">        <span class="keyword">while</span>(!smaller.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//首先，把所有smaller中的元素依次建立新结点，然后更新dummyNode，然后出列</span></span><br><span class="line">            ListNode *newNode = <span class="keyword">new</span> ListNode(smaller.front());</span><br><span class="line">            dummy-&gt;next = newNode;</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">            smaller.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!larger.empty())</span><br><span class="line">        &#123;	</span><br><span class="line">            <span class="comment">//对于larger队列，在smaller队列完成操作之后再继续，操作顺序和smaller队列相同</span></span><br><span class="line">            ListNode *newNodela = <span class="keyword">new</span> ListNode(larger.front());</span><br><span class="line">            dummy-&gt;next = newNodela;</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">            larger.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后返回head-&gt;next,因为head = dummy</span></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="还有一个解法我认为更加美观"><a href="#还有一个解法我认为更加美观" class="headerlink" title="还有一个解法我认为更加美观"></a>还有一个解法我认为更加美观</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接新建两个链表，一个存储小于x的，一个存储大于等于x的，然后让他们两个相连！</span></span><br><span class="line">        ListNode na(0),nb(0);</span><br><span class="line">        ListNode *a=&amp;na,*b=&amp;nb;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=head-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(v&lt;x) a-&gt;next=head,a=head;</span><br><span class="line">            <span class="keyword">else</span> b-&gt;next=head,b=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        a-&gt;next=nb.next;</span><br><span class="line">        b-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> na.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>901股票价格跨度</title>
    <url>/2020/04/28/901%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="901股票价格跨度"><a href="#901股票价格跨度" class="headerlink" title="901股票价格跨度"></a>901股票价格跨度</h1><p><img src="/2020/04/28/901%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/1.png" alt></p>
<h2 id="下面是代码"><a href="#下面是代码" class="headerlink" title="下面是代码"></a>下面是代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockSpanner() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner* obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="这题思路很简单啊，凭什么老是超时"><a href="#这题思路很简单啊，凭什么老是超时" class="headerlink" title="这题思路很简单啊，凭什么老是超时!?????"></a>这题思路很简单啊，凭什么老是超时!?????</h3><p>用pair存储，我一下子就想到了，但是老是超时，有时候AC了，有时候WA了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockSpanner() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化1</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果栈非空，那么和栈顶比，比栈顶的price大，那么就把他吸收进来，再pop掉</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; price &gt;= s.top().second) &#123;</span><br><span class="line">            temp += s.top().first;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后入栈</span></span><br><span class="line">        s.push(make_pair(temp, price));</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//真不知道为啥！！！！</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>921使括号有效的最小添加</title>
    <url>/2020/04/30/921%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%BB%E5%8A%A0/</url>
    <content><![CDATA[<h1 id="921使括号有效的最小添加"><a href="#921使括号有效的最小添加" class="headerlink" title="921使括号有效的最小添加"></a>921使括号有效的最小添加</h1><ul>
<li>这题应该放到简单题中</li>
</ul>
<p><img src="/2020/04/30/921%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%BB%E5%8A%A0/1.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="下面是我给出的代码"><a href="#下面是我给出的代码" class="headerlink" title="下面是我给出的代码"></a>下面是我给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()&amp;&amp;stk.top()==<span class="string">'('</span>&amp;&amp;c==<span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>92反转链表</title>
    <url>/2020/04/19/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/19/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/1.png" alt></p>
<h3 id="下面是题目给出的代码模板"><a href="#下面是题目给出的代码模板" class="headerlink" title="下面是题目给出的代码模板"></a>下面是题目给出的代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="我的解法，和重排列表有相似之处，-1切断，2反转，3合并"><a href="#我的解法，和重排列表有相似之处，-1切断，2反转，3合并" class="headerlink" title="我的解法，和重排列表有相似之处， 1切断，2反转，3合并"></a>我的解法，和重排列表有相似之处， 1切断，2反转，3合并</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//拿 1 2 3 4 5 6 ； m = 2 ，n = 5来讲解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归，首先要给出返回条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先建立ret节点 ，实现从第二个结点开始的 递归操作</span></span><br><span class="line">        ListNode* ret = reverseList(head-&gt;next);</span><br><span class="line">        <span class="comment">//进行反转操作，用head的next指向head本身，实现闭环</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        <span class="comment">// 最后</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">   	</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先，把干扰全部去除，特殊条件有不少，当m==n说明不用反转</span></span><br><span class="line">        <span class="comment">//当只有一个节点，说明不用反转</span></span><br><span class="line">        <span class="comment">//当head为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span>(m==n||!head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(!head ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//然后利用双指针，精确的截取需要反转的链表，然后实现主、子脱钩</span></span><br><span class="line">        <span class="comment">//在脱钩之前，再用两个temp指针，分别指向快慢指针的下一个指针，这样让后续的再合并提供方便！</span></span><br><span class="line">        <span class="comment">//这里有个小细节，我先让快指针走，走n格，然后fast-&gt;next = NULL</span></span><br><span class="line">        <span class="comment">//然后让慢指针走，否则，一旦slow-&gt;next = NULL,快指针就不知道跑到那里去了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next =head;</span><br><span class="line">        ListNode *slow = dummy,*fast = dummy;</span><br><span class="line">        <span class="keyword">while</span>( j&lt;n )</span><br><span class="line">        &#123;</span><br><span class="line">            fast= fast-&gt;next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在fast移动到了5处</span></span><br><span class="line">        ListNode *temp2= fast-&gt;next;<span class="comment">//temp2 为6节点</span></span><br><span class="line">        <span class="comment">//实现快节点脱钩，现在，temp2和它之后的链表成为了一个新链表</span></span><br><span class="line">        fast-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        /------------------------------------------------/</span><br><span class="line">        <span class="keyword">while</span>(i &lt;m<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在slow指向2的前面一个节点，也就是1节点</span></span><br><span class="line">        ListNode *temp1 = slow-&gt;next;<span class="comment">//temp1 为2</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//实现慢节点脱钩，现在，2-3-4-5 是一个新的链表了，我们现在就是要把三个再组合</span></span><br><span class="line">        <span class="comment">//先让fast == temp1 也是为了方便，因为反转链表之后，temp1的位置就是原来fast的位置，也就是5，所以等于是交换fast和temp1的值</span></span><br><span class="line">        fast = temp1;<span class="comment">//现在fast 和 temp 都为2</span></span><br><span class="line">        temp1 = reverseList(temp1);<span class="comment">//反转链表之后，temp1 变成了5</span></span><br><span class="line">        <span class="comment">//现在只要做简单的拼接就可以了</span></span><br><span class="line">		<span class="comment">//slow(1)指向temp1（5）</span></span><br><span class="line">        slow-&gt;next = temp1;</span><br><span class="line">        <span class="comment">//fast(2)指向temp（2）</span></span><br><span class="line">        fast-&gt;next =temp2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode_Link</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>933最近的请求次数</title>
    <url>/2020/04/20/933%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="933最近请求次数"><a href="#933最近请求次数" class="headerlink" title="933最近请求次数"></a>933最近请求次数</h1><h1 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h1><p><img src="/2020/04/20/933%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/933.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RecentCounter() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="这个题目我一开始没看懂，但是说人话，就是"><a href="#这个题目我一开始没看懂，但是说人话，就是" class="headerlink" title="这个题目我一开始没看懂，但是说人话，就是"></a>这个题目我一开始没看懂，但是说人话，就是</h4><p><strong>这道题说人话就是：t代表这个员工的工号，每次新员工t加入q公司前先把工号小于t -3000的老家伙都辞退，然后再让t入职，统计q公司现有几个员工</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	RecentCounter() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		q.push(t);</span><br><span class="line">		<span class="keyword">while</span> (q.front() &lt; t - <span class="number">3000</span>) q.pop();</span><br><span class="line">		<span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>easy</tag>
        <tag>leetcode_Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>946验证栈序列</title>
    <url>/2020/04/30/946%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="946验证栈序列"><a href="#946验证栈序列" class="headerlink" title="946验证栈序列"></a>946验证栈序列</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/04/30/946%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/2.png" alt></p>
<h3 id="下面是题目给出的代码"><a href="#下面是题目给出的代码" class="headerlink" title="下面是题目给出的代码"></a>下面是题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一开始我没有考虑到出栈顺序，所以给出了这个"><a href="#一开始我没有考虑到出栈顺序，所以给出了这个" class="headerlink" title="一开始我没有考虑到出栈顺序，所以给出了这个"></a>一开始我没有考虑到出栈顺序，所以给出了这个</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//也就是说先遍历pushed栈，匹配上了直接出栈，匹配不上再一一入栈</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushed.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(pushed[i]==popped[j])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stk.push(pushed[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后再和pop一一匹配</span></span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.top()==popped[j])</span><br><span class="line">            &#123;</span><br><span class="line">                 stk.pop();</span><br><span class="line">                 j++;</span><br><span class="line">            &#125;     </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//但是这样是不科学的，push[1,2,0],pop[2,1,0]</span></span><br></pre></td></tr></table></figure>
<h3 id="但是存在-1-2-0-2-1-0-这样的数据。也就是说可能进栈又马上出栈，所以还要再判断"><a href="#但是存在-1-2-0-2-1-0-这样的数据。也就是说可能进栈又马上出栈，所以还要再判断" class="headerlink" title="但是存在[1,2,0],[2,1,0]这样的数据。也就是说可能进栈又马上出栈，所以还要再判断"></a>但是存在[1,2,0],[2,1,0]这样的数据。也就是说可能进栈又马上出栈，所以还要再判断</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;popped.<span class="built_in">size</span>();i++)</span><br><span class="line">         &#123;</span><br><span class="line">             stk.push(pushed[i]);</span><br><span class="line">    <span class="comment">//每次入栈以后再判断，栈非空，pop栈为遍历完且栈顶==popped[k],而且还要循环！</span></span><br><span class="line">    <span class="keyword">while</span>((!stk.empty())&amp;&amp;k&lt;popped.<span class="built_in">size</span>()&amp;&amp;(stk.top()==popped[k]))&#123;</span><br><span class="line">                 stk.pop();</span><br><span class="line">                 k++;<span class="comment">//如果匹配成功，k移位</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="当然，还有一种做法有-l’etat-c’est-moi的感觉"><a href="#当然，还有一种做法有-l’etat-c’est-moi的感觉" class="headerlink" title="当然，还有一种做法有 l’etat, c’est moi的感觉"></a>当然，还有一种做法有 l’etat, c’est moi的感觉</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//直接把vector看作是一个栈，直接白嫖，降低空间复杂度</span></span><br><span class="line">		 <span class="comment">// pushed[size++] = pushed[i] ，我直呼内行</span></span><br><span class="line">		<span class="comment">// pushed[i-1]现在是栈顶，size就是栈的元素，如果这个push[i]是要出栈的</span></span><br><span class="line">     	<span class="comment">// 在下一次迭代中就会被push[i+1]替代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushed.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            pushed[<span class="built_in">size</span>++] = pushed[i];</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">size</span> != <span class="number">0</span> &amp;&amp; pushed[<span class="built_in">size</span> - <span class="number">1</span>] == popped[j]) &#123;</span><br><span class="line">                <span class="built_in">size</span>--; j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode_Stack</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>C++03</title>
    <url>/2020/04/20/C-03/</url>
    <content><![CDATA[<h1 id="Day03-总结"><a href="#Day03-总结" class="headerlink" title="Day03 总结"></a>Day03 总结</h1><h3 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造函数的写法</span></span><br><span class="line">    <span class="comment">//没有返回值 函数名与类名相同</span></span><br><span class="line">    <span class="comment">//可以有参数，可以重载</span></span><br><span class="line">    <span class="comment">//由编译器自动调用，不需要手动调用</span></span><br><span class="line">    <span class="comment">//而且编译器只会调用一次</span></span><br><span class="line">    MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MYClASS的构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.析构函数的写法</span></span><br><span class="line">    <span class="comment">//没有返回值，不写void 函数名与类名相同 在函数名前加~</span></span><br><span class="line">    <span class="comment">//且编译器只会调用一次</span></span><br><span class="line">    ~MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MYCLASS的析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass myClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">    MyClass myClass;<span class="comment">//在main函数结束后析构</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.分类</span></span><br><span class="line"><span class="comment">//按照参数进行分类 有参构造函数 无参构造函数（默认）</span></span><br><span class="line"><span class="comment">//按照类型进行分类 普通构造函数 拷贝构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的默认构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    Person(<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的有参构造函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    Person (<span class="keyword">const</span> Person &amp;p)<span class="comment">// 类名（const 类名 &amp;aa）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"拷贝构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" 析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//无参的构造函数</span></span><br><span class="line">     Person p;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//有参的构造函数,用括号</span></span><br><span class="line">     <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">     <span class="comment">//显示法</span></span><br><span class="line">    Person p4 = Person(<span class="number">10</span>);<span class="comment">//有参</span></span><br><span class="line">    Person p5 = Person(p4);<span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意</span></span><br><span class="line"><span class="comment">//    Person p();//不可以用括号发，调用无参构造函数 原因Person p() 编译器认为是函数的声明</span></span><br><span class="line"><span class="comment">//    Person(10);//匿名函数对象 特点：当前行执行完后系统就回收了</span></span><br><span class="line"><span class="comment">//    Person(p5);//不能调用拷贝构造函数，来初始化匿名函数对象Person（p5）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式法</span></span><br><span class="line">    Person p6 = <span class="number">10</span>;<span class="comment">//等价于写了Person p6 = Person （10）</span></span><br><span class="line">    Person p7 = p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数的应用"><a href="#拷贝构造函数的应用" class="headerlink" title="拷贝构造函数的应用"></a>拷贝构造函数的应用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Person()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的默认构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有参构造</span></span><br><span class="line">        Person(<span class="keyword">int</span> age)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Age = age;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的有参构造函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拷贝构造</span></span><br><span class="line">        Person (<span class="keyword">const</span> Person &amp;p)<span class="comment">// 类名（const 类名 &amp;aa）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"拷贝构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            m_Age = p.m_Age;</span><br><span class="line">        &#125;</span><br><span class="line">        ~Person()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" 析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m_Age;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">        <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2以值传递的方式，给函数的参数传值，调用拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p1;</span><br><span class="line">        doWork(p1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 以值的方式来返回局部对象</span></span><br><span class="line">    <span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p1;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p = doWork2();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的默认构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    Person(<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的有参构造函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    拷贝构造</span></span><br><span class="line">    Person (<span class="keyword">const</span> Person &amp;p)<span class="comment">// 类名（const 类名 &amp;aa）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"拷贝构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" 析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1.系统会默认给一个类添加至少3个函数，默认构造函数，析构函数，拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p2.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 如果我们自己提供了有参构造的函数，那么系统就不会默认提供构造函数了；但是依然会提供拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Person p2;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.如果我们自己提供了拷贝构造函数，那么系统就不会提供其他普通构造函数了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值得注意的是，当有参构造由默认参数的时候，不需要自己写无参构造也可以直接调用无参构造函数</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> *name ,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person有参函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     m_Name =(<span class="keyword">char</span>*)   <span class="built_in">malloc</span> (<span class="built_in">strlen</span>(name)+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(m_Name,name);</span><br><span class="line">     m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不自己写拷贝函数，那么系统提供的拷贝函数只会做简单的值拷贝（浅拷贝），如果类中有属性开辟打了堆区，在释放时，由于浅拷贝问题导致堆区内容会重复释放，程序运行不了</span></span><br><span class="line">    Person (<span class="keyword">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">        <span class="comment">//利用深拷贝，解决拷贝带来的问题</span></span><br><span class="line">        m_Name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p.m_Name)+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_Name,p.m_Name);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Name!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">free</span>(m_Name);</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom"</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1的姓名"</span>&lt;&lt;p1.m_Name&lt;&lt;<span class="string">"p1的年龄"</span>&lt;&lt;p1.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"P2Name"</span>&lt;&lt;p2.m_Name&lt;&lt;<span class="string">"p2Age"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    Person(int a,int b,int c)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        m_A = a;</span></span><br><span class="line"><span class="comment">//        m_B = b;</span></span><br><span class="line"><span class="comment">//        m_C = c;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">Person (<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c):m_A(a),m_B(b),m_C(c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//相当于上面的几行代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="comment">//Person p1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Phone(<span class="built_in">string</span> pName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Phone ????????"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_PhoneName = pName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> m_PhoneName;</span><br><span class="line">    ~Phone()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Phone ????????"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Game(<span class="built_in">string</span> gName)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Game????????"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_GameName = gName;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Game()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Game????????"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> m_GameName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name,<span class="built_in">string</span> pName,<span class="built_in">string</span> gName):m_Name(name),m_Phone(pName),m_Game(gName)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Person????????"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person????????"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line">    Game m_Game;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"??"</span>,<span class="string">"APPLE"</span>,<span class="string">"????"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicit关键词"><a href="#Explicit关键词" class="headerlink" title="Explicit关键词"></a>Explicit关键词</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString(<span class="keyword">char</span> *string1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//explicit 关键词用途：防止隐式类型转换来初始化对象；</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span>   <span class="title">MyString</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     m_Len = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *m_Str;</span><br><span class="line">    <span class="keyword">int</span> m_Len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyString::MyString(<span class="keyword">const</span> MyString &amp;str) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyString str = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="function">MyString <span class="title">str2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    MyString str4 = MyString(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="New和delete运算符"><a href="#New和delete运算符" class="headerlink" title="New和delete运算符"></a>New和delete运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new以后就不用malloc代码了</span></span><br><span class="line"><span class="comment">//Person *person = new Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的默认构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造</span></span><br><span class="line">    Person(<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person 的有参构造函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    拷贝构造</span></span><br><span class="line">    Person (<span class="keyword">const</span> Person &amp;p)<span class="comment">// 类名（const 类名 &amp;aa）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"拷贝构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" 析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1.区别</span></span><br><span class="line"><span class="comment">//new 是一个运算符 malloc是一个库函数</span></span><br><span class="line"><span class="comment">//malloc返回值是void* new 返回出来的是new出来的对象的指针</span></span><br><span class="line"><span class="comment">//malloc需要判断是否开辟成功，new内部做好了这种操作（内部会malloc）</span></span><br><span class="line"><span class="comment">//malloc 不会调用构造函数，而new 调用了构造函数</span></span><br><span class="line"><span class="comment">//malloc对应的释放时free，而new对应的释放时delete；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Person p1； //在栈上</span></span><br><span class="line">    Person *person = <span class="keyword">new</span> Person;<span class="comment">//默认</span></span><br><span class="line">    Person *person2 = <span class="keyword">new</span> Person(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">    Person *person3 = <span class="keyword">new</span> Person(*person2);<span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="comment">//释放出new出来的对象</span></span><br><span class="line">    <span class="keyword">delete</span>(person);</span><br><span class="line">    <span class="keyword">delete</span> (person2);</span><br><span class="line">    <span class="keyword">delete</span>(person3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.注意事项</span></span><br><span class="line"><span class="comment">//不要用void * 去接受new出来的对象，原因是不能够释放</span></span><br><span class="line"><span class="comment">//3.利用new去创建数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    int *pInt = new int [10];</span></span><br><span class="line"><span class="comment">//    char *pchar = new char[10];</span></span><br><span class="line">    <span class="comment">//用new在"堆区"创建数组，类中必须要存在默认构造函数，否则无法创建</span></span><br><span class="line">    Person *persons = <span class="keyword">new</span> Person[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//在栈上创建数组时，那么可以指定利用哪个构造函数来初始化对象</span></span><br><span class="line"><span class="comment">//    Person person2[10]  = &#123;Person(10),Person(10),Person(10)&#125;;</span></span><br><span class="line">    <span class="comment">//如果是数组的话，要在delete后加上[]</span></span><br><span class="line">    <span class="keyword">delete</span> []persons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++04</title>
    <url>/2020/04/20/C-04/</url>
    <content><![CDATA[<h1 id="Day04-总结"><a href="#Day04-总结" class="headerlink" title="Day04 总结"></a>Day04 总结</h1><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态成员变量与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝 静态成员变量，属于某个类，所有对象共享</span></span><br><span class="line"><span class="comment">//1 静态成员必须再类中声明，在类外定义</span></span><br><span class="line"><span class="comment">//2 静态数据成员不属于某个对象，在为对象分配空间中不包静态成员所占的空间</span></span><br><span class="line"><span class="comment">//3 静态数据成员可通过类名或者对象名来引用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="comment">//1，共享</span></span><br><span class="line">    <span class="comment">//2. 在编译阶段就分配了内存</span></span><br><span class="line">    <span class="comment">//3，在类内声明，在类外初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">200</span>; <span class="comment">// 非静态成员函数，可以访问两种变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fuc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//         m_C = 100;//静态成员函数 是不可以访问非静态成员变量的</span></span><br><span class="line">        m_A = <span class="number">100</span>;<span class="comment">//静态成员函数 可以访问静态成员变量 ，因为都是共享数据</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"静态成员函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    int m_C ;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_B;<span class="comment">//私有权限的数据，类外访问不到</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_A=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B=<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//访问方式</span></span><br><span class="line">    <span class="comment">//1.通过对象进行访问</span></span><br><span class="line"></span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p2.m_A&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//都变20；</span></span><br><span class="line">    <span class="comment">//通过类名进行访问</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_A = "</span>&lt;&lt;Person::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1 通过对象可以进行调用</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.fuc();</span><br><span class="line">    <span class="comment">//2.通过类名进行调用</span></span><br><span class="line">    <span class="comment">//3 静态成员函数 也是有访问权限的，私有的权限类外访问不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"单例调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> printer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTest</span><span class="params">(<span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Count ++;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"打印的内容：："</span>&lt;&lt;test&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_Count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Printer *printer;</span><br><span class="line">    Printer()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"构造调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Printer(<span class="keyword">const</span> Printer &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Printer *Printer::printer = <span class="keyword">new</span> Printer();<span class="comment">//中间的Printer是作用域，作用在类里面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Printer *p1 = Printer::getInstance();<span class="comment">//这里用p1-&gt;getInstance也可以的</span></span><br><span class="line">    p1-&gt;printTest(<span class="string">"入职申请"</span>);</span><br><span class="line">    p1-&gt;printTest(<span class="string">"离职申请"</span>);</span><br><span class="line">    p1-&gt;printTest(<span class="string">"旅游申请"</span>);</span><br><span class="line">    p1-&gt;printTest(<span class="string">"请假申请"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"使用打印机的次数::"</span>&lt;&lt;p1-&gt;m_Count &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Printer *p2 = Printer::getInstance();</span><br><span class="line">    p2-&gt;printTest(<span class="string">"调休"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"使用打印机的次数::"</span>&lt;&lt;p2-&gt;m_Count &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象模型"><a href="#面向对象模型" class="headerlink" title="面向对象模型"></a>面向对象模型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;<span class="comment">//成员属性 算在类的大小中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_B;<span class="comment">//静态成员变量，不属于类的大小中</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span><span class="comment">//静态成员函数，不属于类的大小中</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_C;<span class="comment">//sizeof+4</span></span><br><span class="line">    <span class="keyword">double</span> m_D;<span class="comment">//sizeof+8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//空类大小为：：1</span></span><br><span class="line">    <span class="comment">//空类也可以实例化的，每个对象在内存中应该都有独一无二的地址</span></span><br><span class="line">    <span class="comment">//Person p[10];    p[0]</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(Person)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this指针的基本使用"><a href="#this指针的基本使用" class="headerlink" title="this指针的基本使用"></a>this指针的基本使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Created by Jason on 2020/3/24.</span></span><br><span class="line"><span class="comment">1.this 指针指向的是被调用的成员函数所属的对象</span></span><br><span class="line"><span class="comment">2.*this 对象本体</span></span><br><span class="line"><span class="comment">3.this 可以解决名称冲突</span></span><br><span class="line"><span class="comment">链式编程*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//this 指针指向的是被调用的成员函数所属的对象</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line"><span class="comment">//        age = age;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"年龄"</span>&lt;&lt;<span class="keyword">this</span>-&gt;age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">AddAge</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age +=p.age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1.age&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//解决名称冲突</span></span><br><span class="line">    p1.showAge();</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    p1.AddAge(p2).AddAge(p2);</span><br><span class="line">    p1.showAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果是一个空指针 可以访问没有this 的一些成员函数</span></span><br><span class="line"><span class="comment">如果函数中用了this指针，程序会down掉</span></span><br><span class="line"><span class="comment">严谨的写一下加上if判断*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showCLassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"classNAme is Person"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//NULL -&gt;m_age;//需要用if(this ==NULL)判断</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"AGE ="</span>&lt;&lt; <span class="keyword">this</span>-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//     Person p1;</span></span><br><span class="line"><span class="comment">//    p1.m_Age = 18;</span></span><br><span class="line"><span class="comment">//    p1.showAge();</span></span><br><span class="line"><span class="comment">//    p1.showCLassName();</span></span><br><span class="line">    Person *p1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//    p1-&gt;showAge();//会报错</span></span><br><span class="line">    p1-&gt;showCLassName();<span class="comment">//没有用this指针，不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常含数与常对象"><a href="#常含数与常对象" class="headerlink" title="常含数与常对象"></a>常含数与常对象</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *this 本质是指针常量 type *const this</span></span><br><span class="line"><span class="comment"> *      1.1指针的指向是不能修改的，指针指向的值可以改</span></span><br><span class="line"><span class="comment"> *      1.2要想让值都不能改，需要在函数的括号后加上const</span></span><br><span class="line"><span class="comment"> *有些特例的属性，即使在长函数或者常对象中都可以修改，需要加上mutable</span></span><br><span class="line"><span class="comment"> * 常对象 const Person p；</span></span><br><span class="line"><span class="comment"> * 常对象，是不可以调用普通成员函数的，只能调用常函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_B;<span class="comment">//加了这个关键字，即使是常函数，m_A也可以修改</span></span><br><span class="line">    <span class="comment">//《成员函数》声明后面加上const 代表常函数，不可以修改成员属性了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Person *const this</span></span><br><span class="line">        <span class="comment">//This 指针的本质是一个指针常量，指针指向是不能修改的，指针指向的值可以改</span></span><br><span class="line">        <span class="comment">//要想让值都不能改，需要在函数的括号后加上const</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"aaa"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">10</span>;</span><br><span class="line">    p1.showPerson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Person p2&#123;&#125;;<span class="comment">//常对象</span></span><br><span class="line">    <span class="comment">//常对象不可以修改内部属性</span></span><br><span class="line">	<span class="comment">//p2.m_A = 20;会报错</span></span><br><span class="line">    p2.m_B =<span class="number">100</span>;<span class="comment">//常对象，只能调用常函数</span></span><br><span class="line">    <span class="comment">//p2.showPerson2();//常对象，是不可以调用普通成员函数的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局函数作为友元函数"><a href="#全局函数作为友元函数" class="headerlink" title="全局函数作为友元函数"></a>全局函数作为友元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*友元</span></span><br><span class="line"><span class="comment"> *  1.1 有一个全局函数作为本类的友元函数，可以访问到私有内容</span></span><br><span class="line"><span class="comment"> *  1.2类的内部写入friend+函数声明</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="comment">//有一个全局函数作为本类的友元函数，可以访问到私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building &amp;building)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Building()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//好基友全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building &amp;building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"好基友正在访问"</span>&lt;&lt;building.m_SittingRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"好基友正在访问"</span>&lt;&lt;building.m_BedRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//直接这样写是访问不到Bedroom的，要在class里加上友元</span></span><br><span class="line">    <span class="comment">//加上以后就可以访问了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Building b;</span><br><span class="line">    goodGay(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类作为友元类"><a href="#类作为友元类" class="headerlink" title="类作为友元类"></a>类作为友元类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*类作为友元类</span></span><br><span class="line"><span class="comment"> * 1有缘关系不能被继承</span></span><br><span class="line"><span class="comment"> * 2友元关系是单向的，类A 是类B的朋友。但类B不一定是类A的朋友</span></span><br><span class="line"><span class="comment"> * 3友元关系不具有传递性。类B是类A的盆友，类C是类B的朋友，但类C不一定是类A的朋友</span></span><br><span class="line"><span class="comment"> *      告诉编译器 goodGay是友元类，可以访问里面的私有内容</span></span><br><span class="line"><span class="comment"> *      在类的内部写入 friend class 类名</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span><span class="comment">//先让ide不要报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    goodGay();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="comment">//告诉编译器 goodGay是友元类，可以访问里面的私有内容</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line">    <span class="comment">//虽然goodGay中可以访问Building类，但Building类中不能访问goodGay</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Building();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外做函数实现</span></span><br><span class="line">goodGay::goodGay() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"GoodGAy is visiting"</span>&lt;&lt;<span class="keyword">this</span>-&gt;building-&gt;m_SittingRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"GoodGAy is visiting"</span>&lt;&lt;<span class="keyword">this</span>-&gt;building-&gt;m_BedRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//如果不声明友元类，在这里访问的话就会报错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Building::Building() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数作为友元函数"><a href="#成员函数作为友元函数" class="headerlink" title="成员函数作为友元函数"></a>成员函数作为友元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*成员函数作为友元函数</span></span><br><span class="line"><span class="comment"> *      告诉编译器， goodGay中的visit可以访问Building类中的私有内容</span></span><br><span class="line"><span class="comment">        friend void goodGay::visit() ;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span><span class="comment">//先让ide不要报错</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    goodGay();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//visit 可以访问Building 中的私有属性</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">//visit2 不可以</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="comment">//告诉编译器， goodGay中的visit可以访问Building类中的私有内容</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Building();</span><br><span class="line">    <span class="built_in">string</span> m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外做函数实现</span></span><br><span class="line">goodGay::goodGay() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"GoodGAy is visiting"</span>&lt;&lt;<span class="keyword">this</span>-&gt;building-&gt;m_SittingRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"GoodGAy is visiting"</span>&lt;&lt;<span class="keyword">this</span>-&gt;building-&gt;m_BedRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//如果不声明友元类，在这里访问的话就会报错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"BAD GAy is visiting"</span>&lt;&lt;<span class="keyword">this</span>-&gt;building-&gt;m_SittingRoom&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;"BAD GAy is visiting"&lt;&lt;this-&gt;building-&gt;m_BedRoom&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Building::Building() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line">    gg.visit2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++05</title>
    <url>/2020/04/20/C-05/</url>
    <content><![CDATA[<h1 id="DAY05-总结"><a href="#DAY05-总结" class="headerlink" title="DAY05  总结"></a>DAY05  总结</h1><h2 id="01数组类封装"><a href="#01数组类封装" class="headerlink" title="01数组类封装"></a>01数组类封装</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* <span class="number">1</span> 提供<span class="keyword">int</span> 类数组</span><br><span class="line">* <span class="number">2</span> 属性</span><br><span class="line">*      <span class="number">2.1</span> <span class="keyword">int</span> *paddreass堆区数组指针</span><br><span class="line">*      <span class="number">2.2</span> <span class="keyword">int</span> m_capacity 数组容量</span><br><span class="line">* <span class="number">3</span> 数组类封装中将对象，当数组名对待，可以用【】重载</span><br><span class="line">*      <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[]（<span class="keyword">int</span> index）这样可以用来当左值</span><br></pre></td></tr></table></figure>

<h2 id="02加号运算符重载"><a href="#02加号运算符重载" class="headerlink" title="02加号运算符重载"></a>02加号运算符重载</h2><p><img src="/2020/04/20/C-05/C:%5CUsers%5CJason%5CCPP%5CLessons%5CDay05_Operator%5C%E5%8A%A0%E5%8F%B7%E9%87%8D%E8%BD%BD.png" alt="加号重载"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*加号运算符重载</span></span><br><span class="line"><span class="comment"> *      对于内置数据类型，编译器知道该如何进行运算</span></span><br><span class="line"><span class="comment"> *      但是对于自定义数据类型，编译器不知道如何运算</span></span><br><span class="line"><span class="comment"> *      利用运算符重载，。可以解决问题</span></span><br><span class="line"><span class="comment"> *      分别用成员函数和全局函数来实现</span></span><br><span class="line"><span class="comment"> *          //成员函数的本质</span></span><br><span class="line"><span class="comment">            //Person p3 = p1.operator+（p2）</span></span><br><span class="line"><span class="comment">            //全局函数的本质</span></span><br><span class="line"><span class="comment">            //Person p3 = operator+(p1,p2)</span></span><br><span class="line"><span class="comment"> *          都可以简化为p3 = p1+p2;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;&#125;;</span><br><span class="line">    Person(<span class="keyword">int</span> a,<span class="keyword">int</span> b):m_A(a),m_B(b)&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">    <span class="comment">//成员函数进行+运算符重载</span></span><br><span class="line"><span class="comment">//    Person operator+(Person &amp;p)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        Person temp;</span></span><br><span class="line"><span class="comment">//        temp.m_A = this-&gt;m_A+p.m_A;</span></span><br><span class="line"><span class="comment">//        temp.m_B = this-&gt;m_B+p.m_B;</span></span><br><span class="line"><span class="comment">//        return temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用全局函数进行+运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1,Person&amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p1.m_A+p2.m_A;</span><br><span class="line">    temp.m_B = p1.m_B+p2.m_B;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载可不可以发生函数重载？</span></span><br><span class="line"><span class="comment">//是可以的</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1,<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p1.m_A+a;</span><br><span class="line">    temp.m_B = p1.m_B+a;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">12</span>,<span class="number">23</span>)</span></span>;</span><br><span class="line">    Person p3 = p2+p1;</span><br><span class="line">    <span class="comment">//成员函数的本质</span></span><br><span class="line">    <span class="comment">//Person p3 = p1.operator+（p2）</span></span><br><span class="line">    <span class="comment">//全局函数的本质</span></span><br><span class="line">    <span class="comment">//Person p3 = operator+(p1,p2)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p3的A：："</span>&lt;&lt;p3.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"P3的B：："</span>&lt;&lt;p3.m_B&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Person p4 = p1+<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p4的A：："</span>&lt;&lt;p4.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"P4的B：："</span>&lt;&lt;p4.m_B&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="03左移运算符重载"><a href="#03左移运算符重载" class="headerlink" title="03左移运算符重载"></a>03左移运算符重载</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*左移运算符重载</span></span><br><span class="line"><span class="comment"> * 运算符重载是一种函数的调用的方式</span></span><br><span class="line"><span class="comment"> * 重载运算符的定义就是一种函数，函数名为operator@</span></span><br><span class="line"><span class="comment"> * @就是想要重载的运算符</span></span><br><span class="line"><span class="comment"> * 全局函数（一元是一个参数，二元两个参数）</span></span><br><span class="line"><span class="comment"> * 成员函数（一元没有参数，二元一个参数）</span></span><br><span class="line"><span class="comment"> *      重载左移</span></span><br><span class="line"><span class="comment"> *          利用成员函数：失败，原因是不能让cout在左侧</span></span><br><span class="line"><span class="comment"> *          利用全局函数：ostream &amp;operator&lt;&lt;(ostream &amp;cout,Person&amp;p)</span></span><br><span class="line"><span class="comment"> *          如果Person属性是私有的，配合友元使用</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="comment">//将全局函数左移运算符重载变为Person 的友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;<span class="built_in">cout</span>, Person &amp;p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person();</span><br><span class="line">    Person(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    试图运用成员函数实现&lt;&lt;运算符重载</span></span><br><span class="line"><span class="comment">//    void operator&lt;&lt;(ostream&amp;cout)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        不方便。</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用全局函数实现&lt;&lt;运算符重载</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;<span class="built_in">cout</span>, Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"m_A = "</span>&lt;&lt;p.m_A&lt;&lt;<span class="string">" m_B="</span>&lt;&lt;p.m_B;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;p1&lt;&lt;endl;//在没有重载之前，这是错误的写法</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="04递增运算符重载"><a href="#04递增运算符重载" class="headerlink" title="04递增运算符重载"></a>04递增运算符重载</h2><p> <img src="/2020/04/20/C-05/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay05_Operator%5C%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.png" alt="递增运算符重载"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*递增运算符重载</span></span><br><span class="line"><span class="comment"> *对于++和--来说，后置形式先返回，然后对象++或者--，返回的是对象的原值</span></span><br><span class="line"><span class="comment"> * 代码调用的时候，要优先使用前缀形式，除非确实需要后缀形式。前缀的效率会高一点</span></span><br><span class="line"><span class="comment"> * 前置++ 返回引用 Myint&amp;operator++（）</span></span><br><span class="line"><span class="comment"> * 后置++ 返回值   Myint operator++（int）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInter</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;<span class="built_in">cout</span>, MyInter &amp;myInt);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyInter()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载前置</span></span><br><span class="line">    MyInter&amp; <span class="keyword">operator</span>++()<span class="comment">//效率高，直接返回自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先++</span></span><br><span class="line">        m_number++;</span><br><span class="line">        <span class="comment">//后返回</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载后置 要把参数放进去 返回值也不一样</span></span><br><span class="line">    MyInter <span class="keyword">operator</span>++(<span class="keyword">int</span>)<span class="comment">//效率低，需要拷贝值</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyInter temp = *<span class="keyword">this</span>;<span class="comment">//当时的状态</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_number++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_number;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;<span class="built_in">cout</span>, MyInter &amp;myInt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;myInt.m_number;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInter i1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;++(++i1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInter i2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; i2++ &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="05智能指针"><a href="#05智能指针" class="headerlink" title="05智能指针"></a>05智能指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*智能指针</span></span><br><span class="line"><span class="comment"> * 智能用途 用来托管堆区创建的对象的释放</span></span><br><span class="line"><span class="comment"> * 如果想让sp对象当作一个指针去对待，需要重载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"有参构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"AGE IS  "</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//智能指针 用来托管new出来的对象的释放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmartPointer(Person *person1)</span><br><span class="line">    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"SMARTPOINTER构造"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = person1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载指针的运算符</span></span><br><span class="line">    Person* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    ~SmartPointer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;person !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"SMARTPOINTER"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">            <span class="keyword">this</span>-&gt;person =<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Person *p=new Person(10);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    delete(p);</span></span><br><span class="line"></span><br><span class="line">    SmartPointer sp = SmartPointer(<span class="keyword">new</span> Person(<span class="number">18</span>));</span><br><span class="line">    sp-&gt;showAge();<span class="comment">//sp-&gt;-&gt;showAge 才是原来的，编译器简化为sp-&gt;showAge();</span></span><br><span class="line">    (*sp).showAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="06赋值运算符的重载"><a href="#06赋值运算符的重载" class="headerlink" title="06赋值运算符的重载"></a>06赋值运算符的重载</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 赋值运算符的重载</span></span><br><span class="line"><span class="comment"> *统会默认给一个类创建至少3个函数 默认构造，析构，拷贝构造（简单值拷贝） operator=（值拷贝）</span></span><br><span class="line"><span class="comment"> * 由于系统提供的operator= 会进行简单的值拷贝，属性中有堆区的数据，系统会崩</span></span><br><span class="line"><span class="comment"> * 返回值 Person&amp; operator=(const Person&amp;p)</span></span><br><span class="line"><span class="comment"> * */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> *name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(name)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_Name,name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//系统会默认给一个类创建至少3个函数 默认构造，析构，拷贝构造（简单值拷贝） operator=（值拷贝）</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先判断原来的堆区是否有数据</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> []<span class="keyword">this</span>-&gt;m_Name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.m_Name)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_Name, p.m_Name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = p.m_Age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.m_Name)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_Name,p.m_Name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age= p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> []<span class="keyword">this</span>-&gt;m_Name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"TOM"</span>,<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"JERRY"</span>,<span class="number">17</span>)</span></span>;</span><br><span class="line"><span class="comment">//    p1 =p2;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS ::"</span>&lt;&lt;p1.m_Name&lt;&lt;<span class="string">"  AGE IS:"</span>&lt;&lt;p1.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS ::"</span>&lt;&lt;p2.m_Name&lt;&lt;<span class="string">"  AGE IS:"</span>&lt;&lt;p2.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">" "</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    p3=p2=p1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS ::"</span>&lt;&lt;p2.m_Name&lt;&lt;<span class="string">"  AGE IS:"</span>&lt;&lt;p2.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS ::"</span>&lt;&lt;p3.m_Name&lt;&lt;<span class="string">"  AGE IS:"</span>&lt;&lt;p3.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(p3)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS ::"</span>&lt;&lt;p4.m_Name&lt;&lt;<span class="string">"  AGE IS:"</span>&lt;&lt;p4.m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="07关系运算符重载"><a href="#07关系运算符重载" class="headerlink" title="07关系运算符重载"></a>07关系运算符重载</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Person&amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"小红"</span>,<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"小白"</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(p1==p2)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"p1等于p2"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1不等于p2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(p1!=p2)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"p1不等于p2"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"p1等于p2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="08函数调用运算符重载"><a href="#08函数调用运算符重载" class="headerlink" title="08函数调用运算符重载"></a>08函数调用运算符重载</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现两个（）重载</span></span><br><span class="line"><span class="comment"> * 进行打印输出文本</span></span><br><span class="line"><span class="comment"> * 进行加法运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">text</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span>  a+b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyFunc func;<span class="comment">//仿函数</span></span><br><span class="line">    func(<span class="string">"Hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="不要重载-amp-amp-和"><a href="#不要重载-amp-amp-和" class="headerlink" title="不要重载&amp;&amp;和||"></a>不要重载&amp;&amp;和||</h1>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++06</title>
    <url>/2020/04/20/C-06/</url>
    <content><![CDATA[<h1 id="Day06总结"><a href="#Day06总结" class="headerlink" title="Day06总结"></a>Day06总结</h1><p> <img src="/2020/04/20/C-06/1.png" alt="为什么要继承"> </p>
<h2 id="02继承的基本语法"><a href="#02继承的基本语法" class="headerlink" title="02继承的基本语法"></a>02继承的基本语法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">语法  <span class="class"><span class="keyword">class</span> 子类：继承方式</span></span><br><span class="line"><span class="class">//利用继承，可以减少重复代码出现</span></span><br><span class="line"><span class="class">//先把公共的部分建立一个类</span></span><br><span class="line"><span class="class">//基类——派生类</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">GamePage</span>:</span> <span class="keyword">public</span> BasePage</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPage</span>:</span> <span class="keyword">public</span> BasePage</span><br></pre></td></tr></table></figure>

<h2 id="03继承方式"><a href="#03继承方式" class="headerlink" title="03继承方式"></a>03继承方式</h2><p><img src="/2020/04/20/C-06/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay06_String_JI_Chen%5C%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.png" alt="继承方式"></p>
<p><img src="/2020/04/20/C-06/C:%5CUsers%5CJason%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417131702116.png" alt="image-20200417131702116"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span>:</span><span class="keyword">public</span> base1</span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> base1</span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> base1</span><br></pre></td></tr></table></figure>

<h2 id="04继承中的对象模型"><a href="#04继承中的对象模型" class="headerlink" title="04继承中的对象模型"></a>04继承中的对象模型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父类的私有属性，子类继承了，但是编译器给隐藏了因此访问不到</span><br></pre></td></tr></table></figure>

<h2 id="05继承中的构造与析构函数"><a href="#05继承中的构造与析构函数" class="headerlink" title="05继承中的构造与析构函数"></a>05继承中的构造与析构函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *继承中的构造与析构函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      初始化列表</span></span><br><span class="line"><span class="comment"> *      可以用初始化列表语法显示制定出调用父类的哪个构造函数</span></span><br><span class="line"><span class="comment"> *      子类不会继承父类中的构造和析构函数，只有父类自己才知道如何构造和析构函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()</span><br><span class="line">    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Base构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~Base()</span><br><span class="line">    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Base析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承中，先调用父类的构造，在调用子类构造</span></span><br><span class="line"><span class="comment">//析构中，顺序相反</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son1()</span><br><span class="line">    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Son构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;  </span><br><span class="line">    ~Son1()</span><br><span class="line">    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"Son析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*********************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    <span class="comment">//可以用初始化列表语法显示制定出调用父类的哪个构造函数</span></span><br><span class="line">    Son2(<span class="keyword">int</span> a):Base2(a)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s;<span class="comment">//现有爸爸后有儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Son2 s;//报错，因为父类里面没有默认构造</span></span><br><span class="line">    <span class="function">Son2 <span class="title">s</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.m_A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="06继承中同名函数的处理"><a href="#06继承中同名函数的处理" class="headerlink" title="06继承中同名函数的处理"></a>06继承中同名函数的处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*如果子类和父类拥有同名成员</span><br><span class="line">*优先调用子类成员，可以通过作用域调用父类成员</span><br><span class="line">*同名的成员函数，子类会隐藏父类中的所有同名版本，需要用作用域调用</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()</span><br><span class="line">    &#123;<span class="keyword">this</span>-&gt;m_A=<span class="number">100</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base 中的Func调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Son 中的Func调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base 中Function（int a）调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base m_A = "</span>&lt;&lt;s.Base::m_A &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    s.func();</span><br><span class="line"><span class="comment">//    s.Base::func();</span></span><br><span class="line"><span class="comment">//同名的成员函数，子类会隐藏掉父类所有重名的版本</span></span><br><span class="line"><span class="comment">//只能调用自己的</span></span><br><span class="line"><span class="comment">//可通过作用域来调用s.Base::func(10);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="07继承中同名静态成员处理"><a href="#07继承中同名静态成员处理" class="headerlink" title="07继承中同名静态成员处理"></a>07继承中同名静态成员处理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*过类名访问</span><br><span class="line">*同名成员函数进行调用</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;<span class="comment">//共享数据，编译阶段分配内存，类内声明类外初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseFUNC"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"BaseFUNCINT"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Base::m_A= <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">29</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对A进行访问</span></span><br><span class="line">    Son s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.Base::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//通过类名访问</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Son::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Son::Base::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Base::m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//同名成员函数进行调用</span></span><br><span class="line">    s.func();</span><br><span class="line">    Son::func(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//子类中同名成员函数会隐藏掉父类中同名成员函数的重载版本。（但是CLion好像会优化）</span></span><br><span class="line">    s.Base::func();</span><br><span class="line">    Son::Base::func();</span><br><span class="line">    Base::func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="08多继承语法"><a href="#08多继承语法" class="headerlink" title="08多继承语法"></a>08多继承语法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*  使用时不太方便，尽量不要写</span><br><span class="line">*  当两个父类中有同名的成员被子类继承后，需要加上作用域</span><br><span class="line"><span class="comment">//如果两个父类有同名，需要加作用域</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base1 中的m_A= "</span>&lt;&lt;s.m_A&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base2 中的m_B= "</span>&lt;&lt;s.m_B&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="/2020/04/20/C-06/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay06_String_JI_Chen%5C%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E3%80%81.png" alt="多继承、、"></p>
<h2 id="09菱形继承"><a href="#09菱形继承" class="headerlink" title="09菱形继承"></a>09菱形继承</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*  Animal 父类 Sheep和Camel 同时继承animal，sheepcamel进行多继承，父类是sheep和camel</span><br><span class="line">*  问题：访问父类中的数据，需要加作用域区分具体数据</span><br><span class="line">*  问题二：由于菱形继承，导致继承的数据有一份是浪费的</span><br><span class="line">*  解决方案：利用虚继承</span><br><span class="line">*  <span class="keyword">virtual</span> Animal 类属于虚基类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//virtual加上以后，继承方式：数据虚继承</span></span><br><span class="line"><span class="comment">//animal 类变为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camel</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sheepCamel</span>:</span><span class="keyword">public</span> Sheep,<span class="keyword">public</span> Camel</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sheepCamel st;</span><br><span class="line">    st.Sheep::m_Age= <span class="number">10</span>;</span><br><span class="line">    st.Camel::m_Age= <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//m_Age只需要一份即可,用虚继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="/2020/04/20/C-06/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay06_String_JI_Chen%5C%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.png" alt="菱形继承"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++07</title>
    <url>/2020/04/20/C-07/</url>
    <content><![CDATA[<h1 id="Day07总结"><a href="#Day07总结" class="headerlink" title="Day07总结"></a>Day07总结</h1><h2 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> * 静态联编和动态联编</span><br><span class="line"> *      静态多态——函数重载、运算符重载</span><br><span class="line"> *      动态多态——父子间继承+虚函数</span><br><span class="line"> *      动态多态满足条件</span><br><span class="line"> *           <span class="number">1.</span>父类中有虚函数</span><br><span class="line"> *           <span class="number">2.</span>子类重写父类的虚函数</span><br><span class="line"> *           <span class="number">3.</span> 父类的指针或者引用指向子类的对象</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"> *      重写的意义</span><br><span class="line"> *      子类重新实现父类中的虚函数，必须返回值，函数名，参数一致才称为重写</span><br><span class="line"> *		在子类中，重写函数前 <span class="keyword">virtual</span>可加可不加</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//加上virtual以后，变成了虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ANIMAL IS TALKING"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ANIMAL IS EATING"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE CAT IS SPEAKING!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE CAT IS EATING!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE DOG IS SPEAKING!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE DOG IS EATING!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Animal &amp; animal = cat 父类的指针或者引用指向子类的对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doeat</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"><span class="comment">//Animal &amp; animal = cat 父类的指针或者引用指向子类的对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用指向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    doSpeak(cat);</span><br><span class="line">    Dog dog;</span><br><span class="line">    doSpeak(dog);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针指向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> Cat;</span><br><span class="line">    Animal*animal1 =<span class="keyword">new</span> Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="02多态原理"><a href="#02多态原理" class="headerlink" title="02多态原理"></a>02多态原理</h2><p><img src="/2020/04/20/C-07/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay07_Duo_Tai%5C%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86.png" alt="多态原理"></p>
<h2 id="03多态案例——计算器"><a href="#03多态案例——计算器" class="headerlink" title="03多态案例——计算器"></a>03多态案例——计算器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* 多态案例——计算器</span><br><span class="line">*    <span class="number">1.</span>  多态的好处：对拓展性的提高，组织性强，可读性强</span><br><span class="line">*    <span class="number">2.</span>  如果父类中有了虚函数，子类并没有重写父类的虚函数，那么这样的代码毫无意义</span><br><span class="line">*    <span class="number">3.</span>  如果子类不重写父类的虚函数，那么没有用到多态带来的好处 ，反而内部结构变化，复杂</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//运行效果和原来一样</span></span><br><span class="line">    <span class="comment">//但是，如果一个类中有纯虚函数出现，这个类就无法实例化对象了</span></span><br><span class="line">    <span class="comment">//有纯虚函数的类，称为抽象类、</span></span><br><span class="line">    <span class="comment">//如果抽象类中有纯虚函数，子类中必须重写纯虚函数！！！否则子类也属于抽象类！！！也无法创造子类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculator</span>:</span><span class="keyword">public</span> AbstractCal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  m_A+m_B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculator</span>:</span><span class="keyword">public</span> AbstractCal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  m_A-m_B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果再加乘法，直接写子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiCalculator</span>:</span><span class="keyword">public</span> AbstractCal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  m_A*m_B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuCalculator</span>:</span><span class="keyword">public</span> AbstractCal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  m_A/m_B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AbstractCal *calculator = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">    calculator-&gt;m_A = <span class="number">100</span>;</span><br><span class="line">    calculator-&gt;m_B= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;calculator-&gt;<span class="built_in">getResult</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    calculator = <span class="keyword">new</span> SubCalculator;<span class="comment">//让calculator重新指向减法</span></span><br><span class="line">    calculator-&gt;m_A = <span class="number">100</span>;</span><br><span class="line">    calculator-&gt;m_B= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;calculator-&gt;<span class="built_in">getResult</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="04抽象类和纯虚函数"><a href="#04抽象类和纯虚函数" class="headerlink" title="04抽象类和纯虚函数"></a>04抽象类和纯虚函数</h2><h3 id="纯虚函数语法"><a href="#纯虚函数语法" class="headerlink" title="纯虚函数语法"></a>纯虚函数语法</h3><ul>
<li>virtual void func() =0;</li>
<li>如果类中有了纯虚函数，那么这个类也称为抽象类</li>
<li>抽象类 是无法实例化对象的</li>
<li>如果抽象类中有纯虚函数，子类中必须重写纯虚函数！！！否则子类也属于抽象类！！！也无法创造子类对象</li>
<li>子类必须实现所有的纯虚函数！</li>
<li>virtual void func() =0;告诉编译器在vtable中为函数保留一个位置，但这个位置不放入地址</li>
</ul>
<h2 id="05虚析构和纯虚析构"><a href="#05虚析构和纯虚析构" class="headerlink" title="05虚析构和纯虚析构"></a>05虚析构和纯虚析构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      如果子类中有属性创建在堆区，那么多态情况下，不会调用子类的析构代码，导致内存泄漏</span><br><span class="line">*      解决方案:虚析构或者纯虚析构</span><br><span class="line">*      虚析构：在析构前加关键词<span class="keyword">virtual</span>即可</span><br><span class="line">*      纯虚析构 <span class="keyword">virtual</span> ~函数名()=<span class="number">0</span>；</span><br><span class="line">*      纯虚析构::类内声明，类外实现</span><br><span class="line">*      如果一个类中有了纯虚析构函数后，那么这个类也属于抽象类型，不能实例化了</span><br><span class="line">*      但是有虚析构，不属于抽象类型，任然能实例化</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ANIMAL 的构造函数调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	虚析构</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Animal()<span class="comment">//有了虚析构，解决了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Animal 虚析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//  纯虚析构，类内实现</span></span><br><span class="line">      <span class="keyword">virtual</span> ~Animal() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外声明</span></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Animal 纯虚析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="06向上向下类型转换"><a href="#06向上向下类型转换" class="headerlink" title="06向上向下类型转换"></a>06向上向下类型转换</h2><p><img src="/2020/04/20/C-07/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay07_Duo_Tai%5C%E5%90%91%E4%B8%8A%E5%90%91%E4%B8%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="向上向下类型转换"></p>
<h2 id="07重写重载重定义"><a href="#07重写重载重定义" class="headerlink" title="07重写重载重定义"></a>07重写重载重定义</h2><p><img src="/2020/04/20/C-07/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay07_Duo_Tai%5C%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%87%8D%E5%AE%9A%E4%B9%89.png" alt="重载重写重定义"></p>
<p><img src="/2020/04/20/C-07/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay07_Duo_Tai%5C%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt="重载重写重定义的代码块"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++08</title>
    <url>/2020/04/20/C-08/</url>
    <content><![CDATA[<h1 id="Day08总结"><a href="#Day08总结" class="headerlink" title="Day08总结"></a>Day08总结</h1><h2 id="01函数模板的基本语法"><a href="#01函数模板的基本语法" class="headerlink" title="01函数模板的基本语法"></a>01函数模板的基本语法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;告诉编译器T是万能数据类型，下面紧跟者的函数或者类中的T类型，不要报错</span><br><span class="line">*      实现通过交换两个数据函数</span><br><span class="line">* 调用模板函数</span><br><span class="line">*      自动类型推到——必须让编译器推导出一致的T类型才可以使用模板</span><br><span class="line">*      显示指定类型——显示告诉编译器T的类型mySwap&lt;<span class="keyword">int</span>&gt;()</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//T是通用类型，告诉编译器不要报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a,T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a=b;</span><br><span class="line">	b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br><span class="line">	<span class="comment">//1.自动类型推导，必须让编译器推导出一致的T</span></span><br><span class="line">	<span class="comment">// swap(a,x)是不行的，如果x是char类型的</span></span><br><span class="line">	mySwap(a,b);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b="</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.1415</span>;</span><br><span class="line">    mySwap(c,d);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c="</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"d="</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 显式指定的类型</span></span><br><span class="line"><span class="comment">//    mySwap&lt;int&gt;(a,x);//x是char类型，在引用条件下是会报错的</span></span><br><span class="line">    <span class="comment">// 显式指定类型，可以进行隐式类型转换，如果转换不成功，那么也不可以用模板</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//模板函数 必须要指定出T的类型，才可以使用</span></span><br><span class="line">    mySwap2&lt;<span class="keyword">double</span> &gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="02函数模板实现int和char的数组排序"><a href="#02函数模板实现int和char的数组排序" class="headerlink" title="02函数模板实现int和char的数组排序"></a>02函数模板实现int和char的数组排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">mySwap</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>) &#123;</span></span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">      a =  b;</span><br><span class="line">     b  = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">printArray</span>(<span class="title">T</span> <span class="title">arr</span>[],<span class="title">int</span> <span class="title">len</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(T arr[] , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;len ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="built_in">min</span>]&gt;arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = j;<span class="comment">//记录最小值的下表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> != i)</span><br><span class="line">        &#123;</span><br><span class="line">            mySwap(arr[i],arr[<span class="built_in">min</span>]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">12</span>,<span class="number">3345</span>,<span class="number">31</span>,<span class="number">2424</span>,<span class="number">657</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    mySort&lt;<span class="keyword">int</span>&gt;(arr,len);</span><br><span class="line">    printArray&lt;<span class="keyword">int</span>&gt;(arr,len);</span><br><span class="line">    <span class="keyword">char</span> charArr[]=<span class="string">"heelllooowoooorllld"</span>;</span><br><span class="line">    len = <span class="keyword">sizeof</span>(charArr)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">    mySort&lt;<span class="keyword">char</span>&gt;(charArr,len);</span><br><span class="line">    printArray&lt;<span class="keyword">char</span> &gt;(charArr,len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="03普通函数和函数模板的区别以及调用规则"><a href="#03普通函数和函数模板的区别以及调用规则" class="headerlink" title="03普通函数和函数模板的区别以及调用规则"></a>03普通函数和函数模板的区别以及调用规则</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      <span class="number">1.</span>C++如果普通函数和函数模板可以同时调用，优先使用的是普通函数</span><br><span class="line">*      <span class="number">2.</span>如果想强制调用函数模板的内容可以使用空参数列表</span><br><span class="line">*      <span class="number">3.</span>函数模板也可以函数重载</span><br><span class="line">*      <span class="number">4.</span>如果函数模板可以产生更好的匹配，那么优先使用函数模板</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myPlus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">myPlus2</span>(<span class="title">T</span> <span class="title">a</span>,<span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c =<span class="string">'c'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;myPlus(a,c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;myPlus2&lt;<span class="keyword">int</span>&gt;(a,c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数和函数模板的调用规则</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myPrint</span>(<span class="title">T</span> <span class="title">a</span>,<span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"函数模板的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">myPrint</span>(<span class="title">T</span> <span class="title">a</span>,<span class="title">T</span> <span class="title">b</span> ,<span class="title">T</span> <span class="title">c</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"函数模板(重载)的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span>  a,<span class="keyword">int</span>  b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"普通函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    myPrint(a,b);</span><br><span class="line">    myPrint&lt;&gt;(a,b);<span class="comment">//空参数列表</span></span><br><span class="line">    <span class="comment">//3. 函数模板也可以函数重载</span></span><br><span class="line">    myPrint&lt;&gt;(a,b, c);</span><br><span class="line">    <span class="comment">//4 如果函数模板可以产生更好的匹配，那么优先使用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> d=<span class="string">'d'</span>;</span><br><span class="line">    <span class="keyword">char</span> e = <span class="string">'e'</span>;</span><br><span class="line">    myPrint(d,e);</span><br><span class="line">    <span class="comment">//上面会调用函数模板，因为普通函数还要做隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="04模板的局限性的解决–具体化"><a href="#04模板的局限性的解决–具体化" class="headerlink" title="04模板的局限性的解决–具体化"></a>04模板的局限性的解决–具体化</h2><img src="/2020/04/20/C-08/Users\Jason\CPP\Lessons\Day08_Template_Func&amp;Class\模板的局限性.png" alt="模板的局限性" style="zoom:67%;">



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      用具体化技术来解决问题</span><br><span class="line">*      <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">*      <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person&amp;a,Person&amp;b)</span><br><span class="line">*      如果是具体化和重载运算符同时出现，优先调用具体化函数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面一段用的是重载运算符来解决问题</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用的是重载==运算符的代码"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name==a.m_Name&amp;&amp;<span class="keyword">this</span>-&gt;m_Age==a.m_Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过模板将那些两个数据的 比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">myCompare</span>(<span class="title">T</span> &amp;<span class="title">a</span>,<span class="title">T</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用函数重载或者具体化Person函数，告诉编译器走Person对比代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> myCompare&lt;Person&gt;(Person&amp;a,Person&amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用的是具体化的代码"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.m_Name==b.m_Name&amp;&amp;a.m_Age==b.m_Age)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"SB"</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"SB"</span>,<span class="number">58</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;myCompare(p1,p2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="05类模板和函数模板的区别"><a href="#05类模板和函数模板的区别" class="headerlink" title="05类模板和函数模板的区别"></a>05类模板和函数模板的区别</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      类模板使用时候不可以用自动类型推导，必须显示指定类型</span><br><span class="line">*      类模板中的类型 可以偶默认参数</span><br><span class="line">*      泛型编程——体现在模板技术——特点：将类型参数化</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">NAMETYPE</span>,<span class="title">class</span> <span class="title">AGETYPE</span>=<span class="title">int</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(NAMETYPE name,AGETYPE age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age=age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    NAMETYPE m_Name;</span><br><span class="line">    AGETYPE  m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    Person p1("Tom",11);这样写是错的 ，不能用自动类型推导</span></span><br><span class="line">    Person&lt;<span class="built_in">string</span>&gt;p1(<span class="string">"Tom"</span>,<span class="number">11</span>);<span class="comment">//类模板必须指定显示函数类型,上面AGETYPE已经有默认参数了，这里可以省略</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS "</span>&lt;&lt;p1.m_Name&lt;&lt;<span class="string">" And AGE IS "</span>&lt;&lt;p1.m_Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="06类模板中成员函数创建时机"><a href="#06类模板中成员函数创建时机" class="headerlink" title="06类模板中成员函数创建时机"></a>06类模板中成员函数创建时机</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person1 Show"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person2 Show"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类模板中的成员函数，并不是一开始就创建出来的，而是在运行阶段才创建出来</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj.showPerson1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj.showPerson2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myClass&lt;Person1&gt;p1;</span><br><span class="line">    p1.func1();</span><br><span class="line"><span class="comment">//    p1.func2();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板作为函数参数"><a href="#类模板作为函数参数" class="headerlink" title="类模板作为函数参数"></a>类模板作为函数参数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      <span class="number">3</span>种方式</span><br><span class="line">*      <span class="number">1</span> .指定传入类型,比较常用，清楚明了</span><br><span class="line">*      <span class="number">2.</span> 参数模板化</span><br><span class="line">*      <span class="number">3.</span> 整个类模板化</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">NAMETYPE</span>,<span class="title">class</span> <span class="title">AGETYPE</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(NAMETYPE name,AGETYPE age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age=age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    NAMETYPE m_Name;</span><br><span class="line">    AGETYPE  m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1 .指定传入类型,比较常用，清楚明了！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&amp;p1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;p1.m_Age&lt;&lt;<span class="string">"  AND  "</span>&lt;&lt;p1.m_Name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p1(<span class="string">"aaa"</span>,<span class="number">10</span>);</span><br><span class="line">    doWork1(p1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doWork2</span>(<span class="title">Person</span>&lt;T1,T2&gt;&amp;<span class="title">person</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;person.m_Age&lt;&lt;<span class="string">"  AND  "</span>&lt;&lt;person.m_Name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//string 替换到T1上面,int 替换到T2上面</span></span><br><span class="line">    Person&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p2(<span class="string">"BBB"</span>,<span class="number">10</span>);</span><br><span class="line">    doWork1(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 整个类模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doWork3</span>(<span class="title">T</span>&amp;<span class="title">person</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;person.m_Age&lt;&lt;<span class="string">"  AND  "</span>&lt;&lt;person.m_Name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p3(<span class="string">"CCC"</span>,<span class="number">10</span>);</span><br><span class="line">    doWork3(p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="08-类模板碰到继承问题以及解决"><a href="#08-类模板碰到继承问题以及解决" class="headerlink" title="08 类模板碰到继承问题以及解决"></a>08 类模板碰到继承问题以及解决</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      如果父类是一个类模板，子类在做继承的时候，必须制定出父类中T的类型，否则无法欸父类中的T分配内存</span><br><span class="line">*      语法：</span><br><span class="line">*      <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="title">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//因为创建子类的时候会调用父类的构造函数</span></span><br><span class="line"><span class="comment">//所以在赋初值的时候要知道T的类型才能分配内存</span></span><br><span class="line"><span class="comment">//需要在Base 后加一个参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T1 m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son&lt;<span class="keyword">int</span> ,<span class="keyword">double</span> &gt;son;</span><br><span class="line">    <span class="comment">//int 是让Son初始化的</span></span><br><span class="line">    <span class="comment">//double是让父类Base初始化的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="09-类模板类外实现成员函数"><a href="#09-类模板类外实现成员函数" class="headerlink" title="09 类模板类外实现成员函数"></a>09 类模板类外实现成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span> ,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">*      <span class="title">void</span> <span class="title">Person</span>&lt;T1,T2&gt;:</span>:showPerson()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name,T2 age);</span><br><span class="line">    <span class="comment">//以下是类内实现</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        this-&gt;m_Name = name;</span></span><br><span class="line"><span class="comment">//        this-&gt;m_Age = age;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//以下是类内实现</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;"姓名："&lt;&lt;this-&gt;m_Name&lt;&lt;" 年龄："&lt;&lt;this-&gt;m_Age&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以下是类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Person</span>&lt;T1,T2&gt;:</span>:Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Person</span>&lt;T1,T2&gt;:</span>:showPerson() &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名："</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">" 年龄："</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;<span class="built_in">string</span> ,<span class="keyword">int</span>&gt;p(<span class="string">"Aaaa"</span>,<span class="number">1002</span>);</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10类模板分文件编写"><a href="#10类模板分文件编写" class="headerlink" title="10类模板分文件编写"></a>10类模板分文件编写</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*       类模板不建议做份文件编写，因为要包含.cpp文件</span><br><span class="line">        解决方法：把类模板的声明和实现放在.hpp文件中，再在.cpp文件中包含.hpp文件，这是约定俗称的</span><br><span class="line">    <span class="comment">//以下代码在.cpp中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(T1 name,T2 age);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Person</span>&lt;T1,T2&gt;:</span>:Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Person</span>&lt;T1,T2&gt;:</span>:showPerson() &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名："</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name&lt;&lt;<span class="string">" 年龄："</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11类模板案例——数组类封装"><a href="#11类模板案例——数组类封装" class="headerlink" title="11类模板案例——数组类封装"></a>11类模板案例——数组类封装</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*      属性</span><br><span class="line">*          T *pAddress;</span><br><span class="line">*          <span class="keyword">int</span> m_Capacity;</span><br><span class="line">*          <span class="keyword">int</span> m_Size;</span><br><span class="line">*      行为</span><br><span class="line">*          有参构造</span><br><span class="line">*          拷贝构造</span><br><span class="line">*          析构</span><br><span class="line">*          <span class="keyword">operator</span>=</span><br><span class="line">*          <span class="keyword">operator</span>[]</span><br><span class="line">*          尾插法</span><br><span class="line">*          尾删法</span><br><span class="line">*          获取数组大小</span><br><span class="line">class MyArray</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> <span class="comment">/*防止隐式转换*/</span>MyArray(<span class="keyword">int</span> capacity)<span class="comment">//MyArray arr(100)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity =capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    MyArray(<span class="keyword">const</span> MyArray&amp;<span class="built_in">array</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity=<span class="built_in">array</span>.m_Capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = <span class="built_in">array</span>.m_Size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress[i] = <span class="built_in">array</span> .pAddress[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有了深拷贝，需要重载复制如算符 arr1 = arr2 =arr3</span></span><br><span class="line">    MyArray&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp;<span class="built_in">array</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先判断原来是否有数据，如果有先释放掉</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pAddress !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[]<span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Capacity=<span class="built_in">array</span>.m_Capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size = <span class="built_in">array</span>.m_Size;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress[i] = <span class="built_in">array</span> .pAddress[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//[]运算符重载  MyArray arr[0]=0;</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾插法********************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(<span class="keyword">const</span> T&amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果超出容量，就不插入</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Capacity ==<span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size]=val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾删法***********************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">popBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Size==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回数组大小*******************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数**********************************************/</span></span><br><span class="line">    ~MyArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pAddress !=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[]<span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">            <span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//真是开辟到堆区数据的指针</span></span><br><span class="line">    T *pAddress;</span><br><span class="line">    <span class="comment">//数组容量</span></span><br><span class="line">    <span class="keyword">int</span> m_Capacity;</span><br><span class="line">    <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******************************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;&#125;;</span><br><span class="line">    Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age):m_Name(name),m_Age(age)&#123;&#125;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;(&amp;<span class="built_in">array</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.getSize(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试int类型数组</span></span><br><span class="line">    <span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">myIntArray</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        myIntArray.pushBack(i+<span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print Int类型数组</span></span><br><span class="line">    printArray(myIntArray);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************************/</span></span><br><span class="line"><span class="comment">//测试自定义类型Person</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(MyArray&lt;Person&gt;&amp;myArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;myArray.getSize();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" NAME IS "</span>&lt;&lt;myArray[i].m_Name&lt;&lt;<span class="string">" AGE IS "</span>&lt;&lt;myArray[i].m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyArray&lt;Person&gt;personArray(<span class="number">10</span>);<span class="comment">//这样会报错，需要在class里面写默认构造函数Person()&#123;&#125;;</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"孙悟空"</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"孙悟空2"</span>,<span class="number">10670</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"孙悟空3"</span>,<span class="number">120</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"孙悟空4"</span>,<span class="number">1030</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"孙悟空5"</span>,<span class="number">10220</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">"孙悟空6"</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p7</span><span class="params">(<span class="string">"孙悟空7"</span>,<span class="number">1030</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p8</span><span class="params">(<span class="string">"孙悟空8"</span>,<span class="number">102</span>)</span></span>;</span><br><span class="line">    personArray.pushBack(p1);</span><br><span class="line">    personArray.pushBack(p2);</span><br><span class="line">    personArray.pushBack(p3);</span><br><span class="line">    personArray.pushBack(p4);</span><br><span class="line">    personArray.pushBack(p5);</span><br><span class="line">    personArray.pushBack(p6);</span><br><span class="line">    personArray.pushBack(p7);</span><br><span class="line">    personArray.pushBack(p8);</span><br><span class="line">    printPerson(personArray);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"SIZE IS "</span>&lt;&lt;personArray.getSize()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-11子集和扩展</title>
    <url>/2020/04/29/JavaScript-11%E5%AD%90%E9%9B%86%E5%92%8C%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="JavaScript-11子集和扩展"><a href="#JavaScript-11子集和扩展" class="headerlink" title="JavaScript-11子集和扩展"></a>JavaScript-11子集和扩展</h1><h3 id="Js的精华不包括什么？"><a href="#Js的精华不包括什么？" class="headerlink" title="Js的精华不包括什么？"></a>Js的精华不包括什么？</h3><ul>
<li>体长使用函数定义表达式而不是函数定义语句</li>
<li>循环体和条件分支都是用花括号括起来，不允许再循环体和条件分支中只包含一条语句时省略花括号</li>
<li>不包含逗号运算符，位运算符以及++和–</li>
<li>不包含==和!= ，这样会进行类型转换，推荐===和!==</li>
<li>var 语句只能出现在函数体的顶部，将所有的变量声明写在一条单独的var语句中</li>
<li>禁止使用全局变量</li>
</ul>
<h3 id="子集的安全性"><a href="#子集的安全性" class="headerlink" title="子集的安全性"></a>子集的安全性</h3><ul>
<li>禁用eval()和Function()构造函数，无法做静态分析</li>
<li>禁止使用this关键字，因为函数可以通过this访问全局对象</li>
<li>禁止使用with，增加静态代码的难度</li>
<li>禁止使用某些全局变量<ul>
<li>完全禁止window或document对象</li>
<li>提供一个外观面板或代理</li>
</ul>
</li>
<li>禁止使用某些属性和方法。如caller和callee，函数的call()和apply()方法，以及constructor和prototype，非标准的属性_proto_</li>
<li>静态分析可以有效地防止带有点  .  运算符的属性存储表达式去独写特殊属性。方括号[]无法做静态分析，安全子集通常精致使用[]，除非方括号内是一个数字或字符串直接量</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>C++09</title>
    <url>/2020/04/20/C-09/</url>
    <content><![CDATA[<h1 id="Day09总结"><a href="#Day09总结" class="headerlink" title="Day09总结"></a>Day09总结</h1><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型转换——静态类型和动态类型转换(static cast)</span></span><br><span class="line"><span class="comment"> * 类型转换——常量类型——重新解释类型转换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一般情况下，尽量少的去使用类型转换，除非来解决非常特殊的问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.静态转换</span></span><br><span class="line"><span class="comment"> *      1.1用于类层次结构中基类（父类）和派生类（子类）之间引用或者指针的转换</span></span><br><span class="line"><span class="comment"> *          1.1.1进行上行转换（派生类引用转换成基类）是安全的</span></span><br><span class="line"><span class="comment"> *          1.1.2进行下行转换（基类指针引用转换成派生类）是不安全的</span></span><br><span class="line"><span class="comment">*       1.2 用于基本数据类型之间的转换，如把int转换成char。</span></span><br><span class="line"><span class="comment"> *          这种转换的安全性也要开发人员来保证</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 静态类型转换 static_cast</span></span><br><span class="line"><span class="comment"> *      语法 static_cast&lt;目标类型&gt;(原对象）</span></span><br><span class="line"><span class="comment"> *      对于内置数据类型是可以转换的</span></span><br><span class="line"><span class="comment"> *      对于自定义数据类型，必须是父子之间的指针或者引用可以转换成功</span></span><br><span class="line"><span class="comment"> * 2.动态类型转换</span></span><br><span class="line"><span class="comment"> *      语法 dynamic_cast&lt;目标类型&gt;(原对象）</span></span><br><span class="line"><span class="comment"> *      对于内置数据类型是不可以转换的</span></span><br><span class="line"><span class="comment"> *      对于自定义数据类型</span></span><br><span class="line"><span class="comment"> *          父转子：不安全，转换失败</span></span><br><span class="line"><span class="comment"> *          子转父：安全，转换成功</span></span><br><span class="line"><span class="comment"> *          如果发生堕胎，总是安全的</span></span><br><span class="line"><span class="comment"> * 3.常量转换（const_cast)</span></span><br><span class="line"><span class="comment"> * 该运算符用来修改类型的const属性</span></span><br><span class="line"><span class="comment"> *      常量指针被转化为非常量指针，并且仍然指向原来的对象</span></span><br><span class="line"><span class="comment"> *      常量引用被转化为非常量引用，并且仍然指向原来的对象</span></span><br><span class="line"><span class="comment"> *      注意：不能直接对非指针和非引用的变量使用const_cast 操作符去直接移除其const</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">/*******************************************************/</span></span><br><span class="line"><span class="comment">//1.静态类型转换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//1.1 内置数据类型的静态类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//内置数据类型</span></span><br><span class="line">    <span class="keyword">char</span> a=<span class="string">'a'</span>;</span><br><span class="line">    <span class="comment">//static_cast&lt;目标类型&gt;（原对象）</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.2 （指针实现）自定义数据类型的静态类型转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//自定义数据类型</span></span><br><span class="line">    Base*base =<span class="literal">NULL</span>;</span><br><span class="line">    Son *son  =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base转为Son*类型 向下类型转换 不安全</span></span><br><span class="line">    Son*son2 = <span class="keyword">static_cast</span>&lt;Son*&gt;(base);</span><br><span class="line">    <span class="comment">//Son 转为Base*类型   向上类型转换 安全</span></span><br><span class="line">    Base*base2 = <span class="keyword">static_cast</span>&lt;Base*&gt;(son);</span><br><span class="line">    <span class="comment">//base 转为Other* 是不会成功的</span></span><br><span class="line">    <span class="comment">//因为没有父子关系</span></span><br><span class="line">     <span class="comment">/*Other*other = static_cast&lt;Base*&gt;(Other);*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.3（引用实现）静态类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    Son son;</span><br><span class="line">    Base&amp; base1 =base;</span><br><span class="line">    Son&amp; son1  = son;</span><br><span class="line">    <span class="comment">//Son 转为Base*类型   向上类型转换 安全</span></span><br><span class="line">    Base&amp; base2 = <span class="keyword">static_cast</span>&lt;Base&amp;&gt;(son1);</span><br><span class="line">    <span class="comment">//base转为Son*类型 向下类型转换 不安全</span></span><br><span class="line">    Son&amp;  son2 = <span class="keyword">static_cast</span>&lt;Son&amp;&gt;(base1);</span><br><span class="line">    <span class="comment">//无继承关系之间的转换 是不成功的</span></span><br><span class="line">   <span class="comment">/*Other&amp;other = static_cast&lt;Base&amp;&gt;(Other);*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">//2.动态类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//内置数据类型，是不允许内置数据类型之间的转换的</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'c'</span>;</span><br><span class="line">    <span class="comment">//以下代码会报错</span></span><br><span class="line">   <span class="comment">/* double d = dynamic_cast&lt;double&gt;(c);*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//base转为Son*类型 向下类型转换 不安全</span></span><br><span class="line">    <span class="comment">//不安全，转换失败</span></span><br><span class="line">    Base*base =<span class="literal">NULL</span>;</span><br><span class="line">    Son *son  =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*Son*son2 = dynamic_cast&lt;Son*&gt;(base);*/</span></span><br><span class="line">    <span class="comment">//Son 转为Base*类型   向上类型转换 安全</span></span><br><span class="line">    Base*base2 = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(son);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果发生多态，那么父子之间转换总是安全的</span></span><br><span class="line">    Base *base3 = <span class="keyword">new</span> Son;</span><br><span class="line">    <span class="comment">//将base3转为Son*</span></span><br><span class="line">    Son*son3 = <span class="keyword">dynamic_cast</span>&lt;Son*&gt;(base3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">//3.常量转换</span></span><br><span class="line"><span class="comment">//3.1指针类型的转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将const int*转为int*</span></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    <span class="comment">//将 p2转为const int*</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p3 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *&gt;(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.2 指针类型的转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//放在符号表中，直接拿掉不可以!!</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;aRef = a;</span><br><span class="line">    <span class="keyword">int</span> &amp;aRef2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(aRef);</span><br><span class="line">    <span class="comment">//注意：不能直接对非指针和非引用的变量使用const_cast 操作符去直接移除其const</span></span><br><span class="line">    <span class="comment">/*int b = const_cast&lt;int&gt;(a);*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************/</span></span><br><span class="line"><span class="comment">//4.重新解释转换 最不安全 不建议用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将base*转为Other*</span></span><br><span class="line">    Base*base = <span class="literal">NULL</span>;</span><br><span class="line">    Other *other = <span class="keyword">reinterpret_cast</span>&lt;Other*&gt;(base);<span class="comment">//是可以转换成功的，就会引起很多操作问题</span></span><br><span class="line">    <span class="comment">//不建议使用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的基本语法"><a href="#异常的基本语法" class="headerlink" title="异常的基本语法"></a>异常的基本语法</h3><p><img src="/2020/04/20/C-09/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay09_YI_Chang_Lei_XIng_Zhuan_Huan%5C%E5%BC%82%E5%B8%B8.png" alt="异常"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三个关键字 try throw catch</span></span><br><span class="line"><span class="comment"> * try：试图执行一段可能会出现异常的代码</span></span><br><span class="line"><span class="comment"> * throw：出现异常后，抛出异常的关键字 throw+类型</span></span><br><span class="line"><span class="comment"> * catch ：捕获异常，catch（类型）</span></span><br><span class="line"><span class="comment"> * 如果在try段执行期间没有异常，那么跟在try后面的catch字句就不会执行</span></span><br><span class="line"><span class="comment"> * catch字句会根据出现的先后顺序被检查，匹配的catch语句捕获并处理异常（或继续抛出异常）</span></span><br><span class="line"><span class="comment"> * 如果匹配的处理未找到，则于宁函数terminate 将自动被调用，其缺省功能调用abort 终止程序</span></span><br><span class="line"><span class="comment"> * 如果处理不了的异常，可以在catch的最后一个分支，使用throw，向上抛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以自定义自己的异常类MyError</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我自己的异常类错误"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person的构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person的析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDivide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*return -1;*/</span><span class="comment">//C语言处理异常缺陷在于，返回值没有统一，返回的值可以是异常的结果，也可以是正确的结果</span></span><br><span class="line">        <span class="comment">/*throw 3.14*/</span>;<span class="comment">//抛出一个1也可以，3.14也可以，不过需要捕获double类型</span></span><br><span class="line">        <span class="comment">//有throw，必要catch</span></span><br><span class="line">        Person p1;</span><br><span class="line">        Person p2;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"AAA"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以发现，Person p1，p2在throw之间，就已经被释放掉了</span></span><br><span class="line">        <span class="comment">/*这就叫栈解旋：从try代码块开始其，到throw抛出异常前</span></span><br><span class="line"><span class="comment">         所有栈上的对象都被释放掉，释放的顺序和构造的顺序都是相反的。*/</span></span><br><span class="line">        <span class="keyword">throw</span> MyError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a/b;<span class="comment">//当a/b=-1时，无法判断是否出错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b=   <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//尝试执行一段可能会出现异常的代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> ret = myDivide(a,b);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ret的结果为 "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//捕获到double以后，不想处理这个异常，想继续往上抛，直接加throw</span></span><br><span class="line">        <span class="keyword">throw</span> ;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"double 类型异常的捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (MyError)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到啦"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"其他 类型异常的捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test01();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    catch (double)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;"double 类型异常的捕获"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MAin 函数Int 类型异常的捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Main 函数其他 类型异常的捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常必须要有人处理，如果</span></span><br><span class="line"></span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常变量的声明周期"><a href="#异常变量的声明周期" class="headerlink" title="异常变量的声明周期"></a>异常变量的声明周期</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *异常变量的生命周期</span></span><br><span class="line"><span class="comment"> *      1.catch (MyException  e)会用拷贝构造</span></span><br><span class="line"><span class="comment">        2.catch (MyException &amp;e) 引用方式，建议用这种方式，节省开销</span></span><br><span class="line"><span class="comment">        3.catch (MyException *e)指针方式，接收抛出 new MyException();堆区创建的对象，记得手动释放delete e;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyException()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MyException构造函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyException(<span class="keyword">const</span> MyException&amp;myException)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MyException拷贝函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyException()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MyException析构函数的调用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *string1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> MyException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doWork(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//     catch (MyException  e)会用拷贝构造</span></span><br><span class="line"><span class="comment">//     catch (MyException &amp;e) 引用方式，建议用这种方式，节省开销</span></span><br><span class="line"><span class="comment">//     catch (MyException *e)指针方式，接收抛出 new MyException();堆区创建的对象，记得手动释放delete e;</span></span><br><span class="line">    <span class="keyword">catch</span> (MyException &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"MyException异常捕获"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常多态的使用"><a href="#异常多态的使用" class="headerlink" title="异常多态的使用"></a>异常多态的使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 异常的多态使用</span></span><br><span class="line"><span class="comment"> *      提供基类异常类：BaseException 纯虚函数 virtual void printError()=0;</span></span><br><span class="line"><span class="comment"> *      提供两个子类继承异常基类，重写父类中的纯虚函数</span></span><br><span class="line"><span class="comment"> *      测试  利用父类引用去接受子类对象，实现多态</span></span><br><span class="line"><span class="comment"> *      抛出那种一场就打印哪种异常的printError函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//异常的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//空指针异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullPointerException</span>:</span><span class="keyword">public</span> BaseException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"空指针异常"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//越界异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutOfRangeException</span>:</span><span class="keyword">public</span> BaseException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"越界异常"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *string1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    throw NullPointerException();</span></span><br><span class="line">    <span class="keyword">throw</span> OutOfRangeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doWork(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BaseException&amp;baseException)</span><br><span class="line">    &#123;</span><br><span class="line">        baseException.printError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统标准异常类"><a href="#系统标准异常类" class="headerlink" title="系统标准异常类"></a>系统标准异常类</h3><p><img src="/2020/04/20/C-09/C:%5CUsers%5CJason%5CCPP%5CC++LessonsBASIC%5CDay09_YI_Chang_Lei_XIng_Zhuan_Huan%5C%E7%B3%BB%E7%BB%9F%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8%E7%B1%BB.png" alt="异常"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用系统标准异常类</span></span><br><span class="line"><span class="comment"> *  标准异常头文件#include &lt;stdexcept&gt;</span></span><br><span class="line"><span class="comment"> *  使用系统异常类  out_of_range("char*)等</span></span><br><span class="line"><span class="comment"> *  捕获：catch (exception &amp;e)或者对应类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//使用系统标准依然需要引用一个头文件</span></span><br><span class="line"><span class="comment">//#include &lt;stdexcept&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(age&lt;<span class="number">0</span>||age&gt;<span class="number">150</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//年龄越界异常抛出</span></span><br><span class="line">            <span class="keyword">throw</span> out_of_range(<span class="string">"年龄必须在100-150之间"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">151</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (out_of_range&amp;e)<span class="comment">//也可以catch(exception&amp;e)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入输出流</span></span><br><span class="line"><span class="comment"> *      cin.get()一次只能读取一个字符</span></span><br><span class="line"><span class="comment"> *      cin.get(一个参数)读取一个字符</span></span><br><span class="line"><span class="comment"> *      cin.get(两个参数)可以读取字符串，不会读取换行符</span></span><br><span class="line"><span class="comment"> *      cin.getline()读取一行，会读取换行符</span></span><br><span class="line"><span class="comment"> *      cin.ignore() 忽略字符</span></span><br><span class="line"><span class="comment"> *      cin.peek()偷窥，偷看一个字符然后再放回缓冲区</span></span><br><span class="line"><span class="comment"> *      cin.putback()把字符放回缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入as  缓冲区中有 a s \n 第一个拿a，第二个拿s 第三个拿\n</span></span><br><span class="line">    <span class="comment">//第四个等待输入</span></span><br><span class="line">   <span class="keyword">char</span> c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">//cin.get(两个参数)读取字符串的时候，不会读取换行符。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cin.get(两个参数）</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"换行还在缓冲区"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"换行不在缓冲区"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">//cin.getline()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">cin</span>.getline(buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"换行还在缓冲区"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"换行不在缓冲区"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    cin.getline 把换行符读取，并且扔掉</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">//cin.ignore ()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.ignore(<span class="number">2</span>);<span class="comment">//没有参数代表忽略一个字符</span></span><br><span class="line">    <span class="comment">//带参数，则说明忽略了n个字符</span></span><br><span class="line">    <span class="keyword">char</span> c  =<span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c ="</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line"><span class="comment">//cin.peek()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入as 看一眼 a，然后再放回缓冲区  缓冲区中还是as</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.<span class="built_in">peek</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c ="</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c ="</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************/</span></span><br><span class="line"><span class="comment">//cin.putback()放回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cin</span>.putback(c);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">cin</span>.getline(buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//先拿走，后来又放回去了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************/</span></span><br><span class="line"><span class="comment">//判断用户输入的内容，是字符串还是数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入一个字符串或者数字："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">cin</span>.<span class="built_in">peek</span>();</span><br><span class="line">    <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"您输入的是数字"</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span>&amp;&amp;c&lt;=<span class="string">'z'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"您输入的是字符串"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"您输入的是啥玩意？？"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************/</span></span><br><span class="line"><span class="comment">//让用户输入一个数字，必须在0-10之间的数字，如果输入有误，重新输入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入0-10之间的数字"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;  <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入正确——数字为"</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//输入正确就退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有误"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//缓冲区中的标志位</span></span><br><span class="line">        <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">cin</span>.sync();<span class="comment">//清空标志位，并且刷新缓冲区</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;"Cin.fail = "&lt;&lt;cin.fail()&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 标准输出流</span></span><br><span class="line"><span class="comment"> *  cout.put() 缓冲区写字符</span></span><br><span class="line"><span class="comment"> *  cout.write()从buffer中写num个字节到当前输出流中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cout.put('a').put('b');</span></span><br><span class="line"><span class="comment">    char buf[] = "helloworld";</span></span><br><span class="line"><span class="comment">    cout.write(buf,strlen(buf));</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//格式化输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过流成员函数</span></span><br><span class="line">    <span class="keyword">int</span> number =<span class="number">99</span>;</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">width</span>(<span class="number">20</span>);<span class="comment">//预留20空间</span></span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">fill</span>(<span class="string">'*'</span>);<span class="comment">//填充</span></span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::left);<span class="comment">//左对齐</span></span><br><span class="line">    <span class="built_in">cout</span>.unsetf(ios::dec);<span class="comment">//卸载十进制</span></span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::hex);<span class="comment">//安装十六进制</span></span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::showbase);<span class="comment">//显示进制基数</span></span><br><span class="line">    <span class="built_in">cout</span>.unsetf(ios::hex);<span class="comment">//卸载十六0进制</span></span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::oct);<span class="comment">//安装八进制</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;number&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用控制符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">88</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">20</span>)</span><br><span class="line">        &lt;&lt;setfill(<span class="string">'*'</span>)</span><br><span class="line">        &lt;&lt;setiosflags(ios::showbase)<span class="comment">//显示基数</span></span><br><span class="line">        &lt;&lt;setiosflags(ios::left)<span class="comment">//左对齐</span></span><br><span class="line">        &lt;&lt;hex    <span class="comment">//安装十六进制</span></span><br><span class="line">        &lt;&lt;number</span><br><span class="line">        &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript_4表达式和运算符</title>
    <url>/2020/04/20/JavaScript-4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p><strong>写在前面</strong></p>
<ul>
<li>我是个Javascript的初学者。有很多地方写的不完善的，多多指教。</li>
<li>内容主要来自老师的ppt，但是存在增删改</li>
<li>我觉得只是听网课的话，走马观花的看一遍其实并不会留下多少印象，但是自己写点东西就会不一样</li>
<li>所以在自己写的时候，可以做到一个信息过滤，将已经懂的，或者艰涩难懂的略去</li>
</ul>
<h1 id="js的表达式和运算符"><a href="#js的表达式和运算符" class="headerlink" title="js的表达式和运算符"></a>js的表达式和运算符</h1><h3 id="4-2-对象和数组的初始化表达式"><a href="#4-2-对象和数组的初始化表达式" class="headerlink" title="4.2 对象和数组的初始化表达式"></a>4.2 对象和数组的初始化表达式</h3><ul>
<li>对象和数组初始化表达式实际上是一个新创建的对象和数组</li>
<li>数组初始化</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] 			<span class="comment">//一个空数组</span></span><br><span class="line">[<span class="number">1</span>+<span class="number">2</span>,<span class="number">3</span>+<span class="number">4</span>]	<span class="comment">//拥有两个元素的数组</span></span><br></pre></td></tr></table></figure>

<p>数组初始化表达式中的元素是可以嵌套的，（数组中的数组）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix =[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]<span class="comment">//二维数组</span></span><br></pre></td></tr></table></figure>

<h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><ul>
<li>JavaScript对数组初始化表达式进行求值的时候，数组初始化表达式中的元素表达式也都会各自计算一次</li>
<li>数组直接两种的列表都好之间的元素可以省略，这是省略的空位会填充值undefined。但结尾处的单个逗号不会创建undefined元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myarray1 = [<span class="number">1</span>,<span class="number">2</span>,,,<span class="number">5</span>];</span><br><span class="line">myarray1[<span class="number">3</span>];<span class="comment">//显示为undefined</span></span><br><span class="line"><span class="keyword">var</span> myarray2 = [<span class="number">1</span>,<span class="number">2</span>,,,<span class="number">5</span>,];</span><br><span class="line">myarray2;</span><br><span class="line">(<span class="number">5</span>)[<span class="number">1</span>,<span class="number">2</span>,empty*<span class="number">2</span>,<span class="number">5</span>]<span class="comment">//最后一个逗号后面不会从创立undefined元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p &#x3D; &#123;x:2,y:1&#125;;	&#x2F;&#x2F;一个拥有两个属性成员的对象</span><br><span class="line">var q &#x3D; &#123;&#125;;			&#x2F;&#x2F;一个空对象</span><br><span class="line">q.x &#x3D; 2 q.y &#x3D; 1;	&#x2F;&#x2F;q的属性成员和p的一样</span><br></pre></td></tr></table></figure>

<ul>
<li>对象直接量也可以嵌套</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rectangle &#x3D; &#123; unpperleft :&#123;x:2,y:2&#125;,lowerleft:&#123;x:2,y:2&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript对数组初始化表达式进行求值的时候，数组初始化表达式中的元素表达式也都会各自计算一次</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">x</span>:<span class="number">2</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> side =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> square = &#123;<span class="string">"upperLeft"</span>:&#123;<span class="attr">x</span>:p.x,<span class="attr">y</span>:p.y&#125;,<span class="string">"lowerleft"</span>:&#123;<span class="attr">x</span>:p.x+side,<span class="attr">y</span>:p.y+side&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Map-补充"><a href="#Map-补充" class="headerlink" title="Map(补充)"></a>Map(补充)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map 是一组键值对的结构，具有极快的查找速度</span></span><br><span class="line"><span class="comment">//用map实现查找，只需要名字-成绩的对照表，直接根据名字查找成绩</span></span><br><span class="line"><span class="comment">//无论这个表多大查找速度都不会慢 o(1)</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>,<span class="number">95</span>],[<span class="string">'Bob'</span>,<span class="number">75</span>],[<span class="string">'Tracy'</span>,<span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">'Micheal'</span>);<span class="comment">//95</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化Map<ul>
<li>初始化Map需要一个二维数组，向上面一样，或者直接初始化一个空的Map</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'Adam'</span>,<span class="number">28</span>);</span><br><span class="line">m.set(<span class="string">'Bob'</span>,<span class="number">21</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>);<span class="comment">//是否存在Adam，返回true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>);<span class="comment">//28</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>)<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//注意，多次对一个key放入value值，会覆盖！</span></span><br></pre></td></tr></table></figure>

<p>++++</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li>创建一个set</li>
<li>通过数组作为输入创建，或者直接创建一个空的set</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">//注意：重复元素在Set中会自动被过滤，也就是说不会重复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素 add()</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s;<span class="comment">//Set(1,2,3,4)</span></span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s;<span class="comment">//Set(1,2,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素delete（）</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">s;<span class="comment">//set&#123;1,2,3&#125;;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s;<span class="comment">//Set&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-3-函数定义表达式"><a href="#4-3-函数定义表达式" class="headerlink" title="4.3 函数定义表达式"></a>4.3 函数定义表达式</h3><ul>
<li>函数定义表达式 定义一个JS函数，表达属的值就是这个新定义的函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-属性访问表达式：得到一个对象属性或者一个数组元素的值"><a href="#4-4-属性访问表达式：得到一个对象属性或者一个数组元素的值" class="headerlink" title="4.4 属性访问表达式：得到一个对象属性或者一个数组元素的值"></a>4.4 属性访问表达式：得到一个对象属性或者一个数组元素的值</h3><ul>
<li>可以通过方括号或者点的方法来访问</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">expression.indentifier</span><br><span class="line">expression[expression]</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:&#123;<span class="attr">z</span>:<span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = &#123;o,<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>]&#125;;</span><br><span class="line">o.x;		<span class="comment">//表达式o.x的属性</span></span><br><span class="line">o.y.z;		<span class="comment">//表达式o.y 的z属性</span></span><br><span class="line">o[<span class="string">"x"</span>];		<span class="comment">//对象o 的x属性</span></span><br><span class="line">a[<span class="number">1</span>];		<span class="comment">//表达式a中索引为1 的元素</span></span><br><span class="line">a[<span class="number">2</span>][<span class="string">"1"</span>];	<span class="comment">//表达式a[2]中索引为1 的元素</span></span><br><span class="line">a[<span class="number">0</span>].x;		<span class="comment">//表达式a[0]的x属性</span></span><br><span class="line">o.z			<span class="comment">//z不是o的属性，所以为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// . 的写法只适用于要访问的属性名称是合法的标识符，且要周到要访问的属性的名字</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-调用表达式"><a href="#4-5-调用表达式" class="headerlink" title="4.5 调用表达式"></a>4.5 调用表达式</h3><ul>
<li>执行过程：首先计算函数表达式，然后计算参数表达式，得到一组参数值</li>
</ul>
<h3 id="4-6-对象创建表达式"><a href="#4-6-对象创建表达式" class="headerlink" title="4.6 对象创建表达式"></a>4.6 对象创建表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Object();</span><br><span class="line">new Point(2,3);</span><br><span class="line">var date &#x3D; new Date();</span><br></pre></td></tr></table></figure>

<h3 id="4-7-运算符概述"><a href="#4-7-运算符概述" class="headerlink" title="4.7 运算符概述"></a>4.7 运算符概述</h3><p><img src="/2020/04/20/JavaScript-4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/4.7.png" alt="示例"></p>
<p><img src="/2020/04/20/JavaScript-4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/4.72.png" alt="示例"></p>
<h3 id="4-8-算术表达式"><a href="#4-8-算术表达式" class="headerlink" title="4.8 算术表达式"></a>4.8 算术表达式</h3><h4 id="4-8-3位运算符"><a href="#4-8-3位运算符" class="headerlink" title="4.8.3位运算符"></a>4.8.3位运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;按位与&amp;</span><br><span class="line">&#x2F;&#x2F;按位或|</span><br><span class="line">&#x2F;&#x2F;按位异或^</span><br><span class="line">&#x2F;&#x2F;按位非~</span><br><span class="line">&#x2F;&#x2F;左移&lt;&lt;</span><br><span class="line">&#x2F;&#x2F;右移&gt;&gt;</span><br><span class="line">&#x2F;&#x2F;无符号右移&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-9关系表达式"><a href="#4-9关系表达式" class="headerlink" title="4.9关系表达式"></a>4.9关系表达式</h3><ul>
<li>关系运算符用于测试两个值之间的关系，返回true或false</li>
</ul>
<h4 id="4-9-1相等和不等运算符"><a href="#4-9-1相等和不等运算符" class="headerlink" title="4.9.1相等和不等运算符"></a>4.9.1相等和不等运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D; 相等</span><br><span class="line">&#x3D;&#x3D;&#x3D; 严格相等</span><br><span class="line">!&#x3D; 不相等</span><br><span class="line">!&#x3D;&#x3D;不严格相等</span><br></pre></td></tr></table></figure>



<h5 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符==="></a>严格相等运算符===</h5><ul>
<li>值类型不同，则不相等</li>
<li>两个值都是NULL或者都是undefined，则他们不相等</li>
<li>NaN和任何值都是不相等的，包括他的本身<ul>
<li>通过x!==x来判断x是否为NaN,只有在x是NaN的时候，这个表达式的值才是true</li>
</ul>
</li>
<li>一个值为0，另一个值为-0，则它们同样相等</li>
<li>如果两个值为字符串，且所含的对应位上的16位数相等，则它们相等</li>
<li>如果两个引用直指向不同的对象 ，这两个引用是不相等的</li>
</ul>
<h5 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符=="></a>相等运算符==</h5><ul>
<li>开两个操作数的类型相同，和上文所述的===比较规则一样</li>
<li>两个操作数类型不同，那么将这样转换<ul>
<li>一个是NULL，一个是undefined，则它们相等</li>
<li>数字与字符串相等比较，将字符串转换为数字，然后比较</li>
<li>true ，转换为1，false转换为0</li>
<li>对象与数字或者字符串比较，使用转换规则将对象转换为原始值，然后再进行比较</li>
<li>其他不同类型之间的比较均不相等</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true &#x3D;&#x3D; 1; &#x2F;&#x2F;true;</span><br><span class="line">true &#x3D;&#x3D;&#x3D; 1; &#x2F;&#x2F;false;</span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN; &#x2F;&#x2F;false</span><br><span class="line">isNaN(NaN);	&#x2F;&#x2F;true;</span><br><span class="line">1&#x3D;&#x3D;&quot;1&quot;;&#x2F;&#x2F;true</span><br><span class="line">1&#x3D;&#x3D;&#x3D;&quot;1&quot;&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



<h4 id="4-9-2-比较运算符"><a href="#4-9-2-比较运算符" class="headerlink" title="4.9.2 比较运算符"></a>4.9.2 比较运算符</h4><ul>
<li><p>小于&lt;</p>
</li>
<li><p>大于&gt;</p>
</li>
<li><p>小于等于&lt;=</p>
</li>
<li><p>大于等于&gt;=</p>
</li>
</ul>
<p><strong>比较运算符的操作数可能是任意类型。然而只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换</strong></p>
<ul>
<li>非数字和字符串的操作数的类型转换规则：<ul>
<li>如果操作数为对象，那么这个对象先转换为原始值</li>
<li>两个字符串，将依照字母表的顺序比较<ul>
<li>这里提到的“字母表顺序”指的是这个字符串的16位unicode字符的索引顺序</li>
</ul>
</li>
<li>如果至少有一个操作数不是字符串，那么这两个操作数都将转换为数字进行比较<ul>
<li>0于-0相等</li>
<li>Infinity 大于任何数字（除其本身）</li>
<li>-infinity小鱼人和数字（除其本身）</li>
</ul>
</li>
<li>若一种一个是（或者转换后）位NaN，返回false</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，数字和字符串比较是，更偏爱转换为数字</span></span><br><span class="line"><span class="comment">//只有在两个都是字符串时，才进行字符串的比较</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>+<span class="number">2</span>			<span class="comment">//加法，结果是3</span></span><br><span class="line"><span class="string">"1"</span>+<span class="string">"2"</span>		<span class="comment">//字符串连接，结果是”12“</span></span><br><span class="line"><span class="string">"1"</span>+<span class="number">2</span>		<span class="comment">//字符串连接，2转换为“2”，结果是“12”</span></span><br><span class="line"><span class="number">11</span>&lt;<span class="number">3</span>		<span class="comment">//数字比较false</span></span><br><span class="line"><span class="string">"11"</span>&lt;<span class="number">3</span>		<span class="comment">//字符串比较true</span></span><br><span class="line"><span class="string">"11"</span>&lt;<span class="number">3</span>		<span class="comment">//字符串比较，结果为 true</span></span><br><span class="line"><span class="string">"one"</span>&lt;<span class="number">3</span>		<span class="comment">//数字的比较，“one”转换为NaN,return false</span></span><br></pre></td></tr></table></figure>

<h4 id="4-9-3-in运算符"><a href="#4-9-3-in运算符" class="headerlink" title="4.9.3 in运算符"></a>4.9.3 in运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;;	<span class="comment">//定义一个对象</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> point 			<span class="comment">//true 有一个x属性</span></span><br><span class="line"><span class="string">"z"</span> <span class="keyword">in</span> poing			<span class="comment">//false对象中不存在名为x的属性</span></span><br><span class="line"><span class="string">"toString"</span> <span class="keyword">in</span> point		<span class="comment">//true对象继承了toString()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组里的属性名其实就是他的index下标</span></span><br><span class="line"><span class="keyword">var</span> data =[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];		<span class="comment">//一个数组</span></span><br><span class="line"><span class="string">"0"</span> <span class="keyword">in</span> data				<span class="comment">//true: 数组包含元素“0”</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> data				<span class="comment">//true: 数字转换为字符串</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> data				<span class="comment">//false：没有索引为3的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>至此，我们知道in运算符其实是判断一个对象（右值）中是否一个属性（左值）</li>
</ul>
<h4 id="4-9-4-instanceof-运算符"><a href="#4-9-4-instanceof-运算符" class="headerlink" title="4.9.4 instanceof 运算符"></a>4.9.4 instanceof 运算符</h4><ul>
<li>instanceof 运算符 左边是对象，右边是表示对象的 类</li>
<li>如果左侧的对象是右侧类的实例，则表达式返回true，否则为false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d  = <span class="keyword">new</span> date();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span>;		<span class="comment">//true d 是date()创建的</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>;	<span class="comment">//true 所有对象都是Object实例</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Number</span>;	<span class="comment">//false d不是一个Number对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>;		<span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>;	<span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>;	<span class="comment">//false 不是正则表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="4-10-逻辑表达式"><a href="#4-10-逻辑表达式" class="headerlink" title="4.10 逻辑表达式"></a>4.10 逻辑表达式</h3><h4 id="4-10-1-amp-amp"><a href="#4-10-1-amp-amp" class="headerlink" title="4.10.1 &amp;&amp;"></a>4.10.1 &amp;&amp;</h4><ul>
<li>三层理解<ul>
<li>当操作数都是布尔值的时候，&amp;&amp;对两个值执行布尔操作</li>
<li>&amp;&amp; 可以对真值和假值进行布尔操作，都是真值返回一个真值，否则返回假值</li>
<li>先计算左操作数的值，如果是假值，那么整个表达式的结果一定是假值，这时简单的返回佐操作是的值，不会去计算右操作数，繁殖，则运行右操作数</li>
</ul>
</li>
</ul>
<h4 id="4-10-2"><a href="#4-10-2" class="headerlink" title="4.10.2 ||"></a>4.10.2 ||</h4><ul>
<li>不讲了</li>
</ul>
<h4 id="4-10-3"><a href="#4-10-3" class="headerlink" title="4.10.3 !"></a>4.10.3 !</h4><ul>
<li>不讲了</li>
</ul>
<h3 id="4-11-赋值表达式"><a href="#4-11-赋值表达式" class="headerlink" title="4.11 赋值表达式"></a>4.11 赋值表达式</h3><ul>
<li>不讲了</li>
</ul>
<h3 id="4-12-表达式计算"><a href="#4-12-表达式计算" class="headerlink" title="4.12 表达式计算"></a>4.12 表达式计算</h3><ul>
<li>eval()</li>
<li>动态运行源代码中的字符串是一种强大的语言特性</li>
<li>在爬虫项目中会用到、</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> (<span class="string">"console.log('Hello world!')"</span>)<span class="comment">// 就是Hello world!  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;</span><br><span class="line"><span class="keyword">var</span> keywords_format = <span class="string">" $('meta[name=\"keywords\"]').eq(0).attr(\"content\")"</span>;</span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('title').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> date_format = <span class="string">"$('#pubtime_baidu').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author_format = <span class="string">"$('#editor_baidu').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format = <span class="string">"$('.left_zw').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> desc_format = <span class="string">" $('meta[name=\"description\"]').eq(0).attr(\"content\")"</span>;</span><br><span class="line"><span class="keyword">var</span> source_format = <span class="string">"$('#source_baidu').text()"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (author_format == <span class="string">""</span>) fetch.author = source_name; <span class="comment">//eval(author_format);  //作者</span></span><br><span class="line"><span class="keyword">else</span> fetch.author = <span class="built_in">eval</span>(author_format);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (content_format == <span class="string">""</span>) fetch.content = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">else</span> fetch.content = <span class="built_in">eval</span>(content_format).replace(<span class="string">"\r\n"</span> + fetch.author, <span class="string">""</span>); <span class="comment">//内容,是否要去掉作者信息自行决定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (source_format == <span class="string">""</span>) fetch.source = fetch.source_name;</span><br><span class="line"><span class="keyword">else</span> fetch.source = <span class="built_in">eval</span>(source_format).replace(<span class="string">"\r\n"</span>, <span class="string">""</span>); <span class="comment">//来源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (desc_format == <span class="string">""</span>) fetch.desc = fetch.title;</span><br><span class="line"><span class="keyword">else</span> fetch.desc = <span class="built_in">eval</span>(desc_format).replace(<span class="string">"\r\n"</span>, <span class="string">""</span>); <span class="comment">//摘要</span></span><br></pre></td></tr></table></figure>

<h3 id="4-13其他运算符"><a href="#4-13其他运算符" class="headerlink" title="4.13其他运算符"></a>4.13其他运算符</h3><h4 id="条件运算符，不讲"><a href="#条件运算符，不讲" class="headerlink" title="条件运算符，不讲"></a>条件运算符，不讲</h4><h4 id="typeof-运算符，不讲"><a href="#typeof-运算符，不讲" class="headerlink" title="typeof 运算符，不讲"></a>typeof 运算符，不讲</h4><h4 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h4><pre><code>+ 一元操作符
+ 用来删除对象属性或者数组元素</code></pre><h4 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h4><ul>
<li>一元运算符，出现在操作数前，操作数可以是任意类型</li>
<li>作用：操作数会照常计算，但虎落计算结果并返回undefined</li>
<li>用处<ul>
<li>在操作数具有副作用的时候使用void 来让程序更具有语义</li>
<li>这个运算符最常用在客户端的URL – javascript:URL中，在URL中可以写带有副作用的表达式，但是void则让浏览器不必显示这个表达式的计算结果</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a href = <span class="string">"javascript:void window.open();"</span> &gt;打开一个新窗口&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="await-运算符，看不懂，暂时不讲"><a href="#await-运算符，看不懂，暂时不讲" class="headerlink" title="await 运算符，看不懂，暂时不讲"></a>await 运算符，看不懂，暂时不讲</h4><h4 id="逗号运算符-，"><a href="#逗号运算符-，" class="headerlink" title="逗号运算符 ，"></a>逗号运算符 ，</h4><ul>
<li>二元运算符，他的操作数可以实任意类型</li>
<li>首先计算左操作数，然后计算右操作数，最后返回右操作数的值</li>
<li>最常用在for循环中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for循环中的第一个逗号是var语句的一部分</span></span><br><span class="line"><span class="comment">//第二个逗号是逗号运算符</span></span><br><span class="line"><span class="comment">//他将两个表达式（i++,j--）放在一条（for循环中的）语句中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>,j = <span class="number">10</span>;i&lt;j;i++,j--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i+j);<span class="comment">//返回10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-9类和模块</title>
    <url>/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="JavaScript-9类和模块"><a href="#JavaScript-9类和模块" class="headerlink" title="JavaScript-9类和模块"></a>JavaScript-9类和模块</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><ul>
<li>通过定义对象的类，让每个对象都共享某些属性</li>
<li>类的属性，用以存放或定义状态，或行为</li>
<li>9.4 类的一个重要特性是“动态可继承”</li>
<li>9.5 检测对象的类的方式，“鸭式辩型”</li>
<li>9.6 实现类的方法</li>
<li>9.7 类的继承</li>
<li>9.8 ECMAScript 2015 中的类</li>
<li>模块</li>
</ul>
<h3 id="9-1类和原型"><a href="#9-1类和原型" class="headerlink" title="9.1类和原型"></a>9.1类和原型</h3><ul>
<li>在JS中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。通常，类的实例还需要进一步的初始化，通常通过定义一个函数来创建并初始化这个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">from,to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">Object</span>.create(range.methods);</span><br><span class="line">    r.from = <span class="keyword">from</span>;</span><br><span class="line">    r.to = to;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">range.methods = &#123;</span><br><span class="line">    <span class="comment">//在不在这个range当中</span></span><br><span class="line">    includes: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from&lt;=x &amp;&amp;x&lt;=<span class="keyword">this</span>.to;&#125;,</span><br><span class="line"></span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from);x&lt;=<span class="keyword">this</span>.to;x++) f(x);&#125;,</span><br><span class="line">    <span class="comment">//range起点到终点</span></span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+ <span class="keyword">this</span>.from+<span class="string">"..."</span>+<span class="keyword">this</span>.to+<span class="string">")"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> r=range(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">r.includes(<span class="number">2</span>);      <span class="comment">//true</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log);<span class="comment">//1,2</span></span><br><span class="line"><span class="built_in">console</span>.log(r);     <span class="comment">//from:1 to:3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>工厂函数方法，没有定义构造函数。</li>
<li>使用关键词new 来调用构造函数，使用new调用构造函数会自动创建一个新对象。因此构造函数本身只需要初始化这个新对象的状态即可</li>
<li>调用构造函数的一个重要特征是，构造函数的protype属性被用作新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此他们都是同一个类的成员</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个构造函数，用以初始化新创建的“范围对象</span></span><br><span class="line"><span class="comment">//注意，这里没有创造一个对象，而是初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from,to</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有的范围对象都继承自这个对象</span></span><br><span class="line">    <span class="comment">//注意，属性的名字必须是prototype</span></span><br><span class="line">    Range.prototype = &#123;</span><br><span class="line">        <span class="comment">//在不在这个range当中</span></span><br><span class="line">        includes: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from&lt;=x &amp;&amp;x&lt;=<span class="keyword">this</span>.to;&#125;,</span><br><span class="line"></span><br><span class="line">        foreach: <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from);x&lt;=<span class="keyword">this</span>.to;x++) f(x);&#125;,</span><br><span class="line">        <span class="comment">//range起点到终点</span></span><br><span class="line">        toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+ <span class="keyword">this</span>.from+<span class="string">"..."</span>+<span class="keyword">this</span>.to+<span class="string">")"</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//这是后一定要+new 关键词，是从range里出来的一个实例</span></span><br><span class="line">    <span class="keyword">var</span> r =<span class="keyword">new</span> Range(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log( r.includes(<span class="number">2</span>));</span><br><span class="line">    r.foreach(<span class="built_in">console</span>.log(r));</span><br></pre></td></tr></table></figure>

<ul>
<li>工厂函数range()转化为构造函数时被重命名为Range()</li>
<li>Range()构造函数通过new 关键词调用，而range()工厂函数则不必使用new</li>
<li>在第一段实例代码中的原型为range.methods,过于随意。在第二段示例代码中的原型时Range.prototype，这是一个强制的命名。对Range()构造函数的调用会自动使用</li>
<li>Range.prototype作为新Range对象的原型</li>
</ul>
<h3 id="9-2类和构造函数"><a href="#9-2类和构造函数" class="headerlink" title="9.2类和构造函数"></a>9.2类和构造函数</h3><h4 id="构造函数和类的标识"><a href="#构造函数和类的标识" class="headerlink" title="构造函数和类的标识"></a>构造函数和类的标识</h4><ul>
<li><p>原型对象时类的唯一标识：当且仅当两个对象继承自同一个原型对象时，他们才是属于同一类的额实例</p>
</li>
<li><p>构造函数时类的”外在表现，构造函数的名字通常用作类名</p>
<ul>
<li><p>使用instanceof运算符来检测对象是否属于某个类</p>
</li>
<li><pre><code class="javascript">r <span class="keyword">instanceof</span> Range     <span class="comment">//    如果r继承自Range.prototype 返回true</span>
&lt;!--￼<span class="number">2</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p>例子</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Range.prototype = &#123;</span><br><span class="line"><span class="comment">//原来创建的这个重写了prototype，所以没有constructor的值</span></span><br><span class="line">    <span class="keyword">constructor</span>：Range,//显示设置构造函数反向引用</span><br><span class="line">    includes: function (x) &#123; <span class="keyword">return</span> <span class="keyword">this</span>.from&lt;=x &amp;&amp;x&lt;=<span class="keyword">this</span>.to;&#125;,</span><br><span class="line">    foreach: <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from);x&lt;=<span class="keyword">this</span>.to;x++) f(x);&#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"("</span>+ <span class="keyword">this</span>.from+<span class="string">"..."</span>+<span class="keyword">this</span>.to+<span class="string">")"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>尽量不用constructor属性</li>
</ul>
<h3 id="9-3Javascript中Java-式的类继承"><a href="#9-3Javascript中Java-式的类继承" class="headerlink" title="9.3Javascript中Java 式的类继承"></a>9.3Javascript中Java 式的类继承</h3><ul>
<li>用JavaScript模拟出Java中的四种类成员类</li>
<li>四种类型成员<ul>
<li>实例字段<ul>
<li>他们是基于实例的属性或者变量，用以保存独立对象的状态</li>
</ul>
</li>
<li>实例方法<ul>
<li>他们是类的所有实例所共享的方法，由每个独立的实例调用</li>
</ul>
</li>
<li>类字段<ul>
<li>这些属性或者变量是属于类的，而不是属于类的某个实例的</li>
</ul>
</li>
<li>类方法<ul>
<li>这些方法是属于类的，而不是属于某个实例的</li>
</ul>
</li>
</ul>
</li>
<li>Js和Java 的不同之处</li>
<li>Js的函数时以值得形式出现的，方法和字段没有太大的区别，如果属性值时函数，那么这个属性就定义了一个方法，否则仅仅时一个普通的属性或者字段，js中由三种不同的对象，如下所示</li>
<li>Javascript中类得三种不同的对象<ul>
<li>构造函数对象<ul>
<li>构造函数为JavaScript得类定义了名字。任何添加到这个构造函数对象中的属性都时类字段和类方法</li>
</ul>
</li>
<li>原型对象<ul>
<li>原型对象的属性被类得所有实例所继承’</li>
</ul>
</li>
<li>实例对象<ul>
<li>类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的</li>
</ul>
</li>
</ul>
</li>
<li>Javascript中定义类<ul>
<li>第一步，先定义一个构造函数，并设置初始化新对象的实例属性</li>
<li>第二部，给构造函数的prototype对象定义实例的方法</li>
<li>第三步，给构造函数定义类字段和类属性<h5 id="Step1-先定义一个构造函数，并设置初始化新对象的实例属性"><a href="#Step1-先定义一个构造函数，并设置初始化新对象的实例属性" class="headerlink" title="Step1 先定义一个构造函数，并设置初始化新对象的实例属性"></a>Step1 先定义一个构造函数，并设置初始化新对象的实例属性</h5></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个构造函数为它所创建的每个实例定义了实例字段r和i</span></span><br><span class="line"><span class="comment">	这两个字段分别保存附属的实部和虚部</span></span><br><span class="line"><span class="comment">	它们是对象的状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Complex</span>(<span class="params">real,imaginary</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">isNaN</span>(real)||<span class="built_in">isNaN</span>(imaginary))</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">	<span class="keyword">this</span>.r = real;</span><br><span class="line">    <span class="keyword">this</span>.i = imaginary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-2给构造函数的prototype对象定义实例的方法"><a href="#Step-2给构造函数的prototype对象定义实例的方法" class="headerlink" title="Step 2给构造函数的prototype对象定义实例的方法"></a>Step 2给构造函数的prototype对象定义实例的方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前复数对象加上另外一个复数，并返回一个新的计算和值后的附属对象</span></span><br><span class="line">Complex.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Complex (<span class="keyword">this</span>.r+that.r,<span class="keyword">this</span>.i+that.i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//负数的求负运算</span></span><br><span class="line">Complex.prototyle.neg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> complex (-<span class="keyword">this</span>.r,-<span class="keyword">this</span>.i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将复数对象转换为一个字符串</span></span><br><span class="line">Complex.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"&#123;"</span>+<span class="keyword">this</span>.r +<span class="string">","</span>+<span class="keyword">this</span>.i+<span class="string">"&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step3-给构造函数定义类字段和类属性"><a href="#Step3-给构造函数定义类字段和类属性" class="headerlink" title="Step3 给构造函数定义类字段和类属性"></a>Step3 给构造函数定义类字段和类属性</h5><img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/2.png" class>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Complex(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Complex(c.i,c.r);</span><br><span class="line">c.add(d).toString();	<span class="comment">//"&#123;5,5&#125;"使用了实例的方法</span></span><br><span class="line"><span class="comment">//这个稍微复杂的表达式用到了类方法和类字段</span></span><br><span class="line"><span class="comment">//complex表示一个类，先&#123;2，3&#125;，再定义一个加上&#123;-2，-3&#125;</span></span><br><span class="line">Complex.prase(c.toString()),add(c.neg()).equals(Complex.ZERO)<span class="comment">//结果永远是0</span></span><br></pre></td></tr></table></figure>

<h3 id="9-4类的扩充"><a href="#9-4类的扩充" class="headerlink" title="9.4类的扩充"></a>9.4类的扩充</h3><ul>
<li>具体可通过给原型对象添加新方法来扩充Javascript类</li>
</ul>
<img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/3.png" class>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printf</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;;</span><br><span class="line">n=<span class="number">3</span>;</span><br><span class="line">n.times(printf,<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/4.png" class>

<img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/5.png" class>

<h3 id="9-5类和类型"><a href="#9-5类和类型" class="headerlink" title="9.5类和类型"></a>9.5类和类型</h3><ul>
<li>三种用以检测任意对象的类的技术<ul>
<li>instanceof运算符</li>
<li>constructor属性</li>
<li>构造函数的名字</li>
</ul>
</li>
<li>鸭式辩型<ul>
<li>更关注对象可以完成什么工作（它包含什么方法）而不是对象属于哪个类</li>
</ul>
</li>
</ul>
<h5 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h5><ul>
<li><p>左操作数是待检测类的对象，有操作时是定义类的构造函数</p>
</li>
<li><p>如果o继承自c.prototype 则表达式o instanceof c的值为true。这里的继承可以不是直接继承</p>
</li>
<li><p>构造函数是类的公共标识，但原型是唯一的标识</p>
<ul>
<li>尽管instanceof运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数</li>
</ul>
</li>
<li><p>检测对象的原型链上是否有存在某特定的原型对象，而不用构造函数做中介的方法：isPrototypeOf() </p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">range.methods.isPrototypeOf(r);<span class="comment">//range.method是原型对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>instanceOf()和isPrototypeOf()方法的缺点<ul>
<li>无法通过对象获得类名，只能检测对象是否属于指定的类名</li>
<li>客户端Javascript中，多窗口和多框架子页面的web应用中兼容性不佳，每个窗口和框架的子页面都具有单独的执行上下文，每个上下文都包含独有的全局变量和一组构造函数</li>
</ul>
</li>
</ul>
<h5 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeAndValue</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x===<span class="literal">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">switch</span>(x.constructor)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="built_in">Number</span>: <span class="keyword">return</span> <span class="string">"Number: "</span>+x;</span><br><span class="line">		cise <span class="built_in">String</span>: <span class="keyword">return</span> <span class="string">"String：'"</span>+x+<span class="string">"'"</span>;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不足之处<ul>
<li>再多个执行上下文的场景中无法正常工作（比如再浏览器窗口的多个框架子页面中）</li>
<li>并非所有的对象都包含constructor属性。我们常常会忽略原型上的constructor属性。比如本章前面的示例代码中所定义的两个类，它们的实例都没有constructor属性</li>
</ul>
</li>
</ul>
<h5 id="构造函数的名称"><a href="#构造函数的名称" class="headerlink" title="构造函数的名称"></a>构造函数的名称</h5><ul>
<li><p>使用instanceof元素安抚和constructor属性检测对象所属的类的主要的问题：</p>
<ul>
<li>多个执行上下文中的函数看起来是一摸一样的，但是他们是相互独立的对象，因此彼此不相等</li>
</ul>
</li>
<li><p>一种可能的解决方案，使用构造函数的名字而不是构造函数本身作为类标识符</p>
<ul>
<li>一些JS实现中，函数对象由非标准的属性name，用来标识函数的名称</li>
<li>对没有name属性的Javascript实现，可将函数转换为字符串然后从中提取出函数名</li>
</ul>
</li>
<li><img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/6.png" class></li>
<li><img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/7.png" class>
</li>
<li><p>缺点： </p>
<ul>
<li>并不是所有的对象都具有constructor属性。此外并不是所有的函数都有名字。如果使用不带名字的函数定义表达式定义一个构造函数，getName(）方法则会返回空字符串：</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个构造函数没有名字</span></span><br><span class="line"><span class="keyword">var</span> Complex = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">this</span>.r = x,<span class="keyword">this</span>.i = y;&#125;</span><br><span class="line"><span class="comment">//这个构造函数有名字</span></span><br><span class="line"><span class="keyword">var</span> Range = <span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">f,t</span>)</span>&#123;<span class="keyword">this</span>.from = f;<span class="keyword">this</span>.to = t;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="鸭式辩型"><a href="#鸭式辩型" class="headerlink" title="鸭式辩型"></a>鸭式辩型</h4><ul>
<li>不关注“对象的类是什么”关注“对象能做什么”<ul>
<li>上文所描述的检测对象的类的各种技术多少都会有些问题，至少在客户端Javascript中式如此。解决办法就是规避掉这些问题：不要关注“对象的类是什么”，而是关注“对象能做什么”。因此提出鸭式辩型</li>
</ul>
</li>
<li>像鸭子一样走路，有用并且嘎嘎叫的鸟就是鸭子<ul>
<li>哪怕并不是从鸭子类的原型对象继承而来，但认为这个对象是鸭子</li>
</ul>
</li>
</ul>
<img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/8.png" class>

<h3 id="9-6-JavaScript面向对象的技术（略去）"><a href="#9-6-JavaScript面向对象的技术（略去）" class="headerlink" title="9.6 JavaScript面向对象的技术（略去）"></a>9.6 JavaScript面向对象的技术（略去）</h3><h3 id="9-7子类"><a href="#9-7子类" class="headerlink" title="9.7子类"></a>9.7子类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>在JavaScript中创建子类的关键之处在于，采用合适的方法对原型对象进行初始化</p>
</li>
<li><p>如果类B继承自类A,B.prototype 必须是 A.prototype的后嗣。B的实例继承自B.prototype，后者同样继承自A.prototype</p>
</li>
<li><p>例子</p>
</li>
</ul>
<h5 id="step1-定义Teacher（）构造函数"><a href="#step1-定义Teacher（）构造函数" class="headerlink" title="step1 定义Teacher（）构造函数"></a>step1 定义Teacher（）构造函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//teacher类继承自Person类</span></span><br><span class="line"><span class="comment">//首先Person类定义如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first,last,age,gender,interests</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = &#123;</span><br><span class="line">        first,</span><br><span class="line">        last</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    <span class="keyword">this</span>.interests = interests;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不要重新定义一边属性，否则就不是从Person（）中继承的</span></span><br><span class="line"><span class="comment">//会需要更多的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">first,last,age,gender,interests,subject</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,first,last,age,gender,interests,subject);</span><br><span class="line">    <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="step-2-设置Teacher-的原型和构造器引用"><a href="#step-2-设置Teacher-的原型和构造器引用" class="headerlink" title="step 2 设置Teacher()的原型和构造器引用"></a>step 2 设置Teacher()的原型和构造器引用</h5><ul>
<li>Teacher.prototype=Object.create(Person.prototype)</li>
<li>create()在这个例子里，创建一个和Person.prototype 一样的新的原型属性值，这个属性指向一个包括属性和方法的对象，然后将它作为Teacher.prototype 的属性值，这意味着Teacher.prototype现在会继承Person.prototype的所有属性和方法</li>
<li>现在Teacher()的prototype的constructor属性指向的是Person()，所以我们需要将其 正确设置</li>
<li>Teacher.prototype.constructor = Teacher;</li>
</ul>
<h5 id="step3-尝试向Teacher-添加新的greeeting-函数"><a href="#step3-尝试向Teacher-添加新的greeeting-函数" class="headerlink" title="step3 尝试向Teacher()添加新的greeeting()函数"></a>step3 尝试向Teacher()添加新的greeeting()函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Teacher.prototype.greeting = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prefix;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.gender===<span class="string">'male'</span>||<span class="keyword">this</span>.gender===<span class="string">'Male'</span>||<span class="keyword">this</span>.gender===<span class="string">'M'</span>||<span class="keyword">this</span>.gender===<span class="string">'m'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix = <span class="string">'Mr.'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.gender === <span class="string">'female'</span>||<span class="keyword">this</span>.gender ===<span class="string">'Female'</span>||<span class="keyword">this</span>.gender ===<span class="string">'f'</span>||<span class="keyword">this</span>.gender ===<span class="string">'F'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix = <span class="string">'Mrs.'</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        prefix = <span class="string">'Mx.'</span></span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'Hello ,my name is '</span>+ prefix+<span class="string">''</span>+<span class="keyword">this</span>.name.last +<span class="string">',and I teache '</span>+ <span class="keyword">this</span>.subject+<span class="string">'.'</span>)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="step4创建一个Teacher-的实例"><a href="#step4创建一个Teacher-的实例" class="headerlink" title="step4创建一个Teacher()的实例"></a>step4创建一个Teacher()的实例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> teacher1 = <span class="keyword">new</span> Teacher(<span class="string">'Dave'</span>,<span class="string">'Griffiths'</span>,<span class="number">31</span>,<span class="string">'male'</span>,[<span class="string">'football'</span>,<span class="string">'cookery'</span>],<span class="string">'mathematics'</span>);</span><br><span class="line">teacher1.name,first;</span><br><span class="line">teacher1.interests[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">teacher1.subject;</span><br><span class="line">teacher1.greeting();</span><br></pre></td></tr></table></figure>

<ul>
<li>前面两个进入到Person()的构造器，继承的属性和方法</li>
<li>后面两个则是只有Teacher()的构造器才有的属性和方法</li>
</ul>
<h3 id="9-8-ES6中的类"><a href="#9-8-ES6中的类" class="headerlink" title="9.8 ES6中的类"></a>9.8 ES6中的类</h3><h4 id="定义类-类声明"><a href="#定义类-类声明" class="headerlink" title="定义类-类声明"></a>定义类-类声明</h4><ul>
<li>使用戴悠class关键词的类名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(height,width) &#123;</span><br><span class="line">         <span class="keyword">this</span>.height = height;</span><br><span class="line">         <span class="keyword">this</span>.width = width;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：函数声明和类声明之间的一个重要区别是函数声明会提升，但是类不会</li>
</ul>
<h4 id="定义类类表达式"><a href="#定义类类表达式" class="headerlink" title="定义类类表达式"></a>定义类类表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名类</span></span><br><span class="line">    <span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(height,width) &#123;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">            <span class="keyword">this</span>.width = width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(Rectangle.name)</span><br><span class="line">    <span class="comment">//输出实例名字，因为类是匿名的</span></span><br><span class="line">    <span class="comment">//具名类</span></span><br><span class="line">    <span class="keyword">let</span> Rectangle = <span class="class"><span class="keyword">class</span> <span class="title">Rectangle2</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(height,width) &#123;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">            <span class="keyword">this</span>.width = width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(Rectangle.name);</span><br><span class="line">    <span class="comment">//后面会把类具体的名字输出，不输出实例名</span></span><br></pre></td></tr></table></figure>

<h4 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h4><ul>
<li>一个类 的类体式{}中的部分。这是定义类成员的位置，如方法或者构造函数</li>
<li>严格模式<ul>
<li>类声明和类表达式的主题都执行在严格模式下，比如，构造函数，静态方法，原型方法，getter和setter都在严格模式下执行</li>
</ul>
</li>
<li>构造函数<ul>
<li>一个类只能拥有一个名为constructor的特殊方法。这个constructor方法是一个特殊的方法，这个方法用于创建和初始化一个由 class 创建的对象。一个构造函数可以使super关键词来调用一个父类的构造函数‘</li>
</ul>
</li>
</ul>
<h5 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(height,width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> area()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    calcArea()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height*<span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Rectangle(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.area)<span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(x,y) &#123;</span><br><span class="line">           <span class="keyword">this</span>.x = x;</span><br><span class="line">           <span class="keyword">this</span>.y = y;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">static</span> distance (a,b)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">const</span> dx = a.x-b.x;</span><br><span class="line">           <span class="keyword">const</span> dy = a.y-b.y;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(dx,dy);<span class="comment">//返回所有参数的平方和的平方根</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>,<span class="number">5</span>);<span class="comment">//两个实例</span></span><br><span class="line">   <span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(Point.distance(p1,p2));</span><br><span class="line"><span class="comment">//静态方法直接写类名+方法，再传入参数</span></span><br></pre></td></tr></table></figure>

<h5 id="用原型和静态方法包装"><a href="#用原型和静态方法包装" class="headerlink" title="用原型和静态方法包装"></a>用原型和静态方法包装</h5><ul>
<li><p>当一个对象调用静态或者原型方法时，如果该对象没有this值，那么this值再被调用的函数内部就是undefined，不会发生自动包装</p>
</li>
<li><pre><code class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>{
      speak() {
          <span class="keyword">return</span> <span class="keyword">this</span>;
      }
      <span class="keyword">static</span> eat(){
<span class="comment">//这是对类来说的，不是对实例来说的，所以这样定义，this必为undefined</span>
          <span class="keyword">return</span> <span class="keyword">this</span>;
      }
  }
  <span class="keyword">let</span> obj = <span class="keyword">new</span> Animal();
  obj.speak();<span class="comment">// 这是一个Animal实例，有this对象，返回Animal{}</span>
  <span class="keyword">let</span> speak = obj.speak();
  speak();<span class="comment">//undefined，找不到this的值</span>

  Animal.eat();<span class="comment">//class Animal;</span>
  <span class="keyword">let</span> eat = Animal.eat();
  eat();<span class="comment">//用一个类来调用一个方法，肯定没有this</span>
&lt;!--￼<span class="number">18</span>--&gt;
</code></pre>
</li>
</ul>
<h5 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h5><ul>
<li>实例的属性必须定义在类的方法里</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(height,width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态的或者原型的数据属性，必须定义在类定义的外面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//他和实例就完全没关系了，任何一个实例，要用这个静态属性的时候必然都是20</span></span><br><span class="line"><span class="comment">//对每个实例都是一样的，而且实例不能修改这个属性</span></span><br><span class="line">Rectangle.staticWidth = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//对于每个实例来说都继承了一个原型，那么他也有这个原型的数据属性</span></span><br><span class="line"><span class="comment">//但是可以对这个prototypeWidth修改</span></span><br><span class="line">Rectangle.prototype.prototypeWidth = <span class="number">25</span></span><br></pre></td></tr></table></figure>

<h5 id="字段声明"><a href="#字段声明" class="headerlink" title="字段声明"></a>字段声明</h5><ul>
<li><p>共有字段声明</p>
<ul>
<li>通过预先声明字段，字段始终存在</li>
<li>这个字段可以用也可以不用默认值来声明</li>
</ul>
</li>
<li><p>私有字段声明</p>
<ul>
<li>只能在类里面读取或者写入</li>
<li>私有字段仅能在字段声明中预先定义</li>
<li>私有字段不能通过在之后赋值来创建他们，这种方式只适合普通属性</li>
</ul>
</li>
<li><p>共有例子</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">	height = <span class="number">0</span>;</span><br><span class="line">	width ;</span><br><span class="line"> <span class="keyword">constructor</span>(height,width) &#123;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">            <span class="keyword">this</span>.width = width;</span><br><span class="line">        &#125;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>私有例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">#	height = 0;</span><br><span class="line">#	width ;</span><br><span class="line"> <span class="keyword">constructor</span>(height,width) &#123;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">            <span class="keyword">this</span>.width = width;</span><br><span class="line">        &#125;	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在外面是看不到的</span></span><br></pre></td></tr></table></figure>

<h4 id="用extends创建子类"><a href="#用extends创建子类" class="headerlink" title="用extends创建子类"></a>用extends创建子类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    speak()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">' makes a noise.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//再原型方法的基础上修改speak()，打印....barks</span></span><br><span class="line">    speak() &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">' barks.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不对原型方法进行任何修改，打印...makes a noise</span></span><br><span class="line">    speak() &#123;</span><br><span class="line">        <span class="keyword">super</span>.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">'轲轲'</span>);</span><br><span class="line">d.speak();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果子类中存在构造函数，则需要再使用this之前首先调用super()</li>
<li>也可以继承传统的基于函数的类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal.prototype.speak= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">' makes a noise.'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//可以继承传统的基于函数的类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        speak() &#123;</span><br><span class="line">            <span class="comment">// super.speak();</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">' barks.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">'轲轲'</span>);</span><br><span class="line">    d.speak();</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的式，类不能继承常规对象。如果要继承常规对象，可以改成Object.setPrototypeOf();</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个简单的对象</span></span><br><span class="line"><span class="keyword">var</span> Animal = &#123;</span><br><span class="line">	speak()&#123;</span><br><span class="line">		 <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">' makes a noise.'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">	 <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示的指定Dog的prototype就是Animal</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Dog.prototype,Animal);</span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">'轲轲'</span>);</span><br><span class="line">    d.speak();</span><br></pre></td></tr></table></figure>

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li>任何javascript代码段就可以当作一个模块</li>
<li>模块化的目标<ul>
<li>支持大规模的程序开发，处理分散源中代码的组装，并且能够让代码正确运行</li>
<li>不同的模块必须避免修改全局执行上下文，因此后续模块应当在他们所期望运行的原始（或接近原始）上下文中执行</li>
</ul>
</li>
</ul>
<h4 id="用作命名空间的对象"><a href="#用作命名空间的对象" class="headerlink" title="用作命名空间的对象"></a>用作命名空间的对象</h4><ul>
<li>在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间</li>
<li>用命名空间来的导入模块（往往将整个模块导入全局命名空间，而不是导入命名空间中的某个单独的类）<ul>
<li>var sets = com.davidflanagan.collections.sets;</li>
</ul>
</li>
<li>按照约定，模块的文件名应当和命名空间匹配<ul>
<li><img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/9.png" class>

</li>
</ul>
</li>
</ul>
<h4 id="作为私有命名空间的函数"><a href="#作为私有命名空间的函数" class="headerlink" title="作为私有命名空间的函数"></a>作为私有命名空间的函数</h4><ul>
<li>模块对外导出一些公用API，这些API是提供给其他程序员使用的，它包括函数类属性和方法</li>
<li>例子：<img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/10.png" class></li>
<li>将模块函数当作构造函数使用，通过new来调用，通过将他们赋值来给this将其到处</li>
<li><img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/11.png" class>

</li>
</ul>
<h4 id="模块化的几个规范"><a href="#模块化的几个规范" class="headerlink" title="模块化的几个规范"></a>模块化的几个规范</h4><h5 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h5><ul>
<li>CommonJS的一个模块就是一个脚本文件，通过执行该文件来加载模块。CommonJS规范规定，每个模块内部，module变量代表当前模块，这个变量是一个对象，他的exports属性是对外的接口。加在某个模块其实是加载该模块的module.exports属性</li>
<li><img src="/2020/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/04/28/JavaScript-9%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%9D%97/12.png" class></li>
<li>优点：解决了依赖，全局变量污染的问题</li>
<li>缺点：CommonJS用同步的方式加载模块，在浏览器端，限于网络原因，CommonJS不适合浏览器端模块加载，更合理的是使用异步加载，比如AMD</li>
</ul>
<h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><ul>
<li><p>即异步模块定义</p>
</li>
<li><p>采用这个异步方式加载模块，模块的加载不影响后面语句的运行</p>
</li>
<li><p>所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行，除了和CommonJS同步加载方式不同之外，AMD在模块的定义与引用上也有所不同</p>
</li>
<li><p>在AMD标准中，定义了下面三个API</p>
<ul>
<li><p>require([module],callback)</p>
<ul>
<li>又是我们依旧通过require关键字，它包含两个参数，第一个数组为要加载的模块，第二个参数为回调函数</li>
</ul>
</li>
<li><p>define(id,[depends],callback)</p>
<ul>
<li>id:模块名称，或者模块加载器请求的指定脚本的名字</li>
<li>depends：是个定义模块所依赖的模块数组，默认为[“require”,”exports”,”module”]</li>
<li>callback:为模块初始化要执行的函数或对象。如果为函数，他应该只被执行一次。如果是对象，此对象应该为模块的输出值</li>
</ul>
</li>
<li><p>require.config()</p>
</li>
</ul>
</li>
<li><p>优点：适合在浏览器环境中异步加载模块，并行加载多个模块</p>
</li>
<li><p>不能按需加载</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-5语句</title>
    <url>/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="js第五章语句"><a href="#js第五章语句" class="headerlink" title="js第五章语句"></a>js第五章语句</h1><h3 id="5-2-复合语句和空语句"><a href="#5-2-复合语句和空语句" class="headerlink" title="5.2 复合语句和空语句"></a>5.2 复合语句和空语句</h3><h5 id="复合语句：用花括号将多条语句括起来，当一条语句使用"><a href="#复合语句：用花括号将多条语句括起来，当一条语句使用" class="headerlink" title="复合语句：用花括号将多条语句括起来，当一条语句使用"></a>复合语句：用花括号将多条语句括起来，当一条语句使用</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	x = Math.PI;</span><br><span class="line">	cx = Math.<span class="built_in">cos</span>(x);</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">"cos(Pi)= "</span> +cx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line">	<span class="number">1.</span> 语句块结尾不需要分号</span><br><span class="line">	<span class="number">2.</span> 语句块中的行都要有缩进，但非必需，增加可读性</span><br><span class="line">	<span class="number">3.</span> Js无块级作用域，语句块中声明的变量非语句块私有</span><br></pre></td></tr></table></figure>

<h5 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">创建一个具有空循环体的循环时，空语句有时候是很有用的</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;a.lenth;a[i++]=<span class="number">0</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((a==<span class="number">0</span>)||(b==<span class="number">0</span>));<span class="comment">//那么这时候空语句就不是帮忙的了，因为这句话什么也没做</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-声明语句"><a href="#5-3-声明语句" class="headerlink" title="5.3 声明语句"></a>5.3 声明语句</h3><ul>
<li>声明语句：这些语句定义标识符（变量名和函数名）并给其赋值</li>
</ul>
<h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> x = <span class="number">2.34</span>, y = <span class="built_in">Math</span>.cos(<span class="number">0.75</span>),r,theta; <span class="comment">//很多变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>, y = x*x;						  <span class="comment">//第二个变量使用了第一个变量</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>,								</span><br><span class="line">    f = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x&#125;,		  <span class="comment">//每个变量独占一行</span></span><br><span class="line">    y = f(x);</span><br></pre></td></tr></table></figure>

<ul>
<li>var语句出现在函数体内，定义的是全局变量，作用于是这个函数</li>
<li>在顶层代码中使用var语句，他声明的是全局变量，在整个javaScript程序中都是可见的</li>
<li>var声明的变量无法通过delete删除</li>
<li>若var的变量为指定初始化，则初始为undefined</li>
<li>变量声明语句会被提前至脚本或者函数的顶部。但是初始化的操作则还在原来的var语句的位置执行，在声明语之前变量的值是undefined</li>
<li>重复生命变量是合法的</li>
</ul>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><ul>
<li>声明局部变量</li>
<li>用法类似var ，但是所声明的变量，旨在let命令所在的代码块内有效，而且有暂时性死区的约束</li>
<li>let不允许在相同作用域内，重复声明同一个变量</li>
</ul>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul>
<li>与let类似，但不能重复赋值</li>
</ul>
<h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x+<span class="number">1</span>; &#125;	<span class="comment">//将表达式赋值给一个变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x+<span class="number">1</span>; &#125;		<span class="comment">//含有变量名的语句</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>定义函数时，不执行函数体内的语句，他和调用函数时待执行的新函数对象相关联</li>
<li>即使是函数体只包含一条语句，仍然要用花括号</li>
<li>函数声明语句通常出现在JavaScript代码的顶层，也可以出现在所嵌套函数的顶部。也就是说，函数定义不能出现在if语句、while循环或者其他任何语句中</li>
<li>函数声明、函数名称和函数体均提前：脚本中的所有函数和函数中所有嵌套的函数都会在当前上下文中其他代码之前声明</li>
<li>无法delete</li>
</ul>
</li>
</ul>
<h3 id="5-4条件语句"><a href="#5-4条件语句" class="headerlink" title="5.4条件语句"></a>5.4条件语句</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><ul>
<li>JavaScript 使用if(){…} else{ }</li>
<li>else 可选，若语句块中只含有一条语句，可以省略</li>
<li>如果还要更加细致的判断条件，可以使用多个if else 的组合</li>
</ul>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(n)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="comment">//bla</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">//执行代码</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li>如果没有default标签，switch语句将跳过它左右的代码块</li>
<li>case关键词跟随任意的表达式</li>
<li>可以使用return 来代替break</li>
<li>“default：”标签可以放置在switch的任何地方，但最常用出现在switch的末尾</li>
</ul>
</li>
</ul>
<h4 id="while-do-while-for-不讲了"><a href="#while-do-while-for-不讲了" class="headerlink" title="while /do while/for 不讲了"></a>while /do while/for 不讲了</h4><h4 id="for-in"><a href="#for-in" class="headerlink" title="for /in"></a>for /in</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span> object)</span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>

<ul>
<li>variable 是一个适用于赋值表达式左侧的值</li>
<li>object 是一个表达式，这个表达式的计算结果是一个对象</li>
<li>statement 是一个语句或者语句块，是这个循环的主体</li>
<li>以任意顺序遍历一个对象除了Symbol以外的可枚举属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name:<span class="string">'Rechel'</span>,</span><br><span class="line">    age:<span class="number">22</span>,</span><br><span class="line">    city:<span class="string">'Shanghai'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果就是： name , age, city</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">//'0','1','2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i])<span class="comment">//'a','b','c'</span></span><br><span class="line">    <span class="comment">//因为再数组中，他的index下标就是数组的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-of"><a href="#for-of" class="headerlink" title="for/of"></a>for/of</h4><ul>
<li>for…of 循环时ES6引入的额新的语法</li>
<li>语法（与for/in相同）<ul>
<li>for(variable of iterable{<ul>
<li>​    //statements</li>
</ul>
</li>
<li>}</li>
</ul>
</li>
<li>Variable： 在每次迭代中，将不同属性的值分配给变量</li>
<li>iterable：被迭代美剧其属性的对象</li>
<li>使用对象：for…of 语句在可迭代对象（包括：Array,Map,Set,String,TypedArray,arguments对象等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</li>
</ul>
<h6 id="for-of-for-in-的区别"><a href="#for-of-for-in-的区别" class="headerlink" title="for/of .for/in 的区别"></a>for/of .for/in 的区别</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> iterable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里为什么会出先这么多属性？</span></span><br><span class="line">    <span class="comment">//因为iterable是一个数组对象，它自身包含了0，1，2，"foo"这些属性</span></span><br><span class="line">    <span class="comment">//但是他同时也是Array对象，Object对象的一个实例，所以说会继承Object，Array的属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);<span class="comment">//0,1,2."foo","arrCustom","objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> iterable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//hasOwnProperty代表了这个对象的自身的属性，这时候继承的属性就不会出现</span></span><br><span class="line">    <span class="keyword">if</span>(iterable.hasOwnProperty(i))&#123;<span class="built_in">console</span>.log(i);<span class="comment">//0,1,2,"foo"&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> iterable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);<span class="comment">//3,5,7</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要区别在于他们的迭代方式</li>
<li>for…in 语句以任意顺序迭代对象的可枚举属性</li>
<li>for…of 显示的是数据</li>
</ul>
<h4 id="forEach循环（The-Best"><a href="#forEach循环（The-Best" class="headerlink" title="forEach循环（The Best)"></a>forEach循环（The Best)</h4><ul>
<li>for in 遍历的对象属性的名称</li>
<li>for of 遍历的是集合本身的元素</li>
<li>更好的方式是直接使用iterable内置的forEach方法，它接受一个函数，每次迭代自动回调该函数</li>
</ul>
<h5 id="在array中使用forEach"><a href="#在array中使用forEach" class="headerlink" title="在array中使用forEach"></a>在array中使用forEach</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//element:指向当前元素的值</span></span><br><span class="line">    <span class="comment">//index： 指向当前的索引</span></span><br><span class="line">    <span class="comment">//array ： 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element+<span class="string">', index ='</span>+ index);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="在set中使用forEach"><a href="#在set中使用forEach" class="headerlink" title="在set中使用forEach"></a>在set中使用forEach</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element,sameElement,set</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(element);</span><br><span class="line">	<span class="built_in">console</span>.log(sameElement);</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">-------------------</span><br><span class="line">B</span><br><span class="line">B</span><br><span class="line">—————————————————— </span><br><span class="line">C</span><br><span class="line">C</span><br><span class="line">-------------------</span><br><span class="line"><span class="comment">//Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身</span></span><br></pre></td></tr></table></figure>

<h5 id="forEach循环例子"><a href="#forEach循环例子" class="headerlink" title="forEach循环例子"></a>forEach循环例子</h5><ul>
<li>Map的回调函数参数依次为value，key和map本身</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="string">'x'</span>],[<span class="number">2</span>,<span class="string">'y'</span>],[<span class="number">3</span>,<span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,key,map</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);<span class="comment">//值</span></span><br><span class="line">	<span class="built_in">console</span>.log(key);<span class="comment">//索引</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">Map</span>);<span class="comment">//图本身</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">x</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="built_in">Function</span>: <span class="built_in">Map</span>]</span><br><span class="line">y</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="built_in">Function</span>: <span class="built_in">Map</span>]</span><br><span class="line">z</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="built_in">Function</span>: <span class="built_in">Map</span>]</span><br></pre></td></tr></table></figure>

<h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><ul>
<li>迭代器是通过使用next() 方法实现iterator protocol 的任何一个对象，该方法返回具有两个属性的对象<ul>
<li>value，这是序列中的next值</li>
<li>done，如果已经迭代到序列中的最后一个值，则它为true</li>
</ul>
</li>
</ul>
<h5 id="迭代器与生成器-1"><a href="#迭代器与生成器-1" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h5><pre><code>+ 生成器是一种返回迭代器的函数，通过function关键字后的星号*来表示，函数中会用到新的关键词yield
+ 星号可以紧挨者关键字function，也可以在中间添加一个空格</code></pre><p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A31.png" alt="示例"></p>
<ul>
<li>关键词yield 可以返回任何和表达式，通过生成器函数批量给迭代器添加元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myIterator</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;list.lenth;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">yield</span> list[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A32.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/%E8%BF%AD%E4%BB%A33.png" alt="示例"></p>
<h3 id="5-6跳转"><a href="#5-6跳转" class="headerlink" title="5.6跳转"></a>5.6跳转</h3><h4 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h4><ul>
<li>语句是可以添加标签的，科在程序的任何地方通过标签名引用这条语句<ul>
<li>identifier: statement</li>
<li>identifier 必须是一个合法的JS 标识符，而不能是一个保留字</li>
<li>可以使用统一标识符作为语句标签和变量名或者函数名</li>
<li>任何语句可以有很多个标签</li>
</ul>
</li>
<li>break和continue是JS中唯二可用语句标签的语句！</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mainloop:<span class="keyword">while</span>(token!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//忽略这里的代码</span></span><br><span class="line">        <span class="keyword">continue</span> mainloop;<span class="comment">//跳转到下一次循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>&amp;&amp;j==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">       iNum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(iNum);<span class="comment">//输出55</span></span><br><span class="line"></span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>&amp;&amp;j==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span> outermost;</span><br><span class="line">		<span class="comment">//跳到最外圈，开始跑，也就是说55-59这些数被吃掉了</span></span><br><span class="line">        &#125;</span><br><span class="line">       iNum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(iNum);<span class="comment">//输出95</span></span><br></pre></td></tr></table></figure>

<h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><h4 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h4><ul>
<li>return语句只能在函数体内出现</li>
<li>执行到return 语句的时候，函数终止执行，并返回expression的值给调用程序</li>
<li>如果没有return 语句，调用表达式的结果是undefined</li>
<li>JavaScript可以自动插入分号，return 关键字和她后面的表达式之间不能有换行</li>
</ul>
<h4 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h4><ul>
<li>在Javascript中，当产生运行时错误或者程序使用throw语句时就会显示地抛出异常</li>
<li>throw expression</li>
<li>expression的值可以实任意类型的<ul>
<li>代表错误码的数字</li>
<li>刻度的错误消息的字符串</li>
<li>Error类型和其子类型<ul>
<li>一个Error对象有一个name属性表示错误类型，一个message属性用来存放传递给构造函数的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/throw1.png" alt="示例"></p>
<ul>
<li>跳转-错误处理，错误处理时程序设计时必须要考虑的问题</li>
</ul>
<p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/throw2.png" alt="示例"></p>
<ul>
<li><p>有错误发生时，执行流程像这样</p>
<ul>
<li>先执行try{…}代码</li>
<li>执行到出错的语句时，后续语句不再继续执行，转而执行catch(e){…}代码</li>
<li>最后执行finally{…}代码</li>
</ul>
</li>
<li><p>没有错误发生时，执行流程像这样</p>
<ul>
<li>先执行try{…}代码</li>
<li>因为没有出错，catch(e){…}代码不会被执行</li>
<li>最后执行finally{…}代码</li>
</ul>
</li>
<li><p>最后请注意，catch和finally可以不必都出现</p>
</li>
<li><p>try，catch，finally 语句块都需要使用花括号，花括号是必须的</p>
</li>
<li><p>JavaScript 有一个标准的Error对象表示错误，在处理错误是，可以通过catch(e)捕获的变量e访问错误对象</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">		<span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>)&#123;</span><br><span class="line">			alert(<span class="string">'Typr error!'</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> <span class="built_in">Error</span>)&#123;</span><br><span class="line">			alert(e.message);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		alert(<span class="string">'Error: '</span>+e);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/throw3.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/throw4.png" alt="示例"></p>
<h3 id="5-7其他语句类型"><a href="#5-7其他语句类型" class="headerlink" title="5.7其他语句类型"></a>5.7其他语句类型</h3><h4 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h4><ul>
<li>use strict 是说明严格模式</li>
<li>只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前</li>
<li>为了避免缺陷建议所有的JS代码都应该使用严格模式<ul>
<li>最简单的就是在JS代码的第一行上写上：’use strict’;</li>
</ul>
</li>
<li>严格模式和非严格模式中的区别<ul>
<li>严格模式中所有的变量都要先声明</li>
<li>不能使用with语句</li>
<li>调用的函数（不是方法）中的一个this值时undefined，在非严格模式中调用的函数中的this值总是全局对象</li>
</ul>
</li>
</ul>
<h4 id="with语句，建议不要用"><a href="#with语句，建议不要用" class="headerlink" title="with语句，建议不要用"></a>with语句，建议不要用</h4><h4 id="debugger语句"><a href="#debugger语句" class="headerlink" title="debugger语句"></a>debugger语句</h4><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/%E5%B0%8F%E7%BB%93.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-5%E8%AF%AD%E5%8F%A5/%E5%B0%8F%E7%BB%932.png" alt="示例"></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-6对象</title>
    <url>/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="Javascript-6对象"><a href="#Javascript-6对象" class="headerlink" title="Javascript-6对象"></a>Javascript-6对象</h1><h3 id="6-1创建对象"><a href="#6-1创建对象" class="headerlink" title="6.1创建对象"></a>6.1创建对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如何获取该变量(对象)是不是属于什么类型的?</span></span><br><span class="line"><span class="comment">     * 语法:</span></span><br><span class="line"><span class="comment">     * 变量 instanceof 类型的名字-----&gt;布尔类型,true就是这种类型,false不是这种类型</span></span><br><span class="line"><span class="comment">     * 在当前的对象的方法中,可以使用this关键字代表当前的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//工厂模式创建对象</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//创建对象</span></span><br><span class="line">      <span class="comment">//添加属性</span></span><br><span class="line">      obj.name = name;</span><br><span class="line">      obj.age = age;</span><br><span class="line">      <span class="comment">//添加方法</span></span><br><span class="line">      obj.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"阿涅哈斯诶呦,我叫:"</span> + <span class="keyword">this</span>.name + <span class="string">"我今年:"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建人的对象</span></span><br><span class="line">    <span class="keyword">var</span> per1 = createObject(<span class="string">"小芳"</span>,<span class="number">20</span>);</span><br><span class="line">    per1.sayHi();</span><br><span class="line">    <span class="comment">//创建一个人的对象</span></span><br><span class="line">    <span class="keyword">var</span> per2 = createObject(<span class="string">"小红"</span>,<span class="number">30</span>);</span><br><span class="line">    per2.sayHi();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> per1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义构造函数创建对象,我要自己定义一个构造函数,自定义构造函数,创建对象</span></span><br><span class="line">    <span class="comment">//函数和构造函数的区别；名字是不是大写(首字母是大写)</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">      <span class="keyword">this</span>.age=age;</span><br><span class="line">      <span class="keyword">this</span>.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我叫:"</span>+<span class="keyword">this</span>.name+<span class="string">",年龄是:"</span>+<span class="keyword">this</span>.age);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义构造函数创建对象:先自定义一个构造函数,创建对象</span></span><br><span class="line">    <span class="keyword">var</span> obj=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name);</span><br><span class="line">    <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">    obj.sayHi();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj)</span><br><span class="line">    <span class="keyword">var</span> obj2=<span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(obj2.name);</span><br><span class="line">    <span class="built_in">console</span>.log(obj2.age);</span><br><span class="line">    obj2.sayHi();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Person);</span><br><span class="line">    <span class="built_in">console</span>.log(obj2 <span class="keyword">instanceof</span>  Person);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义狗的构造函数,创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">      <span class="keyword">this</span>.age=age;</span><br><span class="line">      <span class="keyword">this</span>.sex=sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dog=<span class="keyword">new</span> Dog(<span class="string">"大黄"</span>,<span class="number">20</span>,<span class="string">"男"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Person);<span class="comment">//false</span></span><br><span class="line">    <span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Dog);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">    obj.name=<span class="string">"小白"</span>;</span><br><span class="line">    obj.age=<span class="number">10</span>;</span><br><span class="line">    obj.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"我是:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.sayHi();</span><br><span class="line">    <span class="keyword">var</span> obj2=&#123;</span><br><span class="line">      name:<span class="string">"小明"</span>,</span><br><span class="line">      age:<span class="number">20</span>,</span><br><span class="line">      sayHi:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">      &#125;,</span><br><span class="line">      eat:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"吃了"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj2.sayHi();</span><br><span class="line">    obj2.eat();</span><br></pre></td></tr></table></figure>

<h3 id="6-2属性的查询和设置"><a href="#6-2属性的查询和设置" class="headerlink" title="6.2属性的查询和设置"></a>6.2属性的查询和设置</h3><ul>
<li>获取属性的值<ul>
<li>点                 可以是任何数据类型</li>
<li>方括号         只能返回字符串</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> author = book.author</span><br><span class="line"><span class="keyword">let</span> name = author.name</span><br><span class="line"><span class="keyword">let</span> title = book[<span class="string">"main titkle"</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>创建属性或者给属性赋值<ul>
<li>点 （.)</li>
<li>方括号</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">book.edition = <span class="number">9</span>;</span><br><span class="line">book[<span class="string">"main title"</span>] = <span class="string">"ECMAScript"</span></span><br></pre></td></tr></table></figure>

<h4 id="作为关联数组的对象"><a href="#作为关联数组的对象" class="headerlink" title="作为关联数组的对象"></a>作为关联数组的对象</h4><ul>
<li>关联数组：使用方括号和一个字符串，更像数组，只是这个数组元素是通过字符串索引而不是数字索引</li>
<li>通过[]来访问对象的属性时候，使得在运行程序的时候可以修改或者创建</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> addr = <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//就是把</span></span><br><span class="line">	addr+=customer[<span class="string">"address"</span>+i]+<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li>对象有一些属性是从原型对象继承而来</li>
<li>家是要查询对象o的属性，如果o中不存在x,那么将会继续在o的原型对象中查询属性x。如果原型对象中也没有x，但这个原型对象也友原形，bane继续在这个原型对象的原型上查询，直到找到或者原型是NULL为止</li>
<li>对象的原型属性构成了一个链，通过这个链可以实现属性的继承</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/1.png" alt="示例"></p>
<ul>
<li>属性赋值：<ul>
<li>首先检查原型链，以此判定是否允许赋值操作</li>
<li>如果允许属性赋值操作，他也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/2.png" alt="示例"></p>
<h4 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h4><p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/3.png" alt="示例"></p>
<h3 id="6-3删除属性"><a href="#6-3删除属性" class="headerlink" title="6.3删除属性"></a>6.3删除属性</h3><h4 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h4><ul>
<li>他的操作数应当是一个属性访问表达式</li>
<li>只能删除自有的属性，不能删除继承的属性<ul>
<li>要删除继承的属性必须从定义这个属性的原型对象上删除它</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> book.author;</span><br><span class="line"><span class="keyword">delete</span> book[<span class="string">"main title"</span>];</span><br><span class="line"></span><br><span class="line">o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;				<span class="comment">//o 有一个属性，并且继承了属性toString</span></span><br><span class="line"><span class="keyword">delete</span> o.x;				<span class="comment">//删除x，返回true；</span></span><br><span class="line"><span class="keyword">delete</span> o.x;				<span class="comment">//什么也没做，x已经被删除了</span></span><br><span class="line"><span class="keyword">delete</span> o.toString ;		<span class="comment">//什么也没做，因为toString是继承来的，无法删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span>;				<span class="comment">//无意义，返回true</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4检测属性"><a href="#6-4检测属性" class="headerlink" title="6.4检测属性"></a>6.4检测属性</h3><ul>
<li>in 运算符<ul>
<li>如果对象的自由属性或者继承属性中包含这个属性则返回true</li>
</ul>
</li>
<li>hasOwnProperty()<ul>
<li>是否是对象的自有属性</li>
</ul>
</li>
<li>propertyIsEnumerable()W<ul>
<li>只有检测到是自由属性，且这个属性是可枚举的才会返回true</li>
</ul>
</li>
<li>“！==undefined”<ul>
<li>判断一个属性是否为undefined（无法区分存在但值位undefined的属性）</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/4.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/5.png" alt="示例"></p>
<h3 id="6-5枚举属性"><a href="#6-5枚举属性" class="headerlink" title="6.5枚举属性"></a>6.5枚举属性</h3><h4 id="遍历对象的属性"><a href="#遍历对象的属性" class="headerlink" title="遍历对象的属性"></a>遍历对象的属性</h4><ul>
<li>for/in (对象名或索引)循环 for/of (值）循环<ul>
<li>遍历对象中所有可枚举的属性（包括自有属性和继承属性）</li>
</ul>
</li>
<li>Object.keys( 对象名 )<ul>
<li>返回可枚举的自有属性</li>
</ul>
</li>
<li>Object.getOwnPropertyNames( 对象名 )<ul>
<li>同Object.keys( ），但也返回属性名字是字符串的不可枚举属性</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/6.png" alt="示例"></p>
<h3 id="6-6属性getter-和setter"><a href="#6-6属性getter-和setter" class="headerlink" title="6.6属性getter 和setter"></a>6.6属性getter 和setter</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o =&#123;</span><br><span class="line">    <span class="comment">//普通数据属性</span></span><br><span class="line">    data_prop: value;</span><br><span class="line">    <span class="comment">//存取器属性都是成对定义的函数</span></span><br><span class="line">    <span class="keyword">get</span> accessor_prop ()&#123; <span class="comment">/*这里是函数体*/</span>&#125;</span><br><span class="line">  	<span class="keyword">set</span> accessor_prop (value)&#123; <span class="comment">/*这里是函数体*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时具有getter和setter方法，是一个读/写属性</li>
<li>只有getter方法，是只读属性</li>
<li>只有setter方法，是只写属性，读取只写属性总是返回undefined；</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/7.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/8.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/9.png" alt="示例"></p>
<h3 id="6-7属性的特性"><a href="#6-7属性的特性" class="headerlink" title="6.7属性的特性"></a>6.7属性的特性</h3><ul>
<li>一个属性包含一个名字和4 个特性<ul>
<li>值 value</li>
<li>可写性 writable</li>
<li>可枚举性 enumerale</li>
<li>可配置性 configurable</li>
</ul>
</li>
<li>本节中，存储器属性的getter和setter方法看成是属性的特性<ul>
<li>存取器属性的4个特性是读取，写入，可枚举性，可配置性</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/10.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/11.png" alt="示例"></p>
<ul>
<li>设置属性的特性<ul>
<li>Object.defineProperty()</li>
<li>注意，这个方法要么修改已有的属性要么新建自有属性，但不能修改继承属性</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/12.png" alt="示例"></p>
<ul>
<li>同时修改多个属性</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/13.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/14.png" alt="示例"></p>
<h3 id="对象的三个属性"><a href="#对象的三个属性" class="headerlink" title="对象的三个属性"></a>对象的三个属性</h3><ul>
<li>每一个对象都有与之相关的原型（prototype)，类（class）和可扩展性（extensibleattribute）</li>
</ul>
<h4 id="6-8-1原型属性"><a href="#6-8-1原型属性" class="headerlink" title="6.8.1原型属性"></a>6.8.1原型属性</h4><ul>
<li>对象的原型属性是用来继承属性的</li>
<li>查询原型 Object.getPrototypeOf()</li>
<li>p.isPrototypeOf(o)用来检测p是否在o的原型链中（o是否继承于p）</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/15.png" alt="示例"></p>
<h4 id="6-8-2类属性"><a href="#6-8-2类属性" class="headerlink" title="6.8.2类属性"></a>6.8.2类属性</h4><pre><code>+ 类属性是一个字符串，用以表示对象的类型信息
+ classof()函数可以返回传递给它的任意对象的类。classof()函数可以传入任何类型的参数。数字、字符串和布尔值可以直接用toString()方法，就和对象调用toString()方法一样，并且这个函数包含了对null和undefined的特殊处理</code></pre><p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/16.png" alt="示例"></p>
<h4 id="6-8-3可扩展性"><a href="#6-8-3可扩展性" class="headerlink" title="6.8.3可扩展性"></a>6.8.3可扩展性</h4><ul>
<li>表示是否可以给对象添加新属性，可扩展属性的目的是将对象“锁定”。以避免外界的干扰</li>
<li>Object.isExtensible()判断该对象是否是可扩展</li>
<li>Object.preventExtension(将对象转换为不可扩展的<ul>
<li>一旦对象转换为不可扩展的，就无法再转换回可扩展的</li>
<li>但可以给不可扩展的对象的原型添加属性</li>
</ul>
</li>
<li>Object.seal()设置对象不可扩展，自有属性不可配置<ul>
<li>Object.isSealed()来检测对象是否封闭</li>
</ul>
</li>
<li>Object.freeze()设置对象不可扩展，属性不可配置，数据属性只读(若存取器属性具有setter仍然可以通过给属性赋值调用)<ul>
<li>Object.isFrozen()来判断对象是否冻结</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/17.png" alt="示例"></p>
<h3 id="6-9序列化对象"><a href="#6-9序列化对象" class="headerlink" title="6.9序列化对象"></a>6.9序列化对象</h3><ul>
<li>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象</li>
<li>JSON.stringify（）序列化对象</li>
<li>JSON.parse（） 还原对象</li>
</ul>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/18.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/19.png" alt="示例"></p>
<h3 id="6-10对象方法"><a href="#6-10对象方法" class="headerlink" title="6.10对象方法"></a>6.10对象方法</h3><ul>
<li>toString ()</li>
<li>toLocaleString()</li>
<li>toJSON()</li>
<li>valueOf()</li>
</ul>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/20.png" alt="示例"></p>
<h4 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString ()"></a>toLocaleString ()</h4><p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/21.png" alt="示例"></p>
<h4 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON()"></a>toJSON()</h4><p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/21.png" alt="示例"></p>
<h4 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf()"></a>ValueOf()</h4><p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/22.png" alt="示例"></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h1 id="this-指代当前对象，在哪个对象中实现就指代那个对象"><a href="#this-指代当前对象，在哪个对象中实现就指代那个对象" class="headerlink" title="this 指代当前对象，在哪个对象中实现就指代那个对象"></a>this 指代当前对象，在哪个对象中实现就指代那个对象</h1><p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/24.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-6%E5%AF%B9%E8%B1%A1/25.png" alt="示例"></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-7数组</title>
    <url>/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="Javascript-7数组"><a href="#Javascript-7数组" class="headerlink" title="Javascript-7数组"></a>Javascript-7数组</h1><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><ul>
<li>数组是值得有序集合<ul>
<li>Javascript数组是动态的：根据需要会增长或缩减</li>
<li>Javascript数组可能是稀疏的：数组元素之间可以有空缺<ul>
<li>对于非稀疏数组，lenth属性就是元素的个数</li>
<li>对于稀疏数组，lenth比所有元素的索引要大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-1创建数组"><a href="#7-1创建数组" class="headerlink" title="7.1创建数组"></a>7.1创建数组</h3><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><h5 id="使用数组直接量"><a href="#使用数组直接量" class="headerlink" title="使用数组直接量"></a>使用数组直接量</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> empty=&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> primes = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> misc = &#123;<span class="number">1.1</span>,<span class="literal">true</span>,<span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> base = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> table = &#123;base,base+<span class="number">1</span>,base+<span class="number">2</span>,base+<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b =&#123;[<span class="number">1</span>,&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;],[<span class="number">2</span>,&#123;<span class="attr">x</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="number">4</span>&#125;]&#125;;</span><br><span class="line"><span class="keyword">var</span> count = &#123;<span class="number">1</span>,,<span class="number">3</span>&#125;;		<span class="comment">//数组有3个元素，中间的那个元素值为undefined</span></span><br><span class="line"><span class="keyword">var</span> undefs = [,,] 		<span class="comment">//数组有两个元素，都是undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="调用构造函数Array"><a href="#调用构造函数Array" class="headerlink" title="调用构造函数Array()"></a>调用构造函数Array()</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">"testing,testing"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-2-数组元素的读和写"><a href="#7-2-数组元素的读和写" class="headerlink" title="7.2 数组元素的读和写"></a>7.2 数组元素的读和写</h3><h4 id="使用-操作符来读写数组中的一个元素"><a href="#使用-操作符来读写数组中的一个元素" class="headerlink" title="使用[]操作符来读写数组中的一个元素"></a>使用[]操作符来读写数组中的一个元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"World"</span>];</span><br><span class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>];		<span class="comment">//读第0个元素</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;			<span class="comment">//写第一个元素</span></span><br><span class="line">i = <span class="number">2</span>;			</span><br><span class="line">a[i] = <span class="number">3</span>;				<span class="comment">//写第二个元素</span></span><br><span class="line">a[i+<span class="number">1</span>] = <span class="string">"hello"</span>		<span class="comment">//写第三个元素</span></span><br><span class="line">a[a[i]] = a[<span class="number">0</span>]			<span class="comment">//读第0个和第2个元素，写第三个元素</span></span><br></pre></td></tr></table></figure>

<p>可以使用负数或者非整数来索引数组，这种情况下数值转换为字符串，字符串作为属性名来使用</p>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/1.png" alt="示例"></p>
<h3 id="7-3稀疏数组-数组长度"><a href="#7-3稀疏数组-数组长度" class="headerlink" title="7.3稀疏数组+数组长度"></a>7.3稀疏数组+数组长度</h3><ul>
<li>当数组是稀疏的时候，length 属性大于元素的个数</li>
<li>lenth属性为小于当前长度的非负整数n时，数组中索引值大于或等于n得元素将从中删除</li>
<li>length属性值设置为大于其当前的长度，会在数组尾部创建一个空的区域</li>
</ul>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/2.png" alt="示例"></p>
<h3 id="7-5数组元素的添加和删除"><a href="#7-5数组元素的添加和删除" class="headerlink" title="7.5数组元素的添加和删除"></a>7.5数组元素的添加和删除</h3><ul>
<li>添加元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a= [];</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"zero"</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"one"</span> ;</span><br></pre></td></tr></table></figure>

<ul>
<li>push()方法在尾部添加元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = [];</span><br><span class="line">a.push(<span class="string">"zero"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>unshift在首部添加元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a3 = [];</span><br><span class="line">a3.unshift(<span class="number">1</span>);</span><br><span class="line">a3.unshift(<span class="number">2</span>);</span><br><span class="line">a3 = [<span class="number">2</span>,<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>delete 删除元素</li>
</ul>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/3.png" alt="示例"></p>
<h3 id="7-6数组遍历"><a href="#7-6数组遍历" class="headerlink" title="7.6数组遍历"></a>7.6数组遍历</h3><ul>
<li>for循环</li>
<li>for/in循环<ul>
<li>只会对存在得元素遍历，undefined元素会跳过</li>
</ul>
</li>
<li>forEach()方法,会忽略empty和对象元素</li>
</ul>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/4.png" alt="示例"></p>
<h3 id="7-7多维数组"><a href="#7-7多维数组" class="headerlink" title="7.7多维数组"></a>7.7多维数组</h3><p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/5.png" alt="示例"></p>
<h3 id="7-8数组方法"><a href="#7-8数组方法" class="headerlink" title="7.8数组方法"></a>7.8数组方法</h3><h4 id="Array-join"><a href="#Array-join" class="headerlink" title="Array.join()"></a>Array.join()</h4><ul>
<li>将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串</li>
<li>可指定字符串来分割数组的各个元素，默认使用逗号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join();		<span class="comment">//"1，2，3"</span></span><br><span class="line">a.join(<span class="string">" "</span>);	<span class="comment">//"1 2 3"</span></span><br><span class="line">a.join(<span class="string">""</span>);		<span class="comment">//"123"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">b.join(<span class="string">'-'</span>); 	<span class="comment">//'---------'</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-reverse"><a href="#Array-reverse" class="headerlink" title="Array.reverse()"></a>Array.reverse()</h4><ul>
<li>将数组中的元素颠倒顺序，返回逆序得数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.reverse().join() 	<span class="comment">// =》“3，2，1” 并且a数组已经改变</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-sort"><a href="#Array-sort" class="headerlink" title="Array.sort()"></a>Array.sort()</h4><ul>
<li>将元素以字母表书匈奴排序并返回排序后的数组<ul>
<li>undefined元素会被拍到数组的尾部</li>
<li>可以给sort()方法传递一个比较函数</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; new Array(&quot;b&quot;,&quot;a&quot;,&quot;c&quot;);</span><br><span class="line">a.sort();</span><br><span class="line">var s &#x3D; a.join(&quot;,&quot;); &#x2F;&#x2F;s &#x3D;&#x3D;&quot;a,b,c&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/6.png" alt="示例"></p>
<ul>
<li>注意：Array.sort()默认把所有元素先转换为String再排序</li>
</ul>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/7.png" alt="示例"></p>
<h4 id="Array-concat"><a href="#Array-concat" class="headerlink" title="Array.concat()"></a>Array.concat()</h4><ul>
<li>创建并返回一个链接数组元素得新数组</li>
<li>不会递归扁平化数组的数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat (<span class="number">4</span>,<span class="number">6</span>); 	<span class="comment">//[1,2,3,4,6]</span></span><br><span class="line">a.concat ([<span class="number">4</span>,<span class="number">5</span>])	<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line">a.concat ([<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>]) <span class="comment">//[1，2，3，4，5，6，7]</span></span><br><span class="line">a.concat (<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]) <span class="comment">//[1,2,3,4,5,[6,7]]</span></span><br><span class="line"><span class="comment">//合并数组，但不能合并数组中的数组</span></span><br><span class="line"><span class="comment">//数组中的数组会被当成新数组中的一个对象</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-slice"><a href="#Array-slice" class="headerlink" title="Array.slice()"></a>Array.slice()</h4><ul>
<li>返回指定数组的一个片段或者子数组</li>
<li>它的两个参数分别指定了片段的开始和结束的位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//包含两个参数：第二个参数值数组到但是不会包含</span></span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">3</span>)<span class="comment">//[1,2,3];</span></span><br><span class="line"><span class="comment">//只有一个数字说明从这个指定位置开始一直到结尾</span></span><br><span class="line">a.slice(<span class="number">3</span>)<span class="comment">//[4,5];</span></span><br><span class="line"><span class="comment">//包含负数，它表示相对于数组中最后一个元素的位置</span></span><br><span class="line">a.slice(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//[2,3,4]</span></span><br><span class="line">a.slice(<span class="number">-3</span>,<span class="number">-2</span>);<span class="comment">//[3]</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-splice"><a href="#Array-splice" class="headerlink" title="Array.splice()"></a>Array.splice()</h4><ul>
<li>插入或删除元素的通用方法</li>
<li>在插入或者删除之后的数组元素会根据需要增加或者减小索引值，因此数组的其他部分仍然保持连续</li>
<li>第一个参数指定插入和删除的起始位置</li>
<li>第二个参数制定了应该从数组中删除的元素的个数<ul>
<li>如果省略第二个参数从七十点开始到数组结尾的所有元素都将被删除</li>
<li>第二个参数后的任意个数的参数制定了需要插入到数组中的元素，从第一个参数指定的位置插入</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.splice(<span class="number">4</span>); <span class="comment">//返回[5,6,7,8];a 是[1，2，3，4]</span></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//返回[2,3];a是[4]</span></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">1</span>);	<span class="comment">//返回[4];a是[1];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">'a'</span>,<span class="string">'b'</span>);<span class="comment">// 返回[]; a是[1,2,'a','b',4,5]</span></span><br><span class="line">a.splice(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>);<span class="comment">// 返回['a','b'];a是[1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h4 id="push-和pop"><a href="#push-和pop" class="headerlink" title="push()和pop()"></a>push()和pop()</h4><p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/8.png" alt="示例"></p>
<h4 id="unshift-和shift"><a href="#unshift-和shift" class="headerlink" title="unshift()和shift()"></a>unshift()和shift()</h4><p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/9.png" alt="示例"></p>
<h3 id="7-9ECMAScript5中的数组方法"><a href="#7-9ECMAScript5中的数组方法" class="headerlink" title="7.9ECMAScript5中的数组方法"></a>7.9ECMAScript5中的数组方法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>第一个参数接受一个函数，对数组的每个元素（或者一些元素) 调用一次函数<ul>
<li>大多数情况下，这些函数使用三个参数：数组元素，元素的索引，和数组本身</li>
</ul>
</li>
<li>第二个参数（可选）.如果函数有第2个参数，则调用的函数（第一个参数）被看作是第二个参数的方法<ul>
<li>也就是说在调用函数时传递进去的第二个参数作为他的this的关键词的值来使用</li>
<li>不会修改他们调用的原始数组</li>
</ul>
</li>
</ul>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/10.png" alt="示例"></p>
<ul>
<li>注意，forEach()无法在所有元素都传递给调用的函数之前终止遍历</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><ul>
<li>将调用的数组的每个元素传递给指定的函数，并返回一个新数组（不修改调用的数组）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow);<span class="comment">//[1,4,9,16,25,36,49,64,81]</span></span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><ul>
<li>传递的函数是用来判断逻辑判定true或者false</li>
<li>注意filter()会跳过稀疏数组中缺少的元素，返回的数组总是稠密的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">smallvalues = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x&lt;<span class="number">3</span>&#125;); <span class="comment">//[2,1]</span></span><br><span class="line">everyother = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x,i</span>)</span>&#123;<span class="keyword">return</span> i%<span class="number">2</span>==<span class="number">0</span>&#125;);<span class="comment">//[5,3,1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>filter()接收的回调函数，其实可以有多个参数，通常我们仅仅使用第一个元素。表示Array 的某个元素，另外两个参数表示元素的位置和数组本身</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element,index,self</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(element) 	<span class="comment">//'A','B','C</span></span><br><span class="line">	<span class="built_in">console</span>.log(index)		<span class="comment">//0,1,2</span></span><br><span class="line">	<span class="built_in">console</span>.log(self)		<span class="comment">//arr</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>利用filter进行元素去重<ul>
<li>去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置于indexOf返回的位置不相等，因此被filter</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/11.png" alt="示例"></p>
<h4 id="every-和some"><a href="#every-和some" class="headerlink" title="every()和some()"></a>every()和some()</h4><ul>
<li>every()”针对所有“ 当且仅当针对数组中的所有元素调用判定函数都返回true，才返回true</li>
<li>some()”存在 “:当数组中至少有一个元素调用判定函数返回true，它就返回true</li>
<li>空数组上调用时，every()返回true,some()返回false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x&lt;<span class="number">10</span>;&#125;)	  <span class="comment">//true</span></span><br><span class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x%<span class="number">2</span>===<span class="number">0</span>;&#125;) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x%<span class="number">2</span>===<span class="number">0</span>; &#125;)<span class="comment">//true</span></span><br><span class="line">a.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">isNaN</span> ;&#125;)	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="reduce-和reduceRight"><a href="#reduce-和reduceRight" class="headerlink" title="reduce()和reduceRight()"></a>reduce()和reduceRight()</h4><ul>
<li><p>reduce()</p>
<ul>
<li><p>第一个参数：一个函数，作用在每个元素上，reduce()将结果继续和序列的下一个元素做累计计算</p>
</li>
<li><pre><code class="javascript">[x1,x2,x3,x4].reduce(f)=f(f(f(x1,x2),x3),x4)
&lt;!--￼<span class="number">16</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="7-10数组类型"><a href="#7-10数组类型" class="headerlink" title="7.10数组类型"></a>7.10数组类型</h3><ul>
<li>Array.isArray()函数判断是否为数组</li>
</ul>
<h3 id="7-11类数组对象"><a href="#7-11类数组对象" class="headerlink" title="7.11类数组对象"></a>7.11类数组对象</h3><ul>
<li>Javascript数组拥有的其他对象所没有的特性<ul>
<li>新的元素添加到列表中是，自动更新length属性</li>
<li>设置length为一个较小值将截断数组</li>
<li>从Array.prototype中继承一些有用的方法</li>
<li>其类属性为”Array”</li>
</ul>
</li>
<li>类数组 对象<ul>
<li>拥有length属性和对应非负整数属性的对象</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/14.png" alt="示例"></p>
<ul>
<li>注意<ul>
<li>再ECMA5中字符串的行为和数组类似，但他们最好当作字符串处理</li>
<li>JS数组方法是通用的，不仅应用在真正的数组上，也可以用在类数组上</li>
<li>可以直接定义类数组对象</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/15.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-7%E6%95%B0%E7%BB%84/15.png" alt="示例"></p>
<h3 id="7-12作为数组的字符串"><a href="#7-12作为数组的字符串" class="headerlink" title="7.12作为数组的字符串"></a>7.12作为数组的字符串</h3><ul>
<li><p>字符串的行为类似于只读的数组</p>
<ul>
<li><p>访问单个字符串的两种方法</p>
</li>
<li><pre><code class="javascript"><span class="keyword">var</span> s = <span class="string">'test'</span>;
<span class="built_in">console</span>.log(s.charAt(<span class="number">0</span>));
<span class="built_in">console</span>.log(s[<span class="number">0</span>]); </code></pre>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>LHRandLNR</title>
    <url>/2020/04/28/LHRandLNR/</url>
    <content><![CDATA[<h1 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h1><h2 id="LHR-2"><a href="#LHR-2" class="headerlink" title="$LHR^2$"></a>$LHR^2$</h2><ul>
<li>方法</li>
<li>首先解特征方程，求出每一个根包括重根</li>
<li>如果根都是不重复的,比如 $a_n$ = 6a<sub>n-1</sub>-5a<sub>n-2</sub><ul>
<li>解的 $r_1=1$, $r_2=5$</li>
<li>那么   $a_n$ = $\alpha_1(1)^n$+$\alpha_2(5)^n$</li>
<li>然后把 $a_0,a_1$带入方程算出 $\alpha_1$和$\alpha_2$的值</li>
</ul>
</li>
<li>如果根是重复的。比如 $a_n$ = 6a<sub>n-1</sub>-9a<sub>n-2</sub><ul>
<li>解得 $r_1=3$, $r_2=3$</li>
<li>那么    $a_n$ = $\alpha_1(3)^n$+$\alpha_2n(3)^n$</li>
<li>也就是说，$\alpha$后出现了$n^0,n^1,n^2,n^3……$</li>
<li>然后把 $a_0,a_1$带入方程算出 $\alpha_1$和$\alpha_2$的值</li>
</ul>
</li>
</ul>
<h2 id="LNR-2"><a href="#LNR-2" class="headerlink" title="$LNR^2$"></a>$LNR^2$</h2><ul>
<li><p>方法</p>
</li>
<li><p>通项公式是 通解+ 特解</p>
</li>
<li><p>通解得算法就是抹掉常数项，然后解法和$LHR^2$一样</p>
</li>
<li><p>再计算特解</p>
<ul>
<li>这里需要分类</li>
<li>如果常数项是  C(常数)  那么对应的就是 <strong>A</strong><ul>
<li>如果常数项是  n  那么对应的就是    $A_1n+A_0$      </li>
<li>如果常数项是  $n^2$ 那么对应的就是 $A_2n^2+A_1n+A_0$ （以此类推）</li>
<li>如果常数项是   $r^n$   那么对应的就是 $Ar^n$      </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>把F(n)化成一下格式再做判断 $F(n) =$ (b<sub>t</sub> $n^t$+b<sub>t-1</sub>n<sup>t-1</sup>+……+b<sub>1</sub>n+b<sub>0</sub>) $s^n$</p>
</li>
<li><p>If s is not a root of the characteristic equation of the associated LHR2, there is a particular solution of form. （待会会举例子）</p>
<ul>
<li>(p<sub>t</sub> $n^t$+p<sub>t-1</sub>n<sup>t-1</sup>+……+p<sub>1</sub>n+p<sub>0</sub>) $s^n$;</li>
</ul>
</li>
<li><p>Else, s is a root of multiplicity m, the particular solution is of form</p>
</li>
<li><p>(p<sub>t</sub> $n^t$+p<sub>t-1</sub>n<sup>t-1</sup>+……+p<sub>1</sub>n+p<sub>0</sub>) $s^nn^m$  ;</p>
</li>
</ul>
<ul>
<li><p>例子1</p>
<ul>
<li><p><strong>$a_n$ = 3a<sub>n-1</sub>-2n</strong></p>
</li>
<li><p>step1: find the solution for LHR<sup>2</sup>. The associated linear homogeneous equation is <strong>a<sub>n</sub> = 3a<sub>n-1</sub></strong>. Its solution is    <strong>a<sub>n</sub><sup>(h)</sup> = $\alpha3^n$</strong>    ,where $\alpha$ is a constant.</p>
</li>
<li><p>上标代表了homogeneous，是齐次方程组的通解</p>
</li>
<li><p>step2: 因为常数项是2n所以对应表中的 $A_1n+A_0$,所以 令<strong>p<sub>n</sub> = cn+d</strong>，然后带入原方程，得到 了这个<strong>cn+d= 3（ c(n-1)+d)+2n</strong>  要让<strong>(2 + 2c)n +(2d - 3c) = 0</strong> 解得 <strong>c = -1 and d = -3/2</strong></p>
</li>
<li><p>$a_n = {a_n^p+a_n^h }=-n-1.5+  \alpha3^n$</p>
</li>
<li><p>最后带入求$\alpha$</p>
</li>
</ul>
</li>
<li><p>例子2</p>
<ul>
<li><p><strong>$a_n$ =  a<sub>n-1</sub> +n</strong></p>
</li>
<li><p>step1:The associated linear homogeneous equation is<strong>a<sub>n</sub> =a<sub>n-1</sub></strong>. Its solution is <strong>a<sub>n</sub><sup>(h)</sup> = $\alpha1^n$</strong> =$\alpha$   where $\alpha$ is a constant.</p>
</li>
<li><p>step2: F(n) = n = n<em>(1)<sup>n</sup>,    s=1 是 LHR<sup>2</sup>的一个根，所以说，这里有变化， 原来的*</em>p<sub>n</sub> = cn+d<strong>变成了 **n(cn+d)</strong> </p>
</li>
<li><p>再带入原方程<strong>n(cn+d)= (n-1)(c(n-1)+d)+n  解得 c=d=0.5</strong>  </p>
</li>
<li><p>$a_n = {a_n^p+a_n^h }=n(n+1)/2 +  \alpha $ </p>
</li>
</ul>
</li>
<li><p>例子3</p>
<ul>
<li><strong>$a_n$ = 2a<sub>n-1</sub>+2<sup>n</sup></strong></li>
<li>step1: <strong>a<sub>n</sub> =2a<sub>n-1</sub></strong>   so  <strong>a<sub>n</sub><sup>(h)</sup> = $\alpha(2)^n$</strong></li>
<li>step2: 这里常数项是(1)*2<sup>n</sup> 根据表内，对应$Ar^n$ 但是 因为2是 LHR<sup>2</sup>的一个根，所以说，这里有变化，变成了 A2<sup>n</sup>n  </li>
<li>带入原方程 A2<sup>n+1</sup>(n+1) -2A2<sup>n</sup>n = 2<sup>n</sup>   解得A = 0.5</li>
<li>$a_n = {a_n^p+a_n^h }=\alpha2^n $+ *<em>n2<sup>n-1</sup> *</em></li>
</ul>
</li>
<li><p>例子4</p>
<ul>
<li><strong>a<sub>n+2</sub>+3a<sub>n+1</sub>+2a<sub>n</sub> = 3<sup>n</sup></strong></li>
<li>step1: r<sup>2</sup>+3r+2 = 0 (r+2)(r+1) =0; r = -1,r = -2    <strong>a<sub>n</sub><sup>(h)</sup></strong> = $\alpha_1(-2)^n$+$\alpha_2(-1)^n$</li>
<li>step2: 这里常数项是(1)*3<sup>n</sup> 根据表内，对应$Ar^n$   因为3不是 LHR<sup>2</sup>的一个根，所以说，照常</li>
<li><strong>A3<sup>n+2</sup>+3A3<sup>n+1</sup>+2A3<sup>n</sup> = 3<sup>n</sup>  $\Longrightarrow$  A = 1/20</strong></li>
<li><strong>a<sub>n</sub><sup>(h)</sup></strong> = $\alpha_1(-2)^n$+$\alpha_2(-1)^n$+<strong>1/20(3<sup>n</sup>)</strong></li>
</ul>
</li>
</ul>
<h2 id="结合下面的例子，我们可以更清楚的了解"><a href="#结合下面的例子，我们可以更清楚的了解" class="headerlink" title="结合下面的例子，我们可以更清楚的了解"></a>结合下面的例子，我们可以更清楚的了解</h2><img src="/2020/04/28/LHRandLNR/04/28/LHRandLNR/1.png" class>

<img src="/2020/04/28/LHRandLNR/04/28/LHRandLNR/2.png" class>

<img src="/2020/04/28/LHRandLNR/04/28/LHRandLNR/3.png" class>]]></content>
      <tags>
        <tag>discrete mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-8函数</title>
    <url>/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="JavaScript-8函数"><a href="#JavaScript-8函数" class="headerlink" title="JavaScript-8函数"></a>JavaScript-8函数</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><ul>
<li>形参实参</li>
<li>this</li>
<li>对象的方法</li>
<li>构造函数</li>
<li>函数即对象</li>
<li>闭包<ul>
<li>函数可以嵌套在其他函数中定义，这样他们就可以访问他们被定义时所处的作用域中的任何变量，这意味着Javascript函数构成了一个闭包</li>
</ul>
</li>
</ul>
<h3 id="8-1函数定义"><a href="#8-1函数定义" class="headerlink" title="8.1函数定义"></a>8.1函数定义</h3><ul>
<li>两种方式<ul>
<li>函数定义表达式</li>
<li>函数声明语句</li>
</ul>
</li>
<li>函数定义的必须部分<ul>
<li>函数名称标识符</li>
<li>一对圆括号。包含由0个或者多个用逗号隔开的标识符组成的列表，这些标识符是函数的参数名称，他们就像函数体中的局部变量一样</li>
<li>一对花括号（包含0或多条JavaScript语句，这些语句构成了函数体）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x ;&#125;</span><br><span class="line"><span class="comment">//函数表达式可以包含名称，这在递归时很有用</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">if</span>(x&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x*fact(x<span class="number">-1</span>)&#125;;</span><br><span class="line"><span class="comment">//函数表达式也可以作为参数传给其他函数</span></span><br><span class="line">data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> a-b; &#125;);</span><br><span class="line"><span class="comment">//函数表达式有时定义后立即调用</span></span><br><span class="line"><span class="keyword">var</span> tensquared = (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x;&#125;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>函数声明语句的例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printprops</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> o)</span><br><span class="line">		<span class="built_in">console</span>.log(p+ <span class="string">"："</span> +o[p]+ <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/1.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/2.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/3.png" alt="示例"></p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>​    为什么叫Arrow Function？因为它的定义用的就是一个箭头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x=&gt;x*x;</span><br><span class="line">===</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数相当于匿名函数，有两种格式<ul>
<li>只包含一个表达式， 省略了{…}和return，就像上面</li>
<li>包含多条语句，这时不能省略</li>
<li>如果参数不是一个，就需要用括号（）括起来</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个参数</span></span><br><span class="line">x=&gt;&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;<span class="keyword">return</span> x*x ;&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="keyword">return</span> -x*x ;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个参数</span></span><br><span class="line">(x,y)=&gt;x*x+y*y</span><br><span class="line"><span class="comment">//无参数 （）=&gt;3.14;</span></span><br><span class="line"><span class="comment">//可变函数</span></span><br><span class="line">(x,y,...rest)=&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> i,sum = x+y;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;rest.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=rest[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果要返回一个对象，就要注意，如果是单表达式，这么写会报错：</p>
<ul>
<li>x=&gt;{foo:x}</li>
</ul>
</li>
<li><p>因为和函数体的{…}有语法冲突，所以要改为：</p>
<ul>
<li>x=&gt;({foo:x})</li>
</ul>
</li>
<li><p>箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	birth: <span class="number">1997</span>,</span><br><span class="line">	getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> b = <span class="keyword">this</span>.birth;</span><br><span class="line">		<span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()-<span class="keyword">this</span>.birth;</span><br><span class="line">            <span class="comment">//this指向undefined而不是obj</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> fn();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这样逻辑是有问题的</span></span><br><span class="line">obj.getAge();<span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    birth:<span class="number">1997</span>,</span><br><span class="line">    getAge:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()-<span class="keyword">this</span>.birth;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge();<span class="comment">//23</span></span><br><span class="line"><span class="comment">//这样箭头函数完全修复了this的指向，this总是指向词法作用域，也就是最外层调用者obj</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-函数调用"><a href="#8-2-函数调用" class="headerlink" title="8.2 函数调用"></a>8.2 函数调用</h3><ul>
<li>调用JavaScript函数的四种方式<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过他们的call()和aply（）方法间接调用</li>
</ul>
</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">printprops(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> total = distance(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>)+distance(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> probability = factorial(<span class="number">5</span>)/factorial(<span class="number">13</span>);</span><br></pre></td></tr></table></figure>

<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><ul>
<li>方法调用和汉时调用的重要区别：<ul>
<li>调用上下文</li>
</ul>
</li>
<li>方法调用通过属性访问表达式</li>
<li>属性访问表达式由两部分组成<ul>
<li>一个对象（o)： 调用上下文，函数体可以用this引用</li>
<li>属性名称(m)</li>
</ul>
</li>
<li>方法是个保存在一个对象的属性里的JavaScript函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o.m = f;</span><br></pre></td></tr></table></figure>

<p>给对象o定义了方法m（）,调用时候她就像这样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o.m();</span><br><span class="line">o.m(x,y);</span><br><span class="line">o[<span class="string">"m"</span>](x,y);	<span class="comment">//o.m(x,y);的另一种写法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator = &#123;</span><br><span class="line">	operand1:<span class="number">1</span>,</span><br><span class="line">	operand2:<span class="number">1</span>,</span><br><span class="line">	add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.result = <span class="keyword">this</span>.operand1+<span class="keyword">this</span>.operand2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add(); 	<span class="comment">//这个方法调用计算1+1的结果</span></span><br><span class="line">calculator.result ;<span class="comment">// =&gt;2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个例子和上面的例子是不一样的，上面的例子中，this外面还有一层函数，在那个函数中用匿名函数</span></span><br><span class="line"><span class="comment">	会不指向obj，而是指向第二层函数。</span></span><br><span class="line"><span class="comment">    var obj=&#123;</span></span><br><span class="line"><span class="comment">        birth: 1997,</span></span><br><span class="line"><span class="comment">        getAge: function()&#123;</span></span><br><span class="line"><span class="comment">            var b = this.birth;</span></span><br><span class="line"><span class="comment">            var fn = function()&#123;</span></span><br><span class="line"><span class="comment">                return new Date().getFullYear()-this.birth;</span></span><br><span class="line"><span class="comment">                //this指向undefined而不是obj</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">		return fn();</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">	但是这个例子中，只有一层，this直接指向obj</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h5><ul>
<li>当方法的返回值是一个对象，这个对象还可以再调用他的方法。形成链，每次调用的结果都是另外一个表达式的组成部分</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">customer.surname.toUpperCase();	<span class="comment">//调用customer.surname的方法</span></span><br><span class="line">f().m();	<span class="comment">//在f()调用结束后继续调用返回值的方法m()</span></span><br><span class="line"><span class="comment">//下面这个表达式是说：找到所有的header，取得他们id的映射，转换成数组并对它们进行排序</span></span><br><span class="line"><span class="comment">//$(": header").map(function()&#123;return this.id&#125;).get().sort();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在设计的API中一直采用这种方式（每个方法都返回this）就可以进行链式调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shape.setX(100).setY(100).setSize(50).setOutline(&quot;red&quot;).setFill(&quot;blue&quot;).draw();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意</p>
<ul>
<li><p>不要把方法的链式调用和构造函数的链式调用混为一谈</p>
</li>
<li><p>方法和this关键词是JS面向对象编程的核心</p>
</li>
<li><p>方法调用实际上都会传入一个隐式实参（一个对象）,方法调用的母体就是这个对象</p>
</li>
<li><pre><code class="javascript">rect.setSize(width,height);
setRectSize(rect,width,height);
&lt;!--￼<span class="number">11</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">	<span class="keyword">return</span> y-<span class="keyword">this</span>.birth();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming =&#123;</span><br><span class="line">	name: <span class="string">'小明'</span>,</span><br><span class="line">	birth: <span class="number">1990</span>,</span><br><span class="line">	age: getAge</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age();<span class="comment">//30</span></span><br><span class="line">getAge();		<span class="comment">//NaN 因为this指向全局去了，全局里面并没有birth()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = xiaoming.age;</span><br><span class="line">fn();			<span class="comment">//这样也是NaN</span></span><br></pre></td></tr></table></figure>

<p>这样是不对的！！！</p>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/4.png" alt="示例"></p>
<p>这样就对了</p>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/5.png" alt="示例"></p>
<h4 id="创建对象时构造"><a href="#创建对象时构造" class="headerlink" title="创建对象时构造"></a>创建对象时构造</h4><ul>
<li>创建过程<ul>
<li>首先创建一个新的空对象，然后传入指定的参数并将这个新对象当作this的值来调用与i个指定的函数。这个函数使用this来初始化新创建对象的属性</li>
<li>构造函数一般不会返回值，这个新创建并被初始化后的对象就是整个对象创建表达式的值</li>
<li>如果构造函数确实会返回一个对象值，则此时对象作为整个对象创建表达式的值，新创建的对象就废弃了</li>
<li>如果构造函数使用return单没有指定返回值，或者返回一个原始值，这时将忽略返回值，而使用这个新对象作为调用结果</li>
</ul>
</li>
</ul>
<h4 id="间接调用"><a href="#间接调用" class="headerlink" title="间接调用"></a>间接调用</h4><p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/6.png" alt="示例"></p>
<h3 id="8-3函数的实参和形参"><a href="#8-3函数的实参和形参" class="headerlink" title="8.3函数的实参和形参"></a>8.3函数的实参和形参</h3><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul>
<li>函数定义未指定函数形参的类型</li>
<li>函数调用没有对传入的实参值做类型检查</li>
<li>不检查传入形参的个数</li>
</ul>
<h4 id="可选形参"><a href="#可选形参" class="headerlink" title="可选形参"></a>可选形参</h4><ul>
<li>若传入的实参比函数声明式指定的形参个数少，剩下的形参都将是只给undefined值<ul>
<li>应该给省略的参数赋一个合理的默认值</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/7.png" alt="示例"></p>
<ul>
<li>注意<ul>
<li>用这种可选形参来实现函数时，需要将可选形参放在参数列表的最后，否则必须传入null或者undefined作为第一个形参<ul>
<li>在函数定义中使用注释/<em>optional</em>/来强调形参式可选的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可变长的实参列表：实参对象"><a href="#可变长的实参列表：实参对象" class="headerlink" title="可变长的实参列表：实参对象"></a>可变长的实参列表：实参对象</h4><ul>
<li>若传入的实参个数超过函数定义时的形参个数，使用参数对象解决<h5 id="函数体内，标识符arguments式指向实参对象的引用"><a href="#函数体内，标识符arguments式指向实参对象的引用" class="headerlink" title="函数体内，标识符arguments式指向实参对象的引用"></a>函数体内，标识符arguments式指向实参对象的引用</h5><ul>
<li>通过数字下表就能访问传入函数的实参值</li>
<li>省略的实参都是undefined，多出的参数自动省略</li>
<li>arguments并不是真正的数组，他是一个实参对象（它是一个对象，只是碰巧具有以数字为索引的属性），实参对象式一个类数组对象</li>
</ul>
</li>
</ul>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/8.png" alt="示例"></p>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/9.png" alt="示例"></p>
<ul>
<li>在非严格模式下，当一个函数包含若干形参，实参对象的数组元素是函数形参所对应实参的别名，并且形参名称可以认为是相同变量的不同命名，单严格模式下不行</li>
</ul>
<h5 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h5><p>剩余参数语法允许我们将一个补丁数量的参数表示为一个数组</p>
<ul>
<li>语法</li>
<li><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/11.png" alt="示例"></li>
<li>例子</li>
<li><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/10.png" alt="示例"></li>
<li><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/12.png" alt="示例"></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...Args</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> theArgs.reduce((previous,current)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> previous+current;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); 	<span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h5 id="剩余参数和arguments对象的区别"><a href="#剩余参数和arguments对象的区别" class="headerlink" title="剩余参数和arguments对象的区别"></a>剩余参数和arguments对象的区别</h5><ul>
<li>剩余参数只包含哪些没有对应形参的实参，arguments对象包含了传给函数的所有实参</li>
<li>arguments对象不是一个真正的数组，而剩余函数是真正的array实例，也就是你能够在它上面直接使用所有的数组方法，比如sort，map，forEach和pop（）</li>
</ul>
<h4 id="将对象属性用作实参"><a href="#将对象属性用作实参" class="headerlink" title="将对象属性用作实参"></a>将对象属性用作实参</h4><ul>
<li>通过名/值 对的形式传入参数，是参数顺序无关紧要</li>
<li>例子</li>
</ul>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/13.png" alt="示例"></p>
<p> <img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/D:%5Cprojects%5CJasonXQH.github.io%5Csource_posts%5CJavascript-8%E5%87%BD%E6%95%B0%5C13.png" alt="13"></p>
<h4 id="实参类型"><a href="#实参类型" class="headerlink" title="实参类型"></a>实参类型</h4><ul>
<li>JavaScript方法的形参并未声明类型，在形参传入函数体之前也没有做类型检查</li>
<li>应当在程序中添加实参类型检查逻辑</li>
</ul>
<p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/14.png" alt="示例"></p>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><ul>
<li>函数默认参数允许在没有值或undefined被传入时使用默认形参</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function multiply(a,b&#x3D;1)&#123;</span><br><span class="line">return a*b;</span><br><span class="line">&#125;</span><br><span class="line">console(multiply(5,2));	&#x2F;&#x2F;10</span><br><span class="line">console(multiply(5))	&#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>

<h3 id="8-4作为值的函数"><a href="#8-4作为值的函数" class="headerlink" title="8.4作为值的函数"></a>8.4作为值的函数</h3><ul>
<li>函数不仅是一种语法，也是值<ul>
<li>可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等<h4 id="赋值给变量"><a href="#赋值给变量" class="headerlink" title="赋值给变量"></a>赋值给变量</h4></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x ;&#125;</span><br><span class="line"><span class="keyword">var</span> s = square; 	<span class="comment">//s 和 square指代同一个函数</span></span><br><span class="line">square(<span class="number">4</span>);			<span class="comment">//16</span></span><br><span class="line">s(<span class="number">4</span>);				<span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值给对象的属性"><a href="#赋值给对象的属性" class="headerlink" title="赋值给对象的属性"></a>赋值给对象的属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">square</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x ;&#125;&#125; <span class="comment">//对象直接量</span></span><br><span class="line"><span class="keyword">var</span> y = o.squre(<span class="number">16</span>);						<span class="comment">//y=256</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值给数组元素"><a href="#赋值给数组元素" class="headerlink" title="赋值给数组元素"></a>赋值给数组元素</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x ;&#125;,<span class="number">20</span>];	<span class="comment">//作为数组的一个成员</span></span><br><span class="line">a[<span class="number">0</span>](a[<span class="number">1</span>]);			<span class="comment">//400</span></span><br></pre></td></tr></table></figure>

<h4 id="作为参数传入另一个函数"><a href="#作为参数传入另一个函数" class="headerlink" title="作为参数传入另一个函数"></a>作为参数传入另一个函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123; <span class="keyword">return</span> x+y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">substract</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x-y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x*y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line"><span class="comment">//这里的函数以上面的某个函数作为参数</span></span><br><span class="line"><span class="comment">//并给他传入两个操作数然后调用它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operate</span>(<span class="params">operator,operad1,operand2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> operaor(operand1,operand2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这行代码所示的函数调用实际上计算了（2+3）+（4*5）的值</span></span><br><span class="line"><span class="keyword">var</span> i = operate(add,operate(add,<span class="number">2</span>,<span class="number">3</span>),operate(multiply,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<h4 id="自定义函数属性"><a href="#自定义函数属性" class="headerlink" title="自定义函数属性"></a>自定义函数属性</h4><ul>
<li>函数可以拥有属性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化函数对象的计数器属性</span></span><br><span class="line"><span class="comment">// 有序函数声明被提前了，因此这里是可以在函数声明之前给他成员赋值的</span></span><br><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//每次调用这个函数都会返回一个不同的整数</span></span><br><span class="line"><span class="comment">//它使用一个属性来记住下一次将要返回的值</span></span><br><span class="line"><span class="function">function <span class="title">uniqueInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> uniqueInteget.counter++;<span class="comment">//先返回计数器的值，然后计数器自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算阶乘，并将结果缓存到函数的属性中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">isFinite</span>(n)&amp;&amp;n&gt;<span class="number">0</span>&amp;&amp;n==<span class="built_in">Math</span>.round(n))&#123;	</span><br><span class="line">        <span class="comment">//有限的正整数，round是四舍五入的函数，这里来判断n是不是整数。isFinite()判断是否无限</span></span><br><span class="line">		<span class="keyword">if</span>(!(n <span class="keyword">in</span> factorial))<span class="comment">//如果这个位置没有缓存结果</span></span><br><span class="line">			factorial[n]=n*factorial(n<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> factorial[n];		<span class="comment">//返回缓存结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">&#125;</span><br><span class="line">factorial[<span class="number">1</span>]=<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="8-5-作为命名空间的函数"><a href="#8-5-作为命名空间的函数" class="headerlink" title="8.5 作为命名空间的函数"></a>8.5 作为命名空间的函数</h3><ul>
<li>不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的</li>
<li>我们常常就简单的定义一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间                 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mymodule</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//模块代码</span></span><br><span class="line">	<span class="comment">//这个模块所使用的所有变量都是局部变量</span></span><br><span class="line">	<span class="comment">//而不是污染全局命名空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//模块代码</span></span><br><span class="line">&#125;());<span class="comment">//结束函数定义并立即调用它</span></span><br></pre></td></tr></table></figure>

<h3 id="8-6-闭包"><a href="#8-6-闭包" class="headerlink" title="8.6 闭包"></a>8.6 闭包</h3><ul>
<li>闭包：函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数的作用域内</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope =<span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> scope;&#125;</span><br><span class="line">	<span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope(); =&gt; <span class="string">"local scope"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope =<span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> scope;&#125;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()(); =&gt; 返回值是什么？ 也是<span class="string">"local scope"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>闭包可以捕捉到局部变量（和参数），并一直保存下来，看起来想这些变量绑定到了在其中定义他们的外部函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniqueInteger = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//定义函数并立即调用</span></span><br><span class="line">	<span class="keyword">var</span> counter = <span class="number">0</span>;	<span class="comment">//函数的私有状态，外面访问不到counter属性</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> counter++;&#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		count : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> n++;&#125;</span><br><span class="line">		reset : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n=<span class="number">0</span>;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c= counter().d= counter();</span><br><span class="line">c.count()		<span class="comment">//0</span></span><br><span class="line">d.count()		<span class="comment">//0 c d 互不干扰</span></span><br><span class="line">c.reset()		<span class="comment">//reset()和count()方法共享状态</span></span><br><span class="line">c.count()		<span class="comment">//0:因为我们把c重置了</span></span><br><span class="line">d.count()		<span class="comment">//1：没有重置d</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span>&#123;</span><br><span class="line">		<span class="keyword">get</span> count()&#123;<span class="keyword">return</span> n++;&#125;</span><br><span class="line">		<span class="keyword">set</span> count(m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m&gt;=n)n=m;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"count can only be set to a larger value"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c= counter(<span class="number">1000</span>);</span><br><span class="line">c.count;			<span class="comment">//1000</span></span><br><span class="line">c.count;			<span class="comment">//1001</span></span><br><span class="line">c.count = <span class="number">2000</span>;		</span><br><span class="line">c.count;			<span class="comment">//2000</span></span><br><span class="line">c.count = <span class="number">2000</span>;		<span class="comment">//Error</span></span><br><span class="line"><span class="comment">//也不是很好</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span>(<span class="params">o,name,predicate</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> value;</span><br><span class="line">	o[<span class="string">"get"</span>+name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> value;&#125;</span><br><span class="line">	o[<span class="string">"set"</span>+ name]=<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(predicate&amp;&amp;!predicate(v))</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"set"</span>+name+<span class="string">": invalid value "</span>+v);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			value =v;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o =&#123;&#125;;</span><br><span class="line">addPrivateProperty(o,<span class="string">"Name"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">typeof</span> x==<span class="string">"string"</span>;&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数返回一个总是返回v的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfunc</span>(<span class="params">v</span>)</span>&#123; <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> v;&#125;;&#125;</span><br><span class="line"><span class="comment">//创建一个数组用来存储常数函数</span></span><br><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) funcs[i] = constfunc(i);</span><br><span class="line"><span class="comment">//在第五个位置的元素所表示的函数返回值为5</span></span><br><span class="line">funcs[<span class="number">5</span>]() <span class="comment">//=&gt; 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个 函数 组成的数组，它们的返回值是0-9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfuncs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> funcs = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="comment">//这时候创建了10个闭包，都共享了i，当i变化，所有的闭包都会返回相同的值</span></span><br><span class="line">		funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">	<span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfuncs();<span class="comment">//变量i的值是10</span></span><br><span class="line">funcs[<span class="number">5</span>]()<span class="comment">//返回值是什么,是10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>每个函数调用都包含一个this值，闭包在外部函数里是无法访问this的<ul>
<li>除非外部函数将this转存为一个变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;<span class="comment">//将this保存至一个变量中，以便嵌套的函数能够访问它</span></span><br></pre></td></tr></table></figure>

<ul>
<li>闭包具有自己所绑定的arguments，因此闭包内无法直接访问外部函数的参数数组<ul>
<li>除非外部函数将参数数组保存到另外一个变量中：</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outerArguments = <span class="built_in">arguments</span>;	<span class="comment">//保存起来以便嵌套的函数能使用它</span></span><br></pre></td></tr></table></figure>



<h3 id="8-7函数属性、方法和构造函数"><a href="#8-7函数属性、方法和构造函数" class="headerlink" title="8.7函数属性、方法和构造函数"></a>8.7函数属性、方法和构造函数</h3><ul>
<li>函数也是对象，他们也可以拥有属性和方法<ul>
<li>函数属性和方法</li>
<li>Function()构造函数</li>
</ul>
</li>
</ul>
<h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><ul>
<li>arguments.length 表示传入函数的实参的个数</li>
<li>函数本身的length属性值得是形参的数量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> actual = args.length;			<span class="comment">//实参的真是个数</span></span><br><span class="line">	<span class="keyword">var</span> excepted = args.callee.length;	<span class="comment">//期望的实参个数</span></span><br><span class="line">	<span class="keyword">if</span>(actual!== expected)				<span class="comment">//如果不同则抛出异常</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Expected"</span>+ expected + <span class="string">"args;got "</span>+ actual);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;</span><br><span class="line">	check(<span class="built_in">arguments</span>);	<span class="comment">// 检查实参个数和期望的实参个数是否一致</span></span><br><span class="line">	<span class="keyword">return</span> x+y+z;		<span class="comment">// 再执行函数的后续逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a,b,...rest</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'a='</span>+a);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'b='</span>+b);</span><br><span class="line">&#125;</span><br><span class="line">foo.length;			<span class="comment">//2 不会管..rest</span></span><br></pre></td></tr></table></figure>

<h4 id="prototype属性，在第九章进一步讨论"><a href="#prototype属性，在第九章进一步讨论" class="headerlink" title="prototype属性，在第九章进一步讨论"></a>prototype属性，在第九章进一步讨论</h4><h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call() 和 apply()"></a>call() 和 apply()</h4><ul>
<li>call()和apply()的第一个实参都变为this的值，即使传入的实参是原始值或者null或者undefined</li>
<li>call()，第一个参数之后的所有实参是要传入带调用函数的值；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.call(o,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//对于这个对象来说调用函数，传入参数1，2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply()实参都放到一个数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.apply(o,[<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">	<span class="keyword">return</span> y = <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xm = &#123;</span><br><span class="line">	name:<span class="string">"小明"</span>,</span><br><span class="line">	birth:<span class="number">1990</span>;</span><br><span class="line">	age: getAge;</span><br><span class="line">&#125;</span><br><span class="line">xm.age();</span><br><span class="line">getAge.apply(xm,[])<span class="comment">//25，this指向xm这个对象</span></span><br><span class="line"><span class="comment">//apply是应用的意思，可以理解为把函数引用到这个对象上</span></span><br></pre></td></tr></table></figure>

<h4 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a>bind()方法</h4><ul>
<li>作用是把函数绑定到某个对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.x+y;&#125;	<span class="comment">//这是个待绑定的函数</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;					<span class="comment">//将要绑定的对象</span></span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);				<span class="comment">//通过调用g(x)来调用o.f(x)</span></span><br><span class="line">g(<span class="number">2</span>)<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>除了第一个实参之外，传入bind()的实参也会绑定到this</li>
<li><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/15.png" alt="示例"></li>
</ul>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p><img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/16.png" alt="示例"></p>
<h3 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function()构造函数"></a>Function()构造函数</h3><ul>
<li>FUnction()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体</li>
<li>除了最后一个实参，其他实参字符串是指定函数的形参名字的字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"return x*y"</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x*y;&#125;</span><br><span class="line"><span class="comment">//这两个是一样的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>需要特别注意<ul>
<li>在运行时动态的创建并编译函数 </li>
<li>每次调用Function（）构造函数都会解析函数体，并创建新的函数对象</li>
<li>所创建的函数代码的编译总是会在顶层函数（全局作用域）执行</li>
</ul>
</li>
</ul>
<img src="/2020/04/21/Javascript-8%E5%87%BD%E6%95%B0/04/21/Javascript-8%E5%87%BD%E6%95%B0/17.png" class>

<h3 id="8-8函数式编程"><a href="#8-8函数式编程" class="headerlink" title="8.8函数式编程"></a>8.8函数式编程</h3><ul>
<li>在JavaScript中可以像操控对象一样操控函数，也就是说可以在Javascript中应用函数式编程技术、</li>
</ul>
<h4 id="使用函数处理数组"><a href="#使用函数处理数组" class="headerlink" title="使用函数处理数组"></a>使用函数处理数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先定义两个简单的函数</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="comment">//然后将这些函数和数组的方法配合使用计算出平均数和标准差</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> mean = data.reduce(sum)/data.length;</span><br><span class="line"><span class="keyword">var</span> deviation = data.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x-mean;&#125;);</span><br><span class="line"><span class="comment">//计算标准差</span></span><br><span class="line"><span class="keyword">var</span> stddev = <span class="built_in">Math</span>.sqrt(deviation.map(square).reduce(sum)/(data.length <span class="number">-1</span>));</span><br></pre></td></tr></table></figure>

<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><ul>
<li>操作函数的函数，它姐手一个或者多个函数作为参数，并返回一个新函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个高阶函数会返回一个新的函数，这个新函数将他的实参传入f()</span></span><br><span class="line"><span class="comment">//并且返回f的返回值的逻辑非</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">not</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> result = f,apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">		<span class="keyword">return</span> !result;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> even = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; 	<span class="comment">//判断是否是偶数</span></span><br><span class="line">	<span class="keyword">return</span> x%<span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> odd=not(even);</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>].every(odd)		<span class="comment">//true 每个元素都是奇数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所返回的函数的参数应当是一个实参数组，并对每个数组元素执行函数f()</span></span><br><span class="line"><span class="comment">//并返回所有计算结果组成的数组</span></span><br><span class="line"><span class="comment">//可以对比一下这个函数和上文提到的map()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123; <span class="keyword">return</span> map(a,f)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x+<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="keyword">var</span> incrementer = mapper(increment);</span><br><span class="line">incrementer([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) ; <span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个新的可以计算f(g(...))的函数</span></span><br><span class="line"><span class="comment">//返回的函数h()将它所有的实参传入g()，然后将g()的返回值传入f()</span></span><br><span class="line"><span class="comment">//调用f()和g()时的this值和调用h()时的this是同一个this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">f,g</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//需要给f()传入一个参数，所以使用f()的call方法</span></span><br><span class="line">		<span class="comment">//需要给g()传入很多参数。所以用g()的apply()方法</span></span><br><span class="line">		<span class="keyword">return</span> f.call(<span class="keyword">this</span>,g.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>));</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="keyword">var</span> squareofsum = compose(square,sum);</span><br><span class="line">squareofsum(<span class="number">2</span>,<span class="number">3</span>) ;<span class="comment">//25</span></span><br></pre></td></tr></table></figure>



<h3 id="不完全函数"><a href="#不完全函数" class="headerlink" title="不完全函数"></a>不完全函数</h3><ul>
<li>这个函数可以接受一些参数，这些参数中有一些参数可以被绑定成其他函数，然后返回一个新的函数，这个新的函数接收剩下的未绑定的的参数</li>
</ul>
<h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><ul>
<li>将上次的计算结果缓存起来，在函数式编程当中，这种缓存技巧叫做记忆</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回f()的带有记忆功能的版本</span></span><br><span class="line"><span class="comment">//只有当f()的实参的字符串表示都不相同时它才会工作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;<span class="comment">//将值保存在闭包内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//将实参转换为字符串形式，并将其用作缓存的键</span></span><br><span class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>.length + <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>,<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">if</span>(key <span class="keyword">in</span> cache) <span class="keyword">return</span> cache[key];<span class="comment">//找到的话直接返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>  cache[key] = f.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);<span class="comment">//否则把新的再调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回两个整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) &#123;</span><br><span class="line">        t=b,b=a&amp;t , a=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b!=<span class="number">0</span>)&#123;</span><br><span class="line">        t=b,b=a%b , a=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gcdmemo = memorize(gcd);</span><br><span class="line">gcdmemo(<span class="number">85</span>,<span class="number">187</span>)<span class="comment">//17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，当我们写一个递归函数是，往往需要实现记忆功能</span></span><br><span class="line"><span class="comment">// 我们更希望调用实现了记忆功能的递归函数，而不是原递归函数</span></span><br><span class="line"><span class="keyword">var</span>  factorial = memorize(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;=<span class="number">1</span>)? <span class="number">1</span>: n*factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">factorial(<span class="number">5</span>);	<span class="comment">//120</span></span><br><span class="line"><span class="comment">//先计算了factorial（1）。。。（4）并且有缓存，不会重复计算</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Permutations</title>
    <url>/2020/04/19/TheNextLargerPermutations/</url>
    <content><![CDATA[<h2 id="离散数学的一个求下一个较大排列的算法"><a href="#离散数学的一个求下一个较大排列的算法" class="headerlink" title="离散数学的一个求下一个较大排列的算法"></a>离散数学的一个求下一个较大排列的算法</h2><ul>
<li>输入n个数，以-1结束，然后会输出下一个大的排列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果如下（不想码字了。。）</span></span><br><span class="line"><span class="comment">输入：1432</span></span><br><span class="line"><span class="comment">At the begin , v[j] = 3</span></span><br><span class="line"><span class="comment">After the operation</span></span><br><span class="line"><span class="comment">v[j] = 1</span></span><br><span class="line"><span class="comment">At the begin , v[k] = 2</span></span><br><span class="line"><span class="comment">After the operation</span></span><br><span class="line"><span class="comment">v[k] = 2</span></span><br><span class="line"><span class="comment">After swap the v[j] and the v[k]</span></span><br><span class="line"><span class="comment">2 4 3 1</span></span><br><span class="line"><span class="comment">Then ,Range the Elems after v[j]</span></span><br><span class="line"><span class="comment">2 1 3 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Finally ,The operation is  down ,and the next larger number is</span></span><br><span class="line"><span class="comment">2 1 3 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：31528764</span></span><br><span class="line"><span class="comment">At the begin , v[j] = 6</span></span><br><span class="line"><span class="comment">After the operation</span></span><br><span class="line"><span class="comment">v[j] = 2</span></span><br><span class="line"><span class="comment">At the begin , v[k] = 4</span></span><br><span class="line"><span class="comment">After the operation</span></span><br><span class="line"><span class="comment">v[k] = 4</span></span><br><span class="line"><span class="comment">After swap the v[j] and the v[k]</span></span><br><span class="line"><span class="comment">3 1 5 4 8 7 6 2</span></span><br><span class="line"><span class="comment">Then ,Range the Elems after v[j]</span></span><br><span class="line"><span class="comment">3 1 5 4 2 7 6 8</span></span><br><span class="line"><span class="comment">3 1 5 4 2 6 7 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Finally ,The operation is  down ,and the next larger number is</span></span><br><span class="line"><span class="comment">3 1 5 4 2 6 7 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printv</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;v1,<span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = v1;</span><br><span class="line">    v1=v2;</span><br><span class="line">    v2= temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThenextLargerNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = n<span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"At the begin , v[j] = "</span>&lt;&lt;v[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(v[j]&gt;v[j+<span class="number">1</span>]) j = j <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"After the operation "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v[j] = "</span>&lt;&lt;v[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span>  k = n<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"At the begin , v[k] = "</span>&lt;&lt;v[k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(v[j]&gt;v[k])</span><br><span class="line">        k = k<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"After the operation "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v[k] = "</span>&lt;&lt;v[k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    swap(v[j],v[k]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"After swap the v[j] and the v[k]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printv(v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Then ,Range the Elems after v[j]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> s = j+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        swap(v[r],v[s]);</span><br><span class="line">        printv(v);</span><br><span class="line">        r--;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Finally ,The operation is  down ,and the next larger number is "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printv(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num%<span class="number">10</span>;</span><br><span class="line">            v.push_back(temp);</span><br><span class="line">            num = num/<span class="number">10</span>;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">        ThenextLargerNumber(v);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>discrete mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>V60甜感冲法</title>
    <url>/2020/04/19/V60%E7%94%9C%E6%84%9F%E5%86%B2%E6%B3%95/</url>
    <content><![CDATA[<h1 id="V60-甜感冲法"><a href="#V60-甜感冲法" class="headerlink" title="V60 甜感冲法"></a>V60 甜感冲法</h1><h2 id="单点注水法"><a href="#单点注水法" class="headerlink" title="单点注水法"></a>单点注水法</h2><ul>
<li><p>粉量20g</p>
</li>
<li><p>正常研磨度</p>
</li>
<li><p>水温90度</p>
</li>
<li><p>闷蒸40cc，30秒</p>
</li>
<li><p>中间点小绕圈至120cc</p>
</li>
<li><p>流的还有7成时候，小绕圈至170cc</p>
</li>
<li><p>流的还有7成时候，小绕圈至220cc</p>
</li>
<li><p>流的还有7成时候，小绕圈至220cc</p>
</li>
<li><p>如果想要口感更厚实一点，再+30cc，大绕圈，冲边缘</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>coffee</tag>
      </tags>
  </entry>
  <entry>
    <title>deque容器</title>
    <url>/2020/04/22/deque%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><p><img src="/2020/04/22/deque%E5%AE%B9%E5%99%A8/1.png" alt></p>
<p><img src="/2020/04/22/deque%E5%AE%B9%E5%99%A8/2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * deque 容器</span></span><br><span class="line"><span class="comment"> * 3331 deque构造函数</span></span><br><span class="line"><span class="comment">        deque&lt;T&gt;deqT:/默认构造形式</span></span><br><span class="line"><span class="comment">        deque (beg,end);//构造函数将[beg,end)区阃中的元素拷贝綸本身●</span></span><br><span class="line"><span class="comment">        deque (n, elem);//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="comment">        deque(const deque&amp;deq);//拷贝构造函数。φ</span></span><br><span class="line"><span class="comment">3332 deque赋值操作</span></span><br><span class="line"><span class="comment">        assign(beg,end);//将[beg,end)区阃中的数据拷贝赋值绐本身。ψ</span></span><br><span class="line"><span class="comment">        assign(n,elem);/将n个elem拷贝赋值给本身</span></span><br><span class="line"><span class="comment">        deque&amp; operator=( const deque&amp;deq):/重载等号操作符</span></span><br><span class="line"><span class="comment">        swap(deq)://将deq与本身的元素互换</span></span><br><span class="line"><span class="comment">3333 deque大小操作</span></span><br><span class="line"><span class="comment">        deque.size();/返回客器中元素的个数</span></span><br><span class="line"><span class="comment">        deque.empty();//判断容器是否</span></span><br><span class="line"><span class="comment">        deque.resize(num)://重新指定容器的长度为num;若容器变长,则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">        					如果容器变短,则末尾超出容器长度的元素被刪除。</span></span><br><span class="line"><span class="comment">        resize(num,elem)://重新指定客器的长度为mm若容器变长,则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">        					如器变短,则末尾超出容器长度的元素被刪除</span></span><br><span class="line"><span class="comment">3334</span></span><br><span class="line"><span class="comment">        push_back(elem)://在寳器尾部添加一个数据</span></span><br><span class="line"><span class="comment">        push_front(elem)://在容器头部插入一个数据</span></span><br><span class="line"><span class="comment">        pop_back()://刪除答器最后一个数据</span></span><br><span class="line"><span class="comment">        pop_ front()://删除容器第一个数据</span></span><br><span class="line"><span class="comment">33.35 deque数据存取</span></span><br><span class="line"><span class="comment">        at(idx)://回索引id所指的数据,如果idk越界,抛出 out of range4</span></span><br><span class="line"><span class="comment">        operator []:/回索引ik所指的数据,如果idx越界,不抛出异常,直接出错。</span></span><br><span class="line"><span class="comment">        front();/返回第一个数据。</span></span><br><span class="line"><span class="comment">        back()://返回最后一个数据</span></span><br><span class="line"><span class="comment">3336 deque插入操作</span></span><br><span class="line"><span class="comment">        insert(pos,elem)://在pos位置插入一个elem元素的拷贝,返回新数据的位置。4</span></span><br><span class="line"><span class="comment">        insert(pos, n, elem)://在ps位置插入n个elem数据,无返回值。</span></span><br><span class="line"><span class="comment">        insert ( pos,beg,end):/在pos位置插入[beg,end)区间的数据,无返回值。</span></span><br><span class="line"><span class="comment">337 deque删除操作</span></span><br><span class="line"><span class="comment">        clear();/移除答器的所有数据</span></span><br><span class="line"><span class="comment">       erase(beg,end);//刪除[beg,end)区间的数据,返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">        erase(pos)；//(刪除pos位置的数据,返回下一个数据的位置。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//iterator 普通迭代器</span></span><br><span class="line">    <span class="comment">//reverse_iterator 反转迭代器</span></span><br><span class="line">    <span class="comment">//const_iterator 只读迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(_Deque_iterator&lt;<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> *&gt; it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        *it = 10000;//为了防止修改本体，在传入参数时加上const</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_back(<span class="number">30</span>);</span><br><span class="line">    d.push_back(<span class="number">40</span>);</span><br><span class="line">    printDeque(d);</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    d.swap(d2);</span><br><span class="line">    printDeque(d);<span class="comment">//交换两个deque的值</span></span><br><span class="line">    <span class="keyword">if</span>(d.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"D IS EMPTY"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"D IS NOT EMPTY"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_back(<span class="number">30</span>);</span><br><span class="line">    d.push_back(<span class="number">40</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line">    d.push_front(<span class="number">300</span>);</span><br><span class="line">    d.push_front(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    printDeque(d);<span class="comment">//400,300,200,100,10,20,30,40</span></span><br><span class="line">    d.pop_back();</span><br><span class="line">    d.pop_front();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printDeque(d);<span class="comment">// 300,200,100,10,20,30</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE FIRST ELEM is "</span>&lt;&lt;d.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE LAST ELEM is "</span>&lt;&lt;d.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    d.insert(++d.<span class="built_in">begin</span>(),<span class="number">10000</span>);</span><br><span class="line">    printDeque(d);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    d.erase(++d.<span class="built_in">begin</span>());</span><br><span class="line">    printDeque(d);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    d.erase(++d.<span class="built_in">begin</span>(),--d.<span class="built_in">end</span>());<span class="comment">//删除区间:留下头尾，中间删掉</span></span><br><span class="line">    printDeque(d);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    d.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**************************************************************/</span></span><br><span class="line"><span class="comment">//利用sort排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BIGTOSMALL</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1&gt;v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    d.push_back(<span class="number">10</span>);</span><br><span class="line">    d.push_back(<span class="number">20</span>);</span><br><span class="line">    d.push_back(<span class="number">30</span>);</span><br><span class="line">    d.push_back(<span class="number">40</span>);</span><br><span class="line">    d.push_front(<span class="number">100</span>);</span><br><span class="line">    d.push_front(<span class="number">200</span>);</span><br><span class="line">    d.push_front(<span class="number">300</span>);</span><br><span class="line">    d.push_front(<span class="number">400</span>);</span><br><span class="line">    <span class="comment">//默认排序规则从小到大</span></span><br><span class="line">    sort(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>());</span><br><span class="line">    printDeque(d);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//从大到小</span></span><br><span class="line">    sort(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>(),BIGTOSMALL );</span><br><span class="line">    printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    test01();</span></span><br><span class="line"><span class="comment">//    test02();</span></span><br><span class="line">    test03();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>fr_traduction</title>
    <url>/2020/04/20/fr-traduction/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr-traduction/58.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/59.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/60.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/61.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/62.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/63.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/64.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/65.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/66.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/67.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/68.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/69.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/70.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/71.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/72.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/73.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/74.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr-traduction/75.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>traduction</tag>
      </tags>
  </entry>
  <entry>
    <title>fr10 主有形容词，直陈式现在时，de代替des</title>
    <url>/2020/04/20/fr10/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr10/1.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr10/2.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr10/3.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr10/4.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr11 指示形容词，重读人称代词，专有名词前的冠词</title>
    <url>/2020/04/20/fr11/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr11/5.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr11/6.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr11/7.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr12 形容词，句子成分，及物与不及物动词</title>
    <url>/2020/04/20/fr12/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr12/8.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr12/9.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr12/10.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr12/11.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr13 缩合冠词，y，国名极所用代词</title>
    <url>/2020/04/20/fr13/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr13/12.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr13/13.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr13/14.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr13/15.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr14 命令式，最近将来时，钟点表达</title>
    <url>/2020/04/20/fr14/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr14/16.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr14/17.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr14/18.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr14/19.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr14/20.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr14/21.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr15 直接宾语人称代词，泛指代词on，第二组动词</title>
    <url>/2020/04/20/fr15/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr15/22.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr15/23.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr15/24.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr15/25.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr16 代词式动词，名词和形容词的补语，短语</title>
    <url>/2020/04/20/fr16/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr16/26.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr16/27.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr16/28.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr16/29.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr17 间宾，最近过去式，代词en</title>
    <url>/2020/04/20/fr17/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr17/30.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr17/31.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr17/32.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr17/33.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr18 无人称代词，年月日表达</title>
    <url>/2020/04/20/fr18/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr18/34.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr18/35.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr18/36.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr18/37.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr18/38.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr19 oui\non\si用法，否定短语，限定短语，que引导的从句</title>
    <url>/2020/04/20/fr19/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr19/1.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr19/2.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr19/3.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr19/4.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr20 过去分词，复合过去式，复合句</title>
    <url>/2020/04/20/fr20/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr20/5.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr20/6.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr20/7.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr20/8.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr21 etre 为助动词的复合过去式，疑问词，疑问句</title>
    <url>/2020/04/20/fr21/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr21/9.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr21/10.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr21/11.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr21/12.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr21/13.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr22  复合过去时中的直宾间宾</title>
    <url>/2020/04/20/fr22/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr22/14.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr22/15.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr22/16.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr22/17.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr23 部分冠词，代词en补充</title>
    <url>/2020/04/20/fr23/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr23/18.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr23/19.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr23/20.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr23/21.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr23/22.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr24 未完成过去时极其与复合过去时的比较</title>
    <url>/2020/04/20/fr24/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr24/23.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr24/24.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr24/25.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr24/26.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr24/27.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr24/28.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr25 关系从句和关系代词qui，形容词和副词的比较级</title>
    <url>/2020/04/20/fr25/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr25/29.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr25/30.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr25/31.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr25/32.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr25/33.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr26 形容词副词的最高级，被动态，形容词前de代替des</title>
    <url>/2020/04/20/fr26/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr26/34.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr26/35.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr26/36.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr26/37.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr26/38.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr27 关系代词 que，关系代词ou</title>
    <url>/2020/04/20/fr27/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr27/39.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr27/40.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr27/41.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr28 指示代词，简单、先将来时</title>
    <url>/2020/04/20/fr28/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr28/42.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr28/43.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr28/44.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr28/45.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr29 过去将来时，间接引语</title>
    <url>/2020/04/20/fr29/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr29/46.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr29/47.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr29/48.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr29/49.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr29/50.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr29/51.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr3</title>
    <url>/2020/04/20/fr3/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr3/14.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr3/15.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr30 强调表达法，代词式动词的意义，书信格式</title>
    <url>/2020/04/20/fr30/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr30/52.jpg" alt="示例"><br><img src="/2020/04/20/fr30/53.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr30/54.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr30/55.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr30/56.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr30/57.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr6</title>
    <url>/2020/04/20/fr6/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr6/19.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr6/20.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr6/21.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr5</title>
    <url>/2020/04/20/fr5/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr5/16.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr5/17.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr5/18.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr7</title>
    <url>/2020/04/20/fr7/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr7/22.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr7/23.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr7/24.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr8</title>
    <url>/2020/04/20/fr8/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr8/25.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr8/26.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr8/27.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>fr9 法语的词类，不定冠词和定冠词，序数词</title>
    <url>/2020/04/20/fr9/</url>
    <content><![CDATA[<p><img src="/2020/04/20/fr9/28.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr9/29.jpg" alt="示例"></p>
<p><img src="/2020/04/20/fr9/30.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
      </tags>
  </entry>
  <entry>
    <title>francais_prononciation</title>
    <url>/2020/04/20/francais-prononciation/</url>
    <content><![CDATA[<p><img src="/2020/04/20/francais-prononciation/1.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/2.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/3.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/4.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/5.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/6.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/7.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/8.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/9.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/10.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/11.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/12.jpg" alt="示例"></p>
<p><img src="/2020/04/20/francais-prononciation/13.jpg" alt="示例"></p>
]]></content>
      <tags>
        <tag>francais</tag>
        <tag>cour de francais accelere</tag>
      </tags>
  </entry>
  <entry>
    <title>list容器</title>
    <url>/2020/04/22/list%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="list-容器的基本操作与示范"><a href="#list-容器的基本操作与示范" class="headerlink" title="list 容器的基本操作与示范"></a>list 容器的基本操作与示范</h1><p><img src="/2020/04/22/list%E5%AE%B9%E5%99%A8/1.png" alt></p>
<p><img src="/2020/04/22/list%E5%AE%B9%E5%99%A8/2.png" alt></p>
<p><img src="/2020/04/22/list%E5%AE%B9%E5%99%A8/3.png" alt></p>
<p><img src="/2020/04/22/list%E5%AE%B9%E5%99%A8/4.png" alt></p>
<p><img src="/2020/04/22/list%E5%AE%B9%E5%99%A8/5.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1ist构造函数</span></span><br><span class="line"><span class="comment">        1ist&lt;T&gt;1istT;//1ist采用采用模板类实现,对象的默认构造形式:</span></span><br><span class="line"><span class="comment">        list(beg,end);//构造函数将(beg,end)区间中的元素拷贝给本身o</span></span><br><span class="line"><span class="comment">        list( n, elem);//构造函数将n个以l拷贝绐本身。</span></span><br><span class="line"><span class="comment">        list( const list&amp;list);//拷贝构造函数。</span></span><br><span class="line"><span class="comment"> list数据元素插入和删除操作</span></span><br><span class="line"><span class="comment">        push_back(elem);//在睿器尾部加入一个元素</span></span><br><span class="line"><span class="comment">        pop_back();/剛刪除容器中最后一个元素4</span></span><br><span class="line"><span class="comment">        push_front(elem);//在容器开头插入一个元素</span></span><br><span class="line"><span class="comment">        pop_front();//从寳器开头移除第一个元素</span></span><br><span class="line"><span class="comment">        insert(pos,elem);//在pos位置插eem元素的拷贝,返回新数据的位置</span></span><br><span class="line"><span class="comment">        insert(pos, n, elem);//在pos位置插入n个elem数据,无返回值。</span></span><br><span class="line"><span class="comment">        ert(pos,beg,end);/在pos位置插入[beg,erd区间的数据,无返回值</span></span><br><span class="line"><span class="comment">        clear ();//移除容器的所有数</span></span><br><span class="line"><span class="comment">        erase(beg,end);/刪除[beg,ed)区间的数据,返回下一个数据的位置。φ</span></span><br><span class="line"><span class="comment">        erase(pos);/!刪除pos位置的数据,返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">        remove(e1em);//刪除荟器中所有与e1em值匹配的元素。</span></span><br><span class="line"><span class="comment">3643list大小操作</span></span><br><span class="line"><span class="comment">        size()://返回答器中元素的个数</span></span><br><span class="line"><span class="comment">        empty()://判断容器是否为空</span></span><br><span class="line"><span class="comment">        resize (num );/重新指定器的长度为num</span></span><br><span class="line"><span class="comment">        若窨器变长,则以默认值填充新位置</span></span><br><span class="line"><span class="comment">        如果容器变短,则末尾超出容器长度的元素被刪除φ</span></span><br><span class="line"><span class="comment">        resize(num, elem);/重新指定容器的长度为num</span></span><br><span class="line"><span class="comment">        若窨器变长,则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">        如果器变短,则末尾超出容器长度的元素被除。</span></span><br><span class="line"><span class="comment">3644list 赋值操作</span></span><br><span class="line"><span class="comment">        assign (beg,end);/将[beg,end)区阃中的数据拷贝賦值绐本身</span></span><br><span class="line"><span class="comment">        assign(n,elem);/将n个elem拷贝赋值给本身</span></span><br><span class="line"><span class="comment">        1ist&amp; operator=(const list&amp;1ist);/重载等号操作符</span></span><br><span class="line"><span class="comment">        swap(1ist);/将1st与本身的元素互换。</span></span><br><span class="line"><span class="comment">364.5 list数据的存取</span></span><br><span class="line"><span class="comment">        front();//返回第一个元素</span></span><br><span class="line"><span class="comment">        back();//返回最后一个元素</span></span><br><span class="line"><span class="comment">3.6.4.6 list反转排序</span></span><br><span class="line"><span class="comment">        reverse();//反转链表，比如list包含1，3，5 元素，运行此方法后，list包含5，3，1元素</span></span><br><span class="line"><span class="comment">        sort（）；//list 排序</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(_List_const_iterator&lt;<span class="keyword">int</span>&gt; it = L .<span class="built_in">begin</span>(); it != L .<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//list 是一个双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3(L2.<span class="built_in">begin</span>(),L2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">    L4.push_back(<span class="number">10</span>);</span><br><span class="line">    L4.push_back(<span class="number">20</span>);</span><br><span class="line">    L4.push_back(<span class="number">30</span>);</span><br><span class="line">    L4.push_front(<span class="number">100</span>);</span><br><span class="line">    L4.push_front(<span class="number">200</span>);</span><br><span class="line">    L4.push_front(<span class="number">300</span>);</span><br><span class="line">    L4.push_front(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">//正序打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L4.<span class="built_in">begin</span>();it!=L4.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//逆序打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = L4.rbegin();it != L4.rend();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    L4.insert(L4.<span class="built_in">begin</span>(),<span class="number">1000</span>);</span><br><span class="line">    printList(L4);</span><br><span class="line">    <span class="comment">//remove(elem)</span></span><br><span class="line">    L4.<span class="built_in">remove</span>(<span class="number">300</span>);<span class="comment">//凡是看见300都删除,删除的是所有与elem的 匹配元素</span></span><br><span class="line">    printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L;</span><br><span class="line">    L.push_back(<span class="number">10</span>);</span><br><span class="line">    L.push_back(<span class="number">20</span>);</span><br><span class="line">    L.push_back(<span class="number">30</span>);</span><br><span class="line">    L.push_front(<span class="number">100</span>);</span><br><span class="line">    L.push_front(<span class="number">200</span>);</span><br><span class="line">    L.push_front(<span class="number">300</span>);</span><br><span class="line">    L.push_front(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">    L2.assign(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    L2.assign(L.<span class="built_in">begin</span>(),L.<span class="built_in">end</span>());<span class="comment">//重新赋值</span></span><br><span class="line">    printList(L2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE FRONT ="</span>&lt;&lt;L2.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"THE Back ="</span>&lt;&lt;L2.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> v1 ,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L;</span><br><span class="line">    L.push_back(<span class="number">10</span>);</span><br><span class="line">    L.push_back(<span class="number">20</span>);</span><br><span class="line">    L.push_back(<span class="number">30</span>);</span><br><span class="line">    L.push_front(<span class="number">100</span>);</span><br><span class="line">    L.push_front(<span class="number">200</span>);</span><br><span class="line">    L.push_front(<span class="number">300</span>);</span><br><span class="line">    L.push_front(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">//反转(是质变）</span></span><br><span class="line">    L.reverse();</span><br><span class="line">    printList(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="comment">//所有系统提供的标准算法 使用的容器提供的迭代器都必须支持随机访问</span></span><br><span class="line">    <span class="comment">// 不知处随机访问的</span></span><br><span class="line">    L.sort();<span class="comment">//这是有用的,从小到大</span></span><br><span class="line"><span class="comment">//    sort(L.begin(),L.end());这是没用的</span></span><br><span class="line">    printList(L);</span><br><span class="line">    L.sort(myCompare);</span><br><span class="line">    printList(L);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name , <span class="keyword">int</span> age,<span class="keyword">int</span> <span class="built_in">height</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_height = <span class="built_in">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">    <span class="keyword">int</span> m_height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myComparePerson</span><span class="params">(Person &amp;P1 ,Person &amp;P2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按照年龄，升序</span></span><br><span class="line">    <span class="comment">//如果年龄相同 按照身高进行降序</span></span><br><span class="line">    <span class="keyword">if</span>(P1.m_Age==P2.m_Age)</span><br><span class="line">        <span class="keyword">return</span> P1.m_height&gt;P2.m_height;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> P1.m_Age &lt;P2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;Person&gt;L;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"大娃"</span>,<span class="number">30</span>,<span class="number">170</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"2娃"</span>,<span class="number">28</span>,<span class="number">190</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"3娃"</span>,<span class="number">26</span>,<span class="number">168</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"4娃"</span>,<span class="number">24</span>,<span class="number">187</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"5娃"</span>,<span class="number">24</span>,<span class="number">192</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">"6娃"</span>,<span class="number">24</span>,<span class="number">123</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p7</span><span class="params">(<span class="string">"7娃"</span>,<span class="number">20</span>,<span class="number">284</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p8</span><span class="params">(<span class="string">"爷爷"</span>,<span class="number">90</span>,<span class="number">154</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p9</span><span class="params">(<span class="string">"蛇精"</span>,<span class="number">999</span>,<span class="number">999</span>)</span></span>;</span><br><span class="line">    L.push_back(p1);</span><br><span class="line">    L.push_back(p2);</span><br><span class="line">    L.push_back(p3);</span><br><span class="line">    L.push_back(p4);</span><br><span class="line">    L.push_back(p5);</span><br><span class="line">    L.push_back(p6);</span><br><span class="line">    L.push_back(p7);</span><br><span class="line">    L.push_back(p8);</span><br><span class="line">    L.push_back(p9);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>();it!=L.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名  "</span>&lt;&lt;it-&gt;m_Name&lt;&lt;<span class="string">"年龄  "</span>&lt;&lt;it-&gt;m_Age&lt;&lt;<span class="string">" 身高 "</span>&lt;&lt;it-&gt;m_height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    L.sort(myComparePerson);<span class="comment">//自定义的数据要自己写排序规则</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>();it!=L.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"姓名  "</span>&lt;&lt;it-&gt;m_Name&lt;&lt;<span class="string">"年龄  "</span>&lt;&lt;it-&gt;m_Age&lt;&lt;<span class="string">" 身高 "</span>&lt;&lt;it-&gt;m_height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    test01();</span></span><br><span class="line"><span class="comment">//    test03();</span></span><br><span class="line"><span class="comment">//    test04();</span></span><br><span class="line">    test05();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>map容器</title>
    <url>/2020/04/22/map%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="map容器的基本操作"><a href="#map容器的基本操作" class="headerlink" title="map容器的基本操作"></a>map容器的基本操作</h1><p><img src="/2020/04/22/map%E5%AE%B9%E5%99%A8/1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3821map构造函数</span></span><br><span class="line"><span class="comment">        p&lt;T1,T2&gt; maptTT;//map默认构造函数:</span></span><br><span class="line"><span class="comment">        p( const map &amp;mp):/贝构造函数</span></span><br><span class="line"><span class="comment">* 3822map赋值操作</span></span><br><span class="line"><span class="comment">        map&amp; operator=(const map&amp;mp)://重载等号操作符</span></span><br><span class="line"><span class="comment">        swap(mp)://交换两个集合容器</span></span><br><span class="line"><span class="comment">* 3823map大小操作</span></span><br><span class="line"><span class="comment">        size();//返回容器中元素的数目</span></span><br><span class="line"><span class="comment">        empty();//判断容器是否为空</span></span><br><span class="line"><span class="comment">* 3824map插入数据元素操作</span></span><br><span class="line"><span class="comment">        map.insert(,,,)://往容器插入元素,返回 pair &lt;iterator,bool&gt;</span></span><br><span class="line"><span class="comment">        map&lt;int, string&gt; mapStu</span></span><br><span class="line"><span class="comment">        /第一种通过pair的方式插入对象</span></span><br><span class="line"><span class="comment">        mapStu insert(pair&lt;irt, string&gt;(3,"小张"));</span></span><br><span class="line"><span class="comment">        /第二种通过pair的方式插入对象</span></span><br><span class="line"><span class="comment">        mapStu insert( make_pair(-1,“校长”));</span></span><br><span class="line"><span class="comment">        /第三种通过 value type的方式插入对象</span></span><br><span class="line"><span class="comment">        mapStu insert(map &lt;int, string&gt;::value_type(1, "小李));</span></span><br><span class="line"><span class="comment">        /第四种通过数组的方式插入值</span></span><br><span class="line"><span class="comment">        mapStu[3] = "小刘";</span></span><br><span class="line"><span class="comment">        mapStu[5]=“小王";</span></span><br><span class="line"><span class="comment">* 3825map删除操作</span></span><br><span class="line"><span class="comment">        clear （）;//删除所有元素</span></span><br><span class="line"><span class="comment">        erase(pos):/刪除pos迭代器所指的元素,返回下一个元素的迭代器。4</span></span><br><span class="line"><span class="comment">        erase(beg,end);/删刪除区间[beg,md的所有元素,返回下一个元素的迭代器。</span></span><br><span class="line"><span class="comment">        erase (keyElem)://删除容器中key为keyE1em的对组</span></span><br><span class="line"><span class="comment">* 3826map查找操作</span></span><br><span class="line"><span class="comment">        find (key):/查找键key是否存在,着存在,返回该键的元素的迭代器;/若不存在,返回map.end()</span></span><br><span class="line"><span class="comment">        count (keyElem);//返回容器中key为 keyElem的对组个数。对map来说,要么是0,要么是1。对</span></span><br><span class="line"><span class="comment">        multimap来说,值可能大于1。</span></span><br><span class="line"><span class="comment">        lower_bound (keyElem)://回第一个key&gt;=KeyElem型m元素的迭代器。4e</span></span><br><span class="line"><span class="comment">        upper_bound (keyElem):/回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line"><span class="comment">        equal_range(keyElem):/返回吝器中key与keE1m相等的上下限的两个迭代器</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="comment">//插入方式</span></span><br><span class="line">    <span class="comment">//第一种</span></span><br><span class="line">    m.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    m.insert(make_pair(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">    <span class="comment">//第三种</span></span><br><span class="line">    m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    m[<span class="number">4</span>]=<span class="number">40</span>;</span><br><span class="line">    <span class="comment">//不建议用m[]= 进行赋值，除非进行访问操作，否则一旦误操作，会创建一个不存在的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"KEY = "</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" VALUE = "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">    m.insert(make_pair(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    m.erase(<span class="number">3</span>);<span class="comment">//key = 3 的被删除了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"KEY = "</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" VALUE = "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1&gt;v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt; m;</span><br><span class="line">    m.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">    m.insert(make_pair(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos!=m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" GOT IT key = "</span>&lt;&lt;(*pos).first&lt;&lt;<span class="string">"VALUE IS "</span>&lt;&lt;(*pos).second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = m.count(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"KET IS 4 ="</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">/*    lower_bound(keyElem)*/</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ret =  m.lower_bound(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"GOT IT! THE lower_bound 's key is :"</span>&lt;&lt;ret-&gt;first&lt;&lt;<span class="string">" VALUE IS "</span>&lt;&lt;ret-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"SORRY NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*upper_bound*/</span></span><br><span class="line">    ret = m.upper_bound(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"GOT IT! THE upper_bound 's key is :"</span>&lt;&lt;ret-&gt;first&lt;&lt;<span class="string">" VALUE IS "</span>&lt;&lt;ret-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"SORRY NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*equal_range */</span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator ,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator&gt;it2 = m.equal_range(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(it2.first!=m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"GOT IT! THE lower_bound 's key is :"</span>&lt;&lt;it2.first-&gt;first&lt;&lt;<span class="string">" VALUE IS "</span>&lt;&lt;it2.first-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"SORRY NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(it2.second!=m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"GOT IT! THE lower_bound 's key is :"</span>&lt;&lt;it2.second-&gt;first&lt;&lt;<span class="string">" VALUE IS "</span>&lt;&lt;it2.second-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"SORRY NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,Mycompare&gt; m;<span class="comment">//有大变小</span></span><br><span class="line">    m.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">    m.insert(make_pair(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">    m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>,<span class="number">30</span>));</span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"KEY = "</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" VALUE = "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    test02();</span></span><br><span class="line"><span class="comment">//    test01();</span></span><br><span class="line"><span class="comment">//    test03();</span></span><br><span class="line">test04();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab基础</title>
    <url>/2020/04/29/matlab%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Matlab命令使用"><a href="#Matlab命令使用" class="headerlink" title="Matlab命令使用"></a>Matlab命令使用</h1><ul>
<li>matlab是一个计算工具，也是一种编程语言</li>
</ul>
<h2 id="基本计算操作"><a href="#基本计算操作" class="headerlink" title="基本计算操作"></a>基本计算操作</h2><ul>
<li>+</li>
<li>-</li>
<li>*</li>
<li>%</li>
<li>^ 表示乘方， 5^2  五的二次方</li>
<li>log 代表的是自然对数 ln</li>
<li>log2 代表的是以2为底数的一个函数</li>
<li>log10 代表的是以10为底数的一个函数</li>
<li>想要计算其他的对数，用换底公式：log8 7=log(7)/log(8)</li>
</ul>
<h2 id="基本界面操作"><a href="#基本界面操作" class="headerlink" title="基本界面操作"></a>基本界面操作</h2><ul>
<li>clc 清空屏幕中的所有内容</li>
</ul>
<h2 id="variable-变量"><a href="#variable-变量" class="headerlink" title="variable 变量"></a>variable 变量</h2><ul>
<li>变量是暂时用来保存变量的地方</li>
</ul>
<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/1.png" alt></p>
<p>在工作区可以看出来现在表中有哪些变量</p>
<h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><ul>
<li>用x=[]表示一个数组/向量（vector）</li>
<li>x=[1,2,3] ;</li>
<li>y=[5,6,7];</li>
<li>x+y = [6,8,10];</li>
<li>如果x，y的维度不相同，那么x与y无法相加</li>
<li>通过用分号来实现矩阵中的换行</li>
<li>x= [1,2,3;4 5 6];实现的就是两行三列的矩阵</li>
<li><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/2.png" alt></li>
<li>做矩阵乘法，直接可以用AXB，但前提两个矩阵是要满足矩阵乘法的条件</li>
<li><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/3.png" alt></li>
<li>做矩阵的几次幂也可以直接用  ^  实现、</li>
</ul>
<h2 id="script-脚本"><a href="#script-脚本" class="headerlink" title="script 脚本"></a>script 脚本</h2><ul>
<li>新建脚本后，可以保存在一个固定的文件夹内，每当打开运行后，命令行窗口就会显示答案</li>
</ul>
<h4 id="几个小细节需要注意"><a href="#几个小细节需要注意" class="headerlink" title="几个小细节需要注意"></a>几个小细节需要注意</h4><ul>
<li>注意% 是单行注释；%{  %}是多行注释</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">7</span></span><br><span class="line">x+y </span><br><span class="line"><span class="comment">%注意，如果没有写分号的话，每一行都会输出ans值，等于每一行都认为你已经结束了操作</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">12</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; matlab</span><br><span class="line"></span><br><span class="line">x =</span><br><span class="line"></span><br><span class="line">     <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y =</span><br><span class="line"></span><br><span class="line">     <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">12</span></span><br><span class="line"><span class="comment">%上面的代码的运行结果就是这样   </span></span><br><span class="line"><span class="comment">%如果行末有分号的话，就不会输出ans值，但x,y 的值仍然存在且运算 ，只是不会显示，等于认为你还没有完成脚本的操作</span></span><br><span class="line"><span class="comment">%如果打了分号，我们还需要看x的值，只需要打入 x = 就可以了</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; matlab</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">12</span></span><br></pre></td></tr></table></figure>

<h4 id="同时，利用脚本我们还可以进行交互，比如说"><a href="#同时，利用脚本我们还可以进行交互，比如说" class="headerlink" title="同时，利用脚本我们还可以进行交互，比如说"></a>同时，利用脚本我们还可以进行交互，比如说</h4> <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 我在脚本里写了这句话以后，运行脚本，我们会得到以下结果</span></span><br><span class="line">x = input(<span class="string">'Please enter x:'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------结果----------------------------</span></span><br><span class="line">Please enter x:<span class="number">234</span></span><br><span class="line"></span><br><span class="line">x =</span><br><span class="line"></span><br><span class="line">   <span class="number">234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%也就是说，相当于C++中的 这种操作</span></span><br><span class="line">cout&lt;&lt;<span class="string">"Please enter x: "</span>;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">cout&lt;&lt;x;</span><br></pre></td></tr></table></figure>

<h4 id="现在我们用matlab脚本实现一个简单的相加函数"><a href="#现在我们用matlab脚本实现一个简单的相加函数" class="headerlink" title="现在我们用matlab脚本实现一个简单的相加函数"></a>现在我们用matlab脚本实现一个简单的相加函数</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%脚本内容</span></span><br><span class="line">x = input(<span class="string">'Please put in the x ;'</span>);</span><br><span class="line">y = input(<span class="string">'Please put in the y :'</span>);</span><br><span class="line">x+y</span><br><span class="line"><span class="comment">%这里我前两句用了分号，因为不想输出x的值，但是Please XXXXXXXX 仍然会显现</span></span><br><span class="line"><span class="comment">%如果打了分号，那么在Please put in the x ： 23 之后，会输出 x = 23；</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%运行内容</span></span><br><span class="line">&gt;&gt; add</span><br><span class="line">Please put in the x ;<span class="number">12</span></span><br><span class="line">Please put in the y :<span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">35</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-fprintf函数，可以实现输出，"><a href="#通过-fprintf函数，可以实现输出，" class="headerlink" title="通过 fprintf函数，可以实现输出，"></a>通过 fprintf函数，可以实现输出，</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% C to F</span></span><br><span class="line">C = input(<span class="string">'Please putin a temperature in Celsius : '</span>);</span><br><span class="line">F = (C*<span class="number">1.8</span>)+<span class="number">32</span>;</span><br><span class="line">fprintf(<span class="string">'Fahrenheit = %.1f\n'</span>,F);</span><br><span class="line"><span class="comment">%其中，保留位数的写法和C语言一样，在% 后，f前面打 .1 .2 等</span></span><br><span class="line"><span class="comment">% 换行符也一样 是\n</span></span><br><span class="line"><span class="comment">%如果不想要这么多0，可以把数据类型换成%g，这样只会保留整数与小数部分</span></span><br></pre></td></tr></table></figure>

<h4 id="通过if语句，可以进行判断-注意，判断条件不用（-）需要用end来表示范围"><a href="#通过if语句，可以进行判断-注意，判断条件不用（-）需要用end来表示范围" class="headerlink" title="通过if语句，可以进行判断,注意，判断条件不用（    ）需要用end来表示范围"></a>通过if语句，可以进行判断,注意，判断条件不用（    ）需要用end来表示范围</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">num = input(<span class="string">'Please enter a number : '</span>);</span><br><span class="line"><span class="keyword">if</span> num&gt;<span class="number">0</span></span><br><span class="line">    fprintf(<span class="string">'positive\n'</span>);</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    fprintf(<span class="string">'negative\n'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%如果 num = 0,怎么判断，可以用 elseif（无空格）进行多语句判断</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="sqrt-函数求平方根"><a href="#sqrt-函数求平方根" class="headerlink" title="sqrt 函数求平方根"></a>sqrt 函数求平方根</h4><h4 id="display函数，可以自动加-n"><a href="#display函数，可以自动加-n" class="headerlink" title="display函数，可以自动加\n"></a>display函数，可以自动加\n</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line">&gt;&gt; <span class="built_in">disp</span>(a);</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">    <span class="comment">%----------------------------------</span></span><br><span class="line">&gt;&gt; <span class="built_in">disp</span>([<span class="string">'apple'</span>,<span class="string">'banana'</span>,<span class="string">'orange'</span>]);</span><br><span class="line">applebananaorange</span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">&gt;&gt; <span class="built_in">disp</span>([<span class="string">'apple '</span>,<span class="string">'banana '</span>,<span class="string">'orange '</span>]);</span><br><span class="line">apple banana orange </span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">fr1 = <span class="string">'apple'</span>;</span><br><span class="line">fr2 = <span class="string">'banana'</span>;</span><br><span class="line">fr3 = <span class="string">'orange'</span>;</span><br><span class="line"><span class="built_in">disp</span>([fr1,<span class="string">' '</span>,fr2,<span class="string">' '</span>,fr3]);</span><br></pre></td></tr></table></figure>

<h4 id="循环可以用while-同样的-不需要（-）-需要用end来表示循环范围"><a href="#循环可以用while-同样的-不需要（-）-需要用end来表示循环范围" class="headerlink" title="循环可以用while 同样的 不需要（    ）,需要用end来表示循环范围"></a>循环可以用while 同样的 不需要（    ）,需要用end来表示循环范围</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 比如计算1 加到100；</span></span><br><span class="line"> <span class="built_in">i</span>  = <span class="number">1</span>;</span><br><span class="line"> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;=<span class="number">100</span>;</span><br><span class="line">	sum = sum+<span class="built_in">i</span>;</span><br><span class="line">	<span class="built_in">i</span> = <span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">	<span class="built_in">disp</span>(sum);</span><br></pre></td></tr></table></figure>

<h4 id="不等于在matlab中为"><a href="#不等于在matlab中为" class="headerlink" title="不等于在matlab中为~="></a>不等于在matlab中为~=</h4><h4 id="求余数在matlab中为mod函数"><a href="#求余数在matlab中为mod函数" class="headerlink" title="求余数在matlab中为mod函数"></a>求余数在matlab中为mod函数</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = input(<span class="string">'X is : '</span>);</span><br><span class="line">y = input(<span class="string">'Y is : '</span>);</span><br><span class="line"> <span class="comment">%辗转相除法求最大公约数</span></span><br><span class="line">temp =<span class="built_in">mod</span>(x,y);</span><br><span class="line"><span class="keyword">while</span> temp~=<span class="number">0</span></span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">    temp =  <span class="built_in">mod</span>(x,y);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">fprintf (<span class="string">'最大公约数是 %g\n'</span>,y);</span><br></pre></td></tr></table></figure>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">-5</span>:<span class="number">5</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">%如果中间的量不写，那么默认步长为1，既从小加到大</span></span><br><span class="line"><span class="comment">%如果中间的步长可正可以负，也可以为小数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">5</span>:<span class="number">-1</span>:<span class="number">-5</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%上面就是 步长为-1的情况</span></span><br><span class="line"></span><br><span class="line">v = [<span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> =v</span><br><span class="line">	<span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span>	</span><br><span class="line"><span class="comment">%这就相当于i 遍历v数组</span></span><br></pre></td></tr></table></figure>

<h4 id="sum（x-函数求和"><a href="#sum（x-函数求和" class="headerlink" title="sum（x) 函数求和"></a>sum（x) 函数求和</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">v = [<span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">sum(<span class="built_in">disp</span>(v));</span><br></pre></td></tr></table></figure>



<h2 id="matlab-画图功能"><a href="#matlab-画图功能" class="headerlink" title="matlab 画图功能"></a>matlab 画图功能</h2><h3 id="plot-函数-plot-x-y"><a href="#plot-函数-plot-x-y" class="headerlink" title="plot 函数 plot(x,y)"></a>plot 函数 plot(x,y)</h3><ul>
<li>注意，x，y不止两个数，而是两组数据，比如说</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&gt;&gt; y = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(x,y)</span><br><span class="line"><span class="comment">%画图的时候会一一对应，2-4；3-5；4-6；</span></span><br><span class="line"><span class="comment">%如果把y 改成了[4,6,7]</span></span><br><span class="line"><span class="comment">%plot(x,y)就变成了一条折线了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，在画曲线的时候注意的小细节</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x = <span class="number">-10</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">&gt;&gt; y = x.^<span class="number">2</span>;</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(x,y)</span><br><span class="line">&gt;&gt; y = x^<span class="number">2</span>;</span><br><span class="line">错误使用  ^  (line <span class="number">51</span>)</span><br><span class="line">用于对矩阵求幂的维度不正确。请检查并确保矩阵为方阵并且幂为</span><br><span class="line">标量。要执行按元素矩阵求幂，请使用 <span class="string">'.^ </span></span><br><span class="line"><span class="string">% 是一个方阵，矩阵求幂需要 点乘 用 y = x.*x 或者y = x.^2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------------------------------------------------------</span></span><br><span class="line"><span class="string">&gt;&gt;  x = -10:0.1:10;</span></span><br><span class="line"><span class="string">&gt;&gt; y = x.^2;</span></span><br><span class="line"><span class="string">&gt;&gt; plot(x,y,'</span>green-o')</span><br><span class="line"><span class="comment">%这个-o的作用就是说，每个点用一圈把他标出来</span></span><br><span class="line"><span class="comment">% green其实是线的颜色</span></span><br><span class="line">-------------------------------------------------</span><br></pre></td></tr></table></figure>

<h5 id="axis-equal-命令是让x，y的单位长度相等"><a href="#axis-equal-命令是让x，y的单位长度相等" class="headerlink" title="axis equal 命令是让x，y的单位长度相等"></a>axis equal 命令是让x，y的单位长度相等</h5><h4 id="bar-函数画柱状图"><a href="#bar-函数画柱状图" class="headerlink" title="bar 函数画柱状图"></a>bar 函数画柱状图</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; y = [<span class="number">76</span>,<span class="number">29</span>,<span class="number">378</span>,<span class="number">012</span>,<span class="number">182</span>,<span class="number">2870</span>];</span><br><span class="line">&gt;&gt;  x = <span class="number">2000</span>:<span class="number">2005</span>;</span><br><span class="line">&gt;&gt; bar(x,y)</span><br><span class="line"><span class="comment">%这样画出来的图像就是以x为下标，y为柱值得柱状图</span></span><br><span class="line"><span class="comment">%如果不写x，直接写bar（y)下标从1开始递增</span></span><br></pre></td></tr></table></figure>

<h3 id="三维图像的操作"><a href="#三维图像的操作" class="headerlink" title="三维图像的操作"></a>三维图像的操作</h3><h4 id="基本函数和美观工具"><a href="#基本函数和美观工具" class="headerlink" title="基本函数和美观工具"></a>基本函数和美观工具</h4><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/4.png" alt></p>
<h5 id="shading指令"><a href="#shading指令" class="headerlink" title="shading指令"></a>shading指令</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/5.png" alt></p>
<h5 id="colormap指令"><a href="#colormap指令" class="headerlink" title="colormap指令"></a>colormap指令</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/6.png" alt></p>
<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/7.png" alt></p>
<h5 id="light光照指令"><a href="#light光照指令" class="headerlink" title="light光照指令"></a>light光照指令</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/8.png" alt></p>
<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/9.png" alt></p>
<h6 id="指定光照算法"><a href="#指定光照算法" class="headerlink" title="指定光照算法"></a>指定光照算法</h6><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/10.png" alt></p>
<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/11.png" alt></p>
<h5 id="camlight-相机光照"><a href="#camlight-相机光照" class="headerlink" title="camlight 相机光照"></a>camlight 相机光照</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/12.png" alt></p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">close all;clear all;clc</span><br><span class="line">[x,y,z] = sphere;</span><br><span class="line">colormap(jet)</span><br><span class="line">surf(x,y,z)</span><br><span class="line">shading interp</span><br><span class="line">axis equal</span><br><span class="line">camlight</span><br><span class="line">lighting phong</span><br><span class="line"><span class="comment">% 下面是效果图</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/D:%5Cprojects%5Cmatlab%E7%AC%94%E8%AE%B0%5Ccamlight%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="camlight效果图"></p>
<h5 id="材质-反射属性"><a href="#材质-反射属性" class="headerlink" title="材质-反射属性"></a>材质-反射属性</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/13.png" alt></p>
<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/14.png" alt></p>
<h5 id="图形填充"><a href="#图形填充" class="headerlink" title="图形填充"></a>图形填充</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/15.png" alt></p>
<h4 id="三维曲线"><a href="#三维曲线" class="headerlink" title="三维曲线"></a>三维曲线</h4><ul>
<li>下面实现一个绕z轴上升的螺旋线</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% x取 0 - 6pi 其实就是 三圈</span></span><br><span class="line">&gt;&gt; theta = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">6</span>*<span class="built_in">pi</span>;</span><br><span class="line">&gt;&gt; x = <span class="built_in">cos</span>(theta);</span><br><span class="line">&gt;&gt; y = <span class="built_in">sin</span>(theta);</span><br><span class="line">&gt;&gt; <span class="comment">% z也要取301个点，和x,y 搭配</span></span><br><span class="line">&gt;&gt; z = <span class="number">0</span>:<span class="number">300</span>;</span><br><span class="line">&gt;&gt; <span class="built_in">plot3</span>(x,y,z)</span><br></pre></td></tr></table></figure>

<h4 id="三维曲面"><a href="#三维曲面" class="headerlink" title="三维曲面"></a>三维曲面</h4><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/16.png" alt></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%上图是莫比乌斯圈</span></span><br><span class="line">clc;clear;close all;</span><br><span class="line">k = <span class="number">50</span>;</span><br><span class="line">u = <span class="number">0</span>:<span class="built_in">pi</span>/k:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">v = [<span class="number">-1</span>,<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(v)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(u)</span><br><span class="line">        x(<span class="built_in">i</span>,<span class="built_in">j</span>) = (<span class="number">1</span>+v(<span class="built_in">j</span>)*<span class="built_in">cos</span>(u(<span class="built_in">i</span>)/<span class="number">2</span>)/<span class="number">2</span>)*<span class="built_in">cos</span>(u(<span class="built_in">i</span>));</span><br><span class="line">        y(<span class="built_in">i</span>,<span class="built_in">j</span>) = (<span class="number">1</span>+v(<span class="built_in">j</span>)*<span class="built_in">cos</span>(u(<span class="built_in">i</span>)/<span class="number">2</span>)/<span class="number">2</span>)*<span class="built_in">sin</span>(u(<span class="built_in">i</span>));</span><br><span class="line">        z(<span class="built_in">i</span>,<span class="built_in">j</span>) = v(<span class="built_in">j</span>)*<span class="built_in">sin</span>(u(<span class="built_in">i</span>)/<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">surf(x,y,z)</span><br><span class="line"><span class="comment">%如果想去掉网格线，可以加上shading flat</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/20.png" alt></p>
<h5 id="旋转柱面函数"><a href="#旋转柱面函数" class="headerlink" title="旋转柱面函数"></a>旋转柱面函数</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/17.png" alt></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%上面是旋转正弦曲面，</span></span><br><span class="line">close all;clear all;clc</span><br><span class="line">x = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">20</span>:<span class="built_in">pi</span>*<span class="number">3</span>;</span><br><span class="line">r = <span class="number">5</span>+<span class="built_in">cos</span>(x);<span class="comment">%半径</span></span><br><span class="line"><span class="comment">%cylinder中r为半径，60为网格数</span></span><br><span class="line">[a,b,c] = cylinder(r,<span class="number">60</span>);</span><br><span class="line"><span class="comment">%如果直接写cylinder(r)那么就是默认20格子</span></span><br><span class="line">mesh(a,b,c)</span><br><span class="line"><span class="comment">%可以通过引入颜色图来美观化</span></span><br><span class="line">surf(a,b,c)</span><br><span class="line">shading interp</span><br><span class="line">colormap(jet)</span><br><span class="line"><span class="comment">%效果如下</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/18.png" alt></p>
<h5 id="旋转球面函数-sphere"><a href="#旋转球面函数-sphere" class="headerlink" title="旋转球面函数 sphere"></a>旋转球面函数 sphere</h5><p><img src="/2020/04/29/matlab%E5%9F%BA%E7%A1%80/19.png" alt></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[x,y,z] = sphere;</span><br><span class="line">mesh(x,y,z)</span><br><span class="line">shading interp</span><br><span class="line">axis equal</span><br><span class="line"><span class="comment">% mesh是网格线，surf是面，无网格线</span></span><br><span class="line"><span class="comment">%可以通过colormap（）来美观球面</span></span><br><span class="line"><span class="comment">%sphere(n)中的n为网格数，可改边网格的疏密程度</span></span><br></pre></td></tr></table></figure>

<h4 id="立体图形的绘制"><a href="#立体图形的绘制" class="headerlink" title="立体图形的绘制"></a>立体图形的绘制</h4><h5 id="绘制正方体-利用patch函数"><a href="#绘制正方体-利用patch函数" class="headerlink" title="绘制正方体 - 利用patch函数"></a>绘制正方体 - 利用patch函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vertices = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">faces=[<span class="number">1</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span>;<span class="number">2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">6</span>;<span class="number">3</span> <span class="number">4</span>  <span class="number">8</span> <span class="number">7</span>; <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">8</span>;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>;<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">    h = patch(vertices(faces(i,:),<span class="number">1</span>),vertices(faces(i,:),<span class="number">2</span>),vertices(faces(i,:),<span class="number">3</span>),<span class="string">'g'</span>);</span><br><span class="line"><span class="built_in">end</span></span><br><span class="line">axis equal</span><br><span class="line">colormap(jet)</span><br><span class="line">view(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<h4 id="动画制作"><a href="#动画制作" class="headerlink" title="动画制作"></a>动画制作</h4><h5 id="项目1-动态正弦曲线"><a href="#项目1-动态正弦曲线" class="headerlink" title="项目1 动态正弦曲线"></a>项目1 动态正弦曲线</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X= <span class="number">-2</span>*<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">Y = <span class="built_in">sin</span>(X);</span><br><span class="line">h = <span class="built_in">plot</span>(X,Y);<span class="comment">%把整条曲线全部保存</span></span><br><span class="line"><span class="comment">%现在这个曲线只有两个周期，并没有移动</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">1000</span> </span><br><span class="line">    X = X+<span class="number">0.01</span>;</span><br><span class="line">    Y = <span class="built_in">sin</span>(X);</span><br><span class="line">    set(h,<span class="string">'XData'</span>,X,<span class="string">'YData'</span>,Y)</span><br><span class="line">    drawnow;</span><br><span class="line"><span class="comment">% 往右移动1000次，每次移动0.01个单位</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%如果不想让他停下来，可以 </span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">true</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%动画原理，，让原来的图像全部向右边移动一一个距离，再在图中画出来</span></span><br></pre></td></tr></table></figure>

<h5 id="项目2-动态弹簧曲线"><a href="#项目2-动态弹簧曲线" class="headerlink" title="项目2 动态弹簧曲线"></a>项目2 动态弹簧曲线</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">theta = <span class="number">-10</span>*<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="number">10</span>*<span class="built_in">pi</span>;</span><br><span class="line">X = <span class="built_in">cos</span>(theta);</span><br><span class="line">Y = <span class="built_in">sin</span>(theta);</span><br><span class="line">Z = theta;</span><br><span class="line">h = <span class="built_in">plot3</span>(X,Y,Z);</span><br><span class="line"><span class="comment">%X,Y不需要动，只需要动Z的长度</span></span><br><span class="line">axis([<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-10</span>*<span class="built_in">pi</span>,<span class="number">10</span>*<span class="built_in">pi</span>]);<span class="comment">%固定坐标轴的单位</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">true</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">100</span> </span><br><span class="line">    Z = <span class="number">0.98</span>*Z;</span><br><span class="line">    set(h,<span class="string">'XData'</span>,X,<span class="string">'YData'</span>,Y,<span class="string">'ZData'</span>,Z);</span><br><span class="line">    drawnow</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">100</span> </span><br><span class="line">    Z = Z/<span class="number">0.98</span>;</span><br><span class="line">    set(h,<span class="string">'XData'</span>,X,<span class="string">'YData'</span>,Y,<span class="string">'ZData'</span>,Z);</span><br><span class="line">    drawnow</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="项目3-时钟模型"><a href="#项目3-时钟模型" class="headerlink" title="项目3 时钟模型"></a>项目3 时钟模型</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">X = <span class="built_in">cos</span>(t);</span><br><span class="line">Y = <span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(X,Y);</span><br><span class="line">axis equal;</span><br><span class="line"><span class="comment">%hold on 命令是为了下面两张图不覆盖</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">lineX = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">lineY= [<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line"><span class="comment">%这里的lineX ，lineY不是点，是映射，0-0，1-0，lineX代表x轴，lineY代表y轴，所以是(0,0),(1,0)两个点相连接，接下来该的也是改(1,0)这两个坐标的值</span></span><br><span class="line">h = <span class="built_in">plot</span>(lineX,lineY);</span><br><span class="line">theta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">true</span></span><br><span class="line">    theta = theta+<span class="number">0.01</span>;</span><br><span class="line">    lineX(<span class="number">2</span>) = <span class="built_in">cos</span>(theta);</span><br><span class="line">    lineY(<span class="number">2</span>) = <span class="built_in">sin</span>(theta);</span><br><span class="line">    set(h,<span class="string">'XData'</span>,lineX,<span class="string">'YData'</span>,lineY);</span><br><span class="line">    drawnow;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>pyspider框架</title>
    <url>/2020/05/07/pyspider%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="pyspider框架"><a href="#pyspider框架" class="headerlink" title="pyspider框架"></a>pyspider框架</h1><h2 id="安装使用pyspider框架遇到的麻烦"><a href="#安装使用pyspider框架遇到的麻烦" class="headerlink" title="安装使用pyspider框架遇到的麻烦"></a>安装使用pyspider框架遇到的麻烦</h2><p><a href="https://blog.csdn.net/weixin_43963656/article/details/90317441" target="_blank" rel="noopener">基本上他遇到的错误我都遇到了</a></p>
<ol>
<li>我的python版本是3.8，但是很显然pyspider的作者根本没想把pyspider与py38兼容，出现了关键字冲突的问题，对于那个人说修改run.py文件中的asnyc关键字，我改了也没luan用。最后装了3.6，真香</li>
<li>其次就是他说的WsgiDAV新版本版本和当前不兼容的问题，也是按照他说的降低版本解决了问题</li>
<li>昨晚运行的好好的，今天再次运行出现了DNS链接上的问题，难道dns被封了？<ol>
<li>我换了一个文件夹运行pyspider all，输入一样的代码运行后。问题解决了</li>
</ol>
</li>
</ol>
<p>最后输入pyspider all,奇迹出现</p>
<p><img src="/2020/05/07/pyspider%E6%A1%86%E6%9E%B6/1.png" alt></p>
<p><img src="/2020/05/07/pyspider%E6%A1%86%E6%9E%B6/2.png" alt></p>
<h3 id="利用pyspider框架爬取网站"><a href="#利用pyspider框架爬取网站" class="headerlink" title="利用pyspider框架爬取网站"></a>利用pyspider框架爬取网站</h3><ul>
<li>我们这次选的是TripAdvisor网站</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>python基本语法</title>
    <url>/2020/04/29/python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="python-基本语法，随便上了个课"><a href="#python-基本语法，随便上了个课" class="headerlink" title="python 基本语法，随便上了个课"></a>python 基本语法，随便上了个课</h1><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if语句</span></span><br><span class="line">age = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> age&gt;<span class="number">16</span>:</span><br><span class="line">    print(<span class="string">'可以进入'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'禁止进入'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="if-elif-else-语句"><a href="#if-elif-else-语句" class="headerlink" title="if-elif-else 语句"></a>if-elif-else 语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if-elif-else 语句</span></span><br><span class="line">score = <span class="number">50</span></span><br><span class="line"><span class="keyword">if</span> score&gt;=<span class="number">90</span>:</span><br><span class="line">    print(<span class="string">'A'</span>)</span><br><span class="line"><span class="keyword">elif</span> score&gt;=<span class="number">80</span>:</span><br><span class="line">    print(<span class="string">'B'</span>)</span><br><span class="line"><span class="keyword">elif</span> score&gt;=<span class="number">70</span>:</span><br><span class="line">    print(<span class="string">'C'</span>)</span><br><span class="line"><span class="keyword">elif</span> score&gt;=<span class="number">60</span>:</span><br><span class="line">    print(<span class="string">'D'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'不通过'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="for-和while"><a href="#for-和while" class="headerlink" title="for 和while"></a>for 和while</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for 遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):<span class="comment"># 不包括10</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># while 遍历</span></span><br><span class="line">n=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n&lt;<span class="number">10</span>:</span><br><span class="line">    print(n)</span><br><span class="line">    n=n+<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'循环结束'</span>)</span><br><span class="line"><span class="comment"># for循环嵌套</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 默认是换行结束的,这里告诉他end=' '以空格结束</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;i&#125;</span>*<span class="subst">&#123;j&#125;</span>=<span class="subst">&#123;i*j&#125;</span>'</span>,end=<span class="string">' '</span>)</span><br><span class="line">    print()<span class="comment"># 换行,</span></span><br><span class="line"><span class="comment"># while嵌套</span></span><br><span class="line">n=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n&lt;<span class="number">10</span>:</span><br><span class="line">    m=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>  m&lt;=n:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;n&#125;</span>*<span class="subst">&#123;m&#125;</span>=<span class="subst">&#123;n * m&#125;</span>'</span>, end=<span class="string">' '</span>)</span><br><span class="line">        m=m+<span class="number">1</span></span><br><span class="line">    n=n+<span class="number">1</span></span><br><span class="line">    print()</span><br><span class="line"><span class="comment"># while 和for 是可以混合使用的</span></span><br></pre></td></tr></table></figure>

<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># break</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = input(<span class="string">'输入：（0）退出：'</span>)</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">'0'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'您输入的是'</span>,s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># continue</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">'python'</span>:</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">'y'</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(s,end=<span class="string">''</span>)</span><br><span class="line"><span class="comment"># 猜数字    </span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">target = random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">3</span>:</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    n =int(input(<span class="string">'请猜想一个1-100的整数'</span>))</span><br><span class="line">    <span class="keyword">if</span> n&gt;target:</span><br><span class="line">        print(<span class="string">'猜大了'</span>)</span><br><span class="line">    <span class="keyword">elif</span> n&lt;target:</span><br><span class="line">        print(<span class="string">'猜小了'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'猜对了'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">'傻逼，猜了三次都没对'</span>)</span><br><span class="line">print(<span class="string">'傻逼，猜了三次都没对'</span>)</span><br><span class="line">print(<span class="string">'傻逼，猜了三次都没对'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line"><span class="comment"># 1.单引号或者双引号</span></span><br><span class="line"><span class="comment"># 2.单三引号或者双三引号</span></span><br><span class="line">print(<span class="string">'''</span></span><br><span class="line"><span class="string">我</span></span><br><span class="line"><span class="string">是</span></span><br><span class="line"><span class="string">你</span></span><br><span class="line"><span class="string">爹</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"><span class="comment"># 转义字符</span></span><br><span class="line">print(<span class="string">'这里\n\n\n\n\n\n\n有好几个换行'</span>)</span><br><span class="line">print(<span class="string">'这里\t\t\t\t有好几个tab键'</span>)</span><br><span class="line"><span class="comment"># 字符串索引</span></span><br><span class="line">s = <span class="string">'床前明月光'</span></span><br><span class="line">print(s[<span class="number">0</span>])</span><br><span class="line">print(s[<span class="number">1</span>])</span><br><span class="line">print(s[<span class="number">2</span>])</span><br><span class="line">print(s[<span class="number">3</span>])</span><br><span class="line">print(s[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 负的索引,即右往左遍历</span></span><br><span class="line">print(s[<span class="number">-1</span>])</span><br><span class="line">print(s[<span class="number">-2</span>])</span><br><span class="line">print(s[<span class="number">-3</span>])</span><br><span class="line">print(s[<span class="number">-4</span>])</span><br><span class="line">print(s[<span class="number">-5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串切片</span></span><br><span class="line"><span class="comment"># 'string'.[begin:end:pace]默认步长为1</span></span><br><span class="line">s = <span class="string">'床前明月光！'</span></span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 从1开始到结尾</span></span><br><span class="line">print(s[<span class="number">1</span>:])</span><br><span class="line"><span class="comment"># 从开始到这里</span></span><br><span class="line">print(s[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出 format()</span></span><br><span class="line">user_1 = <span class="string">'韩梅梅'</span></span><br><span class="line">user_2 = <span class="string">'李雷'</span></span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;user_1&#125;</span>对<span class="subst">&#123;user_2&#125;</span>说:hello,傻逼'</span>)</span><br><span class="line"><span class="comment"># + 号连接多个字符串</span></span><br><span class="line">print(<span class="string">'are'</span>+<span class="string">' you'</span>+<span class="string">' ok'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表</span></span><br><span class="line"><span class="comment"># 可以直接通过列表索引修改元素</span></span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>,<span class="string">'awserq3'</span>,<span class="number">1.3</span>]</span><br><span class="line">my_list.pop(<span class="number">1</span>)<span class="comment"># 把my_list[i]出列</span></span><br><span class="line">my_list.pop()<span class="comment"># 把my_list最后一个元素出列</span></span><br><span class="line">my_list.remove(<span class="string">'a'</span>)<span class="comment"># 直接把a这个元素移除</span></span><br><span class="line">my_list.append(<span class="number">222</span>)<span class="comment"># 添加元素，加到队尾</span></span><br><span class="line">my_list.append(<span class="string">'python'</span>)<span class="comment"># 添加元素，加到队尾</span></span><br><span class="line">my_list.insert(<span class="number">2</span>,<span class="string">'java'</span>)<span class="comment"># 现在my_list[2]就是java</span></span><br><span class="line">my_list.extend(<span class="string">'CPP'</span>)<span class="comment"># 把字符串 按位拆开插入尾部</span></span><br><span class="line">my_list.extend(<span class="string">'6789'</span>)<span class="comment"># 直接6789 的话是不行的。不可迭代</span></span><br><span class="line">my_list.extend([<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>])<span class="comment"># 直接6789 的话是不行的。不可迭代</span></span><br><span class="line">print(my_list)</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 元组，（不可变的列表）用小括号</span></span><br><span class="line">my_list = (<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>,<span class="number">1.2</span>)</span><br><span class="line">my_list[<span class="number">2</span>]=<span class="number">22</span></span><br><span class="line"><span class="comment"># 这样是会报错的</span></span><br></pre></td></tr></table></figure>

<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典&#123;&#125;</span></span><br><span class="line"><span class="comment"># 键值对 key-&gt;value</span></span><br><span class="line">user = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'Tom'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">print(user)</span><br><span class="line">user[<span class="string">'age'</span>] = <span class="number">28</span></span><br><span class="line">print(user[<span class="string">'age'</span>])</span><br><span class="line">user[<span class="string">'inte'</span>] = <span class="string">'打篮球'</span></span><br><span class="line">print(user)</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>def是关键词</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(n,m)</span>:</span></span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n&lt;=m:</span><br><span class="line">        s+=n</span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">print(sum(<span class="number">1</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件读取</span></span><br><span class="line">f = open(<span class="string">'sb.txt'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 文件写入</span></span><br><span class="line">f = open(<span class="string">'sb.txt'</span>,encoding=<span class="string">'utf-8'</span>,mode=<span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'keke'</span>)<span class="comment"># 会替换原来的内容</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h3 id="python第三方库"><a href="#python第三方库" class="headerlink" title="python第三方库"></a>python第三方库</h3><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类和对象：面向对象 编程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sex,birthday)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.birthday = birthday</span><br><span class="line"><span class="comment"># self 相当于js中的this</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self,word)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self.name&#125;</span>说："<span class="subst">&#123;word&#125;</span>"'</span>)</span><br><span class="line"></span><br><span class="line">zhang_San = Person(<span class="string">'张三'</span>,<span class="string">'male'</span>,<span class="string">'2001'</span>)</span><br><span class="line">li_si = Person(<span class="string">'李四'</span>,<span class="string">'male'</span>,<span class="string">'2000'</span>)</span><br><span class="line">zhang_San.say(<span class="string">"我是你爹"</span>)</span><br><span class="line">li_si = Person(<span class="string">"GUN!!"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="学生系统"><a href="#学生系统" class="headerlink" title="学生系统"></a>学生系统</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">10195501423</span>,</span><br><span class="line">        <span class="string">'name'</span>:<span class="string">'Jason'</span>,</span><br><span class="line">        <span class="string">'sex'</span>:<span class="string">'Male'</span>,</span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'浙江'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">10195501424</span>,</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'keke'</span>,</span><br><span class="line">        <span class="string">'sex'</span>: <span class="string">'Male'</span>,</span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'上海'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">10195501425</span>,</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'feifei'</span>,</span><br><span class="line">        <span class="string">'sex'</span>: <span class="string">'Male'</span>,</span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'上海'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="number">10195501426</span>,</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'弘弘'</span>,</span><br><span class="line">        <span class="string">'sex'</span>: <span class="string">'Male'</span>,</span><br><span class="line">        <span class="string">'address'</span>: <span class="string">'浙江'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 美化显示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beautify_print</span> <span class="params">(data_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index,student <span class="keyword">in</span> enumerate(data_list):</span><br><span class="line">        print(<span class="string">f'序号：<span class="subst">&#123;index+<span class="number">1</span>&#125;</span>'</span>,end=<span class="string">'\t'</span>)</span><br><span class="line">        print(<span class="string">f'ID：<span class="subst">&#123;student[<span class="string">"id"</span>]&#125;</span>'</span>,end=<span class="string">'\t'</span>)</span><br><span class="line">        print(<span class="string">f'姓名：<span class="subst">&#123;student[<span class="string">"name"</span>]&#125;</span>'</span>,end=<span class="string">'\t'</span>)</span><br><span class="line">        print(<span class="string">f'性别：<span class="subst">&#123;student[<span class="string">"sex"</span>]&#125;</span>'</span>,end=<span class="string">'\t'</span>)</span><br><span class="line">        print(<span class="string">f'地址：<span class="subst">&#123;student[<span class="string">"address"</span>]&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># 控制输入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_name</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name = input(<span class="string">'输入学生姓名：'</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> name:</span><br><span class="line">            <span class="keyword">return</span> name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择性别</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_sex</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'1.(Male)||2.(Female)'</span>)</span><br><span class="line">        n = input(<span class="string">'Choose The Gender'</span>)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Male'</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="string">'2'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Female'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#    1. 显示所有学生信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all</span><span class="params">()</span>:</span></span><br><span class="line">    beautify_print(data)</span><br><span class="line"><span class="comment">#    2. 新建所有学生信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_student</span><span class="params">()</span>:</span></span><br><span class="line">    id = input(<span class="string">'输入学生id：'</span>)</span><br><span class="line">    name = input_name()</span><br><span class="line">    sex = choose_sex()</span><br><span class="line">    address = input(<span class="string">'输入学生地址：'</span>)</span><br><span class="line">    student = &#123;</span><br><span class="line">        <span class="string">'id'</span> : id,</span><br><span class="line">        <span class="string">'name'</span> : name,</span><br><span class="line">        <span class="string">'sex'</span>:sex,</span><br><span class="line">        <span class="string">'address'</span>:address</span><br><span class="line">    &#125;</span><br><span class="line">    data.append(student)</span><br><span class="line"><span class="comment">#    3. 查询所有学生信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_student</span><span class="params">()</span>:</span></span><br><span class="line">    name = input(<span class="string">'查询学生的姓名：'</span>)</span><br><span class="line">    <span class="keyword">for</span> student <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> student[<span class="string">'name'</span>] == name:</span><br><span class="line">            print(<span class="string">f'查到学生<span class="subst">&#123;name&#125;</span>：<span class="subst">&#123;student&#125;</span>'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        print(<span class="string">'查无此人'</span>)</span><br><span class="line"><span class="comment">#    4. 修改学生信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_student</span><span class="params">()</span>:</span></span><br><span class="line">    name = input(<span class="string">'查询学生的姓名：'</span>)</span><br><span class="line">    <span class="keyword">for</span> student <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> student[<span class="string">'name'</span>] == name:</span><br><span class="line">            print(<span class="string">f'查到学生<span class="subst">&#123;name&#125;</span>：<span class="subst">&#123;student&#125;</span>'</span>)</span><br><span class="line">            student[<span class="string">'id'</span>] = input(<span class="string">'输入id：'</span>)</span><br><span class="line">            student[<span class="string">'name'</span>] = input(<span class="string">'输入名字：'</span>)</span><br><span class="line">            student[<span class="string">'sex'</span>] = input(<span class="string">'输入性别：'</span>)</span><br><span class="line">            student[<span class="string">'address'</span>] = input(<span class="string">'输入性别：'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'查无此人'</span>)</span><br><span class="line"><span class="comment">#    5. 删除 学生信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_student</span><span class="params">()</span>:</span></span><br><span class="line">    name = input(<span class="string">'要删除的学生的姓名：'</span>)</span><br><span class="line">    <span class="keyword">for</span> student <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> student[<span class="string">'name'</span>] == name:</span><br><span class="line">            print(student)</span><br><span class="line">            data.remove(student)</span><br><span class="line">            print(<span class="string">'已经被删除了'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'查无此人'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'''</span></span><br><span class="line"><span class="string">    *************************</span></span><br><span class="line"><span class="string">    1. 显示所有学生信息</span></span><br><span class="line"><span class="string">    2. 新建学生信息</span></span><br><span class="line"><span class="string">    3. 查询学生信息</span></span><br><span class="line"><span class="string">    4. 修改学生信息</span></span><br><span class="line"><span class="string">    5. 删除学生信息</span></span><br><span class="line"><span class="string">    0，退出系统</span></span><br><span class="line"><span class="string">    ************************* </span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line">    op = input(<span class="string">'请输入序号：'</span>)<span class="comment"># input输入的都是字符串</span></span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">'1'</span>:</span><br><span class="line">        show_all()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'2'</span>:</span><br><span class="line">        create_student()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'3'</span>:</span><br><span class="line">        find_student()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'4'</span>:</span><br><span class="line">        modify_student()</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'5'</span>:</span><br><span class="line">        remove_student()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>queue容器</title>
    <url>/2020/04/22/queue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue 没有迭代器</span></span><br><span class="line"><span class="comment">3.5.3.1 queue构造函数</span></span><br><span class="line"><span class="comment">        queue&lt;T&gt;queT:// queue采用模板类实现, queue对象的默认构造形式</span></span><br><span class="line"><span class="comment">        queue( const queue&amp;que)://拷贝构造函数</span></span><br><span class="line"><span class="comment">3.5.3.2 queue存取、插入和删除操作</span></span><br><span class="line"><span class="comment">        push(elem)://往队尾添加元素</span></span><br><span class="line"><span class="comment">        pop();//从队头移除第一个元素ψ</span></span><br><span class="line"><span class="comment">        back();//返回最后一个元素</span></span><br><span class="line"><span class="comment">        front()//返回第一个元素</span></span><br><span class="line"><span class="comment">3.5.3.3 queue赋值操作</span></span><br><span class="line"><span class="comment">        queue&amp;operator = (const queue &amp;que);//重戴等号操作符</span></span><br><span class="line"><span class="comment">3.5.3.4 queue大小操作</span></span><br><span class="line"><span class="comment">        empty();//判断队列是否为空</span></span><br><span class="line"><span class="comment">        size();//返回队列的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age):m_Name(name),m_age(age)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Person&gt;q;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>,<span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    q.push(p1);</span><br><span class="line">    q.push(p2);</span><br><span class="line">    q.push(p3);</span><br><span class="line">    q.push(p4);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取对头元素</span></span><br><span class="line">        Person pFront =q.front();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"队头元素 NAME IS "</span>&lt;&lt;pFront.m_Name&lt;&lt;<span class="string">" AGE IS "</span>&lt;&lt;pFront.m_age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//获取对尾元素</span></span><br><span class="line">        Person pBack = q.back();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"队尾元素 NAME IS "</span>&lt;&lt;pBack.m_Name&lt;&lt;<span class="string">" AGE IS "</span>&lt;&lt;pBack.m_age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        q.pop();<span class="comment">//出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"队列的大小为"</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>set容器</title>
    <url>/2020/04/22/set%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h1><p><img src="/2020/04/22/set%E5%AE%B9%E5%99%A8/1.png" alt></p>
<p><img src="/2020/04/22/set%E5%AE%B9%E5%99%A8/2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3721set构造函数</span></span><br><span class="line"><span class="comment">        set&lt;T&gt;st;//set默认构造函数:</span></span><br><span class="line"><span class="comment">        multiset&lt;T&gt;mst;// mit iset默认构造函数:</span></span><br><span class="line"><span class="comment">        set( const set&amp;st);//拷考贝构造函数</span></span><br><span class="line"><span class="comment">3722set赋值操作</span></span><br><span class="line"><span class="comment">        set&amp; operator=(const set&amp;*st);</span></span><br><span class="line"><span class="comment">        swap(st);//交换两个集合容器</span></span><br><span class="line"><span class="comment">3723set大小操作</span></span><br><span class="line"><span class="comment">        size();/返回容器中元素的数目</span></span><br><span class="line"><span class="comment">        empty();//判断容器是否为空</span></span><br><span class="line"><span class="comment">3724set插入和删除操作</span></span><br><span class="line"><span class="comment">        insert(elem)://在容器中插入元素。</span></span><br><span class="line"><span class="comment">        clear();//除所有元素</span></span><br><span class="line"><span class="comment">        erase(pos);//!剛除pos迭代器所指的元素,返回下一个元素的送代器</span></span><br><span class="line"><span class="comment">        erase(beg,end);//刪除区间[beg,end]的所有元素,返回下一个元素的送代器。</span></span><br><span class="line"><span class="comment">372.5set查找操作</span></span><br><span class="line"><span class="comment">        find (key):/查找键key是存在,若存在,返回该键的元素的迭代器;若不存在,返回   set.end();</span></span><br><span class="line"><span class="comment">        count (key):/查找键key的元素个数</span></span><br><span class="line"><span class="comment">        lower_ bound (keyl1em):/回第一个key&gt;=keyE1em元素的迭代器。</span></span><br><span class="line"><span class="comment">        upper_bound(KeyElet):/回第一个key&gt;keyE1em元素的迭代器。</span></span><br><span class="line"><span class="comment">        equal_range (keyl1em):/回容器中key与keyE1em相等的上下限的两个迭代器。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it= s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.insert(<span class="number">10</span>);</span><br><span class="line">    s.insert(<span class="number">20</span>);</span><br><span class="line">    s.insert(<span class="number">30</span>);</span><br><span class="line">    s.insert(<span class="number">60</span>);</span><br><span class="line">    s.insert(<span class="number">50</span>);</span><br><span class="line">    s.insert(<span class="number">30</span>);</span><br><span class="line">    printSet(s);</span><br><span class="line">    <span class="comment">//set 特点：自动排序，重复的数值计算一次</span></span><br><span class="line">    s.erase(<span class="number">20</span>);</span><br><span class="line">    printSet(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.insert(<span class="number">10</span>);</span><br><span class="line">    s.insert(<span class="number">20</span>);</span><br><span class="line">    s.insert(<span class="number">30</span>);</span><br><span class="line">    s.insert(<span class="number">30</span>);</span><br><span class="line">    s.insert(<span class="number">60</span>);</span><br><span class="line">    s.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = s.<span class="built_in">find</span>(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos!= s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到了！："</span>&lt;&lt;*pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找不到"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos2 = s.<span class="built_in">find</span>(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos2!= s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到了！："</span>&lt;&lt;*pos2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找不到"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printSet(s);</span><br><span class="line">    <span class="comment">//set.count只允许出现0或1，因为同一个数字最多一次</span></span><br><span class="line">    <span class="keyword">int</span> num = s.count(<span class="number">10</span> );</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"10的个数为"</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//lower_bound(keyElem)返回第一个k&gt;=keyElem 元素的迭代器</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator res= s.lower_bound(<span class="number">29</span>);</span><br><span class="line">    <span class="keyword">if</span>(res!= s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到lowerbound值为"</span>&lt;&lt;*res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    upper_bound(KeyElet);/回第一个key&gt;keyE1em元素的迭代器。</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator res2= s.upper_bound(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(res2!= s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到lowerbound值为"</span>&lt;&lt;*res2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    equal_range (keyl1em):/回容器中key与keyE1em相等的上下限的两个迭代器。</span></span><br><span class="line">    pair&lt; <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator ,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator &gt;it=s.equal_range (<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(it.first!=s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到equal_range中的lower_bound值为"</span>&lt;&lt;*(it.first)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(it.second!=s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到equal_range中的upper_bound值为"</span>&lt;&lt;*(it.second)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"NOT FOUND"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对组的声明方式*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p(<span class="built_in">string</span>(<span class="string">"Tom"</span>),<span class="number">18</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS "</span>&lt;&lt;p.first&lt;&lt;<span class="string">" AGE IS "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第二种声明</span></span><br><span class="line">    pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p2= make_pair(<span class="string">"Jerry"</span>,<span class="number">29</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS "</span>&lt;&lt;p2.first&lt;&lt;<span class="string">" AGE IS "</span>&lt;&lt;p2.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.insert(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"SUCCESSFULLY INSERT!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"UNSUCCESSFULLY INSERT!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ret = s.insert(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"SUCCESSFULLY INSERT!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"UNSUCCESSFULLY INSERT!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">    ms.insert(<span class="number">10</span>);</span><br><span class="line">    ms.insert(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*multiset 插入的元素是不管有几个相同的，都会打印出来*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用仿函数，指定set容器的排序规则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1&gt;v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    s.insert(<span class="number">10</span>);</span><br><span class="line">    s.insert(<span class="number">50</span>);</span><br><span class="line">    s.insert(<span class="number">30</span>);</span><br><span class="line">    s.insert(<span class="number">40</span>);</span><br><span class="line">    s.insert(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">/*默认排序是从小到大！*/</span></span><br><span class="line">    printSet(s);</span><br><span class="line">    <span class="comment">/*插入之后无法改变，但是可以再插入之前指定排序规则*/</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>,MyCompare&gt;s2;<span class="comment">//写了仿函数后，在set建立时要写入</span></span><br><span class="line">    s2.insert(<span class="number">10</span>);</span><br><span class="line">    s2.insert(<span class="number">50</span>);</span><br><span class="line">    s2.insert(<span class="number">30</span>);</span><br><span class="line">    s2.insert(<span class="number">40</span>);</span><br><span class="line">    s2.insert(<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>,MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>();it!= s2.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name ,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MycomparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1,<span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//年龄升序</span></span><br><span class="line">        <span class="keyword">return</span> p1.m_Age&lt;p2.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Person,MycomparePerson&gt; s;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"vvv"</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">70</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"fff"</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">"www"</span>,<span class="number">60</span>)</span></span>;</span><br><span class="line">    s.insert(p1);</span><br><span class="line">    s.insert(p2);</span><br><span class="line">    s.insert(p3);</span><br><span class="line">    s.insert(p4);</span><br><span class="line">    s.insert(p5);</span><br><span class="line">    s.insert(p6);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;Person,MycomparePerson&gt;::iterator it = s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NAME IS "</span> &lt;&lt; (*it).m_Name&lt;&lt;<span class="string">" AGE IS "</span>&lt;&lt; it-&gt;m_Age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="comment">//不写仿函数，是打印不出来顺序排列的的！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    test01();</span></span><br><span class="line"><span class="comment">//    test02();</span></span><br><span class="line"><span class="comment">//    test03();</span></span><br><span class="line"><span class="comment">//    test04();</span></span><br><span class="line"><span class="comment">//    test05() ;</span></span><br><span class="line">    test06();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>stack容器</title>
    <url>/2020/04/22/stack%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><p><img src="/2020/04/22/stack%E5%AE%B9%E5%99%A8/1.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.4.3.1 stack构造函数</span></span><br><span class="line"><span class="comment">    stack&lt;T&gt;stkT∥stack采用模板类实现,stack对象的默认构造形式</span></span><br><span class="line"><span class="comment">    stack( const stack&amp;stk)://拷贝构造函数</span></span><br><span class="line"><span class="comment">3.4.3.2 stack赋值操作</span></span><br><span class="line"><span class="comment">    stack operator( const stack &amp;stk);/重载等号操作符</span></span><br><span class="line"><span class="comment">3.4.3.3 stack数据存取操作。</span></span><br><span class="line"><span class="comment">    push(elem)//栈顶添加元素</span></span><br><span class="line"><span class="comment">    pop();//从栈顶移除第一个元素</span></span><br><span class="line"><span class="comment">    top();/返回栈顶元素</span></span><br><span class="line"><span class="comment">3.4.3.4 stack大小操作</span></span><br><span class="line"><span class="comment">    empty();//判断堆栈是否为空</span></span><br><span class="line"><span class="comment">    size();//返回堆栈的大小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    s.push(<span class="number">10</span>);</span><br><span class="line">    s.push(<span class="number">20</span>);</span><br><span class="line">    s.push( <span class="number">30</span>);</span><br><span class="line">    s.push(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输出栈顶元素</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"栈的大小"</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test01();</span><br><span class="line">   system(<span class="string">"pause"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>string容器</title>
    <url>/2020/04/22/string%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="string-容器"><a href="#string-容器" class="headerlink" title="string 容器"></a>string 容器</h1><p><img src="/2020/04/22/string%E5%AE%B9%E5%99%A8/1.png" alt></p>
<p><img src="/2020/04/22/string%E5%AE%B9%E5%99%A8/2.png" alt></p>
<p><img src="/2020/04/22/string%E5%AE%B9%E5%99%A8/3.png" alt></p>
<p><img src="/2020/04/22/string%E5%AE%B9%E5%99%A8/4.png" alt></p>
<p><img src="/2020/04/22/string%E5%AE%B9%E5%99%A8/5.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * string 容器</span></span><br><span class="line"><span class="comment"> *   string构造函数</span></span><br><span class="line"><span class="comment">        string()创建一个空的字符串例如: string str;</span></span><br><span class="line"><span class="comment">        string( const string&amp;str):/使用一个 string对象初始化另一个 string对象</span></span><br><span class="line"><span class="comment">        string( const char*s)://使用字符串s初始化</span></span><br><span class="line"><span class="comment">        string( int n, char c)://使用n个字符c初始化</span></span><br><span class="line"><span class="comment">    string基本赋值操作</span></span><br><span class="line"><span class="comment">        string&amp; operat or=( const char*s)://char*类型字符串賦值给当前的字符串</span></span><br><span class="line"><span class="comment">        string&amp; operat or=( onst string &amp;s):/把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="comment">        string&amp; operat or=(harc):;/字符赋值给当前的字符串</span></span><br><span class="line"><span class="comment">        string&amp; assign( const char*s);/把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="comment">        string&amp; assign( const char*s,intn)://把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="comment">        string&amp; assign( const string&amp;s);/把字符串s赋给当前字符串</span></span><br><span class="line"><span class="comment">        string&amp; assign(int n, char c)://用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="comment">        string&amp; assign( const string&amp;s, int st art,intn)://将s从 start开始n个字符赋值给字符串</span></span><br><span class="line"><span class="comment">    string 存取字符操作</span></span><br><span class="line"><span class="comment">        char*operator[](int n)//通过[]的方式获取字符</span></span><br><span class="line"><span class="comment">        char&amp; at (int n)//通过at方法获取字符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 3.12.4 string拼接操作</span></span><br><span class="line"><span class="comment">        string&amp; operat or+=( const string&amp; str):/重载七操作符</span></span><br><span class="line"><span class="comment">        string&amp; operat or+=( const char*str):/重载+操作符</span></span><br><span class="line"><span class="comment">        string&amp; operat or+=( canst char c):/重戴+操作符</span></span><br><span class="line"><span class="comment">        string&amp; append( const char*s)://把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="comment">        string&amp; append( const char*s,intn):/把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="comment">        string&amp; append (const string &amp;3): //B operator=O+</span></span><br><span class="line"><span class="comment">        string&amp; append( const string &amp;s, ant pos,intn):/把字符串s中从pos开始的n个字符连接到</span></span><br><span class="line"><span class="comment">        当前字符串结尾</span></span><br><span class="line"><span class="comment">        string&amp; append(itn, char c)://在当前字符串结尾添加n个字符c</span></span><br><span class="line"><span class="comment">3.12.5  string查找和替换</span></span><br><span class="line"><span class="comment">        int find( const string&amp; str, ant pos=0) const;/查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">        int find( const char*s, ant pos=0) const;//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">        int find( const char*s, Int pos,irtn)cnst;∥从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="comment">        int find( const char c, ant pos=0) const:/查找字符c第一次出现位置4</span></span><br><span class="line"><span class="comment">        int rfid(const stringl&amp;str, ant pos=mpos) const:/查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="comment">        int find (const char*s, int pos=mpos) const:/查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">        int rfid(const char*s, lnt pos,intn) const://Npos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="comment">        int find(const char c, int pos=0) const:/查找字符c最后一次出现位置</span></span><br><span class="line"><span class="comment">        replace( ant pos, int n, const string&amp; str)://替换从pos开始n个字符为字符串st</span></span><br><span class="line"><span class="comment">        string&amp; rep1ace( ant pos,intn, const char*s);//替换从pos开始的n个字符为亨符串s</span></span><br><span class="line"><span class="comment">3.12.6  string比较</span></span><br><span class="line"><span class="comment">        大写的A比小写的a要小,因为比的是字符串</span></span><br><span class="line"><span class="comment">        int compare (const string&amp;s)const//与字符串s比较</span></span><br><span class="line"><span class="comment">        int compare(const char*s)const  //与字符串s比较</span></span><br><span class="line"><span class="comment">3.12.7  string字串</span></span><br><span class="line"><span class="comment">        string substr(int pos=0;int n= pos)const//返回由pos 开始的n个字符组成的字符串</span></span><br><span class="line"><span class="comment">        string substr(pos)const//返回由pos 开始到字符串结束的字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.12.8  string插入和删除操作</span></span><br><span class="line"><span class="comment">        string&amp; insert( int pos, const char*s)://插入字符串</span></span><br><span class="line"><span class="comment">        string&amp; insert( int pos, const string&amp; str)://插入字符串</span></span><br><span class="line"><span class="comment">        string&amp; insert( ant pos,int n, char c):/在指定位置插入n个字符c</span></span><br><span class="line"><span class="comment">        string&amp; erase( int pos,int n=pos):/刪除从Pos开始的n个字符</span></span><br><span class="line"><span class="comment">3.12.9string和c-stye字符串转换</span></span><br><span class="line"><span class="comment">        string str="toast";// string转char*</span></span><br><span class="line"><span class="comment">        const char *cstr= str c_str();</span></span><br><span class="line"><span class="comment">        char*s=“ toast";//char*转 string</span></span><br><span class="line"><span class="comment">        string str(s)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">补充说明：： transform(a.begin(),a.end(),a.begin(),::toupper)可以将整个字符串中 的英文变成大写！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造</span></span><br><span class="line">    <span class="built_in">string</span> s1;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"有参构造"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//两个参数的有参</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s5;</span><br><span class="line">    s5=s4;</span><br><span class="line">    s5.assign(<span class="string">"abcdefg"</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s5&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s6=<span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="built_in">string</span> s7;</span><br><span class="line">    <span class="comment">//assign是从0开始计算的</span></span><br><span class="line">    s7.assign(s6,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s7&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">//    for(int i = 0;i&lt;s.size();i++)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;s[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;s.at(i)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//at 和中括号的区别：【】访问越界，会直接挂掉，at访问越界，会抛出一个异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//        s[100];</span></span><br><span class="line">        s.at(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (out_of_range&amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e.what()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">" I"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">" LOVE BEIJING"</span>;</span><br><span class="line">    str1+=str2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> str3 = <span class="string">"天安门"</span>;</span><br><span class="line">    str1.append(str3);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> str4 = <span class="string">"abcdefg "</span>;</span><br><span class="line">    str4.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"111111"</span>);<span class="comment">//替换从pos开始n个字符为字符串st</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = str4.<span class="built_in">find</span>(<span class="string">"den"</span>);</span><br><span class="line">    <span class="keyword">int</span> pos2 = str4.rfind(<span class="string">"de"</span>,<span class="number">6</span>);<span class="comment">//rfind从右往左找</span></span><br><span class="line">    <span class="comment">//查到了，返回第一个数字所在位置</span></span><br><span class="line">    <span class="comment">//查不到，返回-1；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Pos ="</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Pos ="</span>&lt;&lt;pos2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 =<span class="string">"abbcde"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2=<span class="string">"aacdef"</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1.compare(str2)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str1==str2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1 .compare(str2)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str1&gt;str2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"str1&lt;str2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 =<span class="string">"abcde"</span>;</span><br><span class="line">    <span class="built_in">string</span> subStr = str1.substr(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;subStr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> email = <span class="string">"2697767160@qq.com"</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">"@"</span>);</span><br><span class="line">    <span class="built_in">string</span> usrName = email.substr(<span class="number">0</span>,pos);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;usrName&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//不需要做+1,-1的操作!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需求,讲网址中的每个单词都截取到容器当中</span></span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">"www.itcast.com.cn"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v;</span><br><span class="line">    <span class="comment">//需要截取 www, itcast , com, cn;</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">"."</span>,start);</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将最后一个单词截取处理</span></span><br><span class="line">            <span class="built_in">string</span> tmp = str1.substr( start,str1.<span class="built_in">size</span>()-start);</span><br><span class="line">            v.push_back(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> tmp = str1.substr( start,pos-start);</span><br><span class="line">        v.push_back(tmp);</span><br><span class="line">        start = pos+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"hello"</span>;</span><br><span class="line">    str.insert(<span class="number">1</span>,<span class="string">"111"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//利用erase 删除掉111</span></span><br><span class="line">    str.erase(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//char*-&gt;string</span></span><br><span class="line">    <span class="keyword">char</span>*str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span> <span class="params">(str)</span></span>;</span><br><span class="line">    <span class="comment">//string -&gt; char*</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*str2 = s.c_str();</span><br><span class="line">    doWork(str2);<span class="comment">//编译器 将 const char* 隐式转换为string</span></span><br><span class="line">    <span class="comment">/*doWork2(s);*/</span> <span class="comment">//编译器不会讲string 隐式类型转换为const char*</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; a = s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span>&amp; b = s[<span class="number">3</span>];</span><br><span class="line">    a=<span class="string">'1'</span>;</span><br><span class="line">    b=<span class="string">'2'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>*)s.c_str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    s =<span class="string">"ppppppppppppppppppppppppppppppppppppppppppppppppp"</span>;<span class="comment">//重新分配内存,之前会失效</span></span><br><span class="line">    a=<span class="string">'1'</span>;</span><br><span class="line">    b=<span class="string">'2'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>*)s.c_str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">//把小写字符改成大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abCDEfG"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]= <span class="built_in">toupper</span>(str[i]);</span><br><span class="line">        <span class="comment">//小写转大写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]= <span class="built_in">tolower</span>(str[i]);</span><br><span class="line">        <span class="comment">//大写转小写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test10();</span><br><span class="line"><span class="comment">//    test09();</span></span><br><span class="line"><span class="comment">//    test08();</span></span><br><span class="line"><span class="comment">//    test07();</span></span><br><span class="line"><span class="comment">//    test06();</span></span><br><span class="line"><span class="comment">//    test05();</span></span><br><span class="line"><span class="comment">//    test04();</span></span><br><span class="line"><span class="comment">//    test03();</span></span><br><span class="line"><span class="comment">//    test01();</span></span><br><span class="line"><span class="comment">//    test02();</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>vector容器</title>
    <url>/2020/04/22/vector%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><p><img src="/2020/04/22/vector%E5%AE%B9%E5%99%A8/1.png" alt></p>
<p><img src="/2020/04/22/vector%E5%AE%B9%E5%99%A8/2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Jason on 2020/3/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">3.2.4.1 vector构造函数</span></span><br><span class="line"><span class="comment">        vector&lt;T&gt;v;//釆用模板实现类实现,默认构造函数+</span></span><br><span class="line"><span class="comment">        vector(v. begin(),v.end())://将 vector(v. begin(),v.end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="comment">        vector(n,elem)://构造函数将n个elem 拷贝给本身。</span></span><br><span class="line"><span class="comment">        vector( const vector&amp;vec)://拷贝构造函数。</span></span><br><span class="line"><span class="comment">        //例子使用第二个构造函数我们可以</span></span><br><span class="line"><span class="comment">        int arr[]=&#123;2,3,4,1,9&#125;;</span></span><br><span class="line"><span class="comment">        vector&lt;int &gt;v1(arr, arr+sizeof(arr)/ sizeof(int));</span></span><br><span class="line"><span class="comment">3.2.4.2 vector常用赋值操作</span></span><br><span class="line"><span class="comment">        assign(beg,end):/将[beg,end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">        assign(n,elem)://将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">        vector&amp; operator=( const vector&amp;vec)://重载等号操作符</span></span><br><span class="line"><span class="comment">        swap(vec)://将vec与本身的元素互换。</span></span><br><span class="line"><span class="comment">3.2.4.3 vector大小操作</span></span><br><span class="line"><span class="comment">        size() //返回客器中元素的个数</span></span><br><span class="line"><span class="comment">        empty()//判断器是否为空</span></span><br><span class="line"><span class="comment">        resize( int num)://重新指定窨器的长度为num,若寳器变长,则以默认值填充新位置。如果窨器变</span></span><br><span class="line"><span class="comment">        则末尾超出容器长度的元素被刪除。</span></span><br><span class="line"><span class="comment">        resize( int num,elem)://重新指定窨器的长度为num,若寳器变长,唢以e值填充新位置。如</span></span><br><span class="line"><span class="comment">        果窨器变短,则末尾超出窨器长度的元素被刪除。</span></span><br><span class="line"><span class="comment">        capacity()://睿器的窖量</span></span><br><span class="line"><span class="comment">        reserve( int len);//窖器预留1mn个元素长度,预留位置不初始化,元素不可访问。</span></span><br><span class="line"><span class="comment">3.2.4.4 vector数据存取操作</span></span><br><span class="line"><span class="comment">        at( int idx)://返回索引id所指的数据,如果iκ越畀,抛岀ourt_ of range异常。艹</span></span><br><span class="line"><span class="comment">        operator[]://返回索引id所指的数据,越畀时,运行直接报错</span></span><br><span class="line"><span class="comment">        front()//返回窨器中第一个数据元素</span></span><br><span class="line"><span class="comment">        back()//返回窨器中最后一个数据元素</span></span><br><span class="line"><span class="comment">3.2.4.5 vector插入和删除操作</span></span><br><span class="line"><span class="comment">        insert( const_ iterator pos, int count,elem)://迭代器指向位置pos插入cmt个元素elem.</span></span><br><span class="line"><span class="comment">        push back(elem)://尾部插入元素e1em</span></span><br><span class="line"><span class="comment">        pop_ back()//刪除最后一个元素</span></span><br><span class="line"><span class="comment">        erase( const_iterator start, const_ iterator end)://刪除迭代器从 start到end之间的元素</span></span><br><span class="line"><span class="comment">        erase( const_iterator pos)://刪除迭代器指向的元素</span></span><br><span class="line"><span class="comment">        clear()://刪除窖器中所有元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        拓展</span></span><br><span class="line"><span class="comment">        sort 函数，可以加上greater&lt;Elem&gt;来解决降序</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">160</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//    printVector(v2);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3(v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//    printVector(v3);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line"><span class="comment">//    v4.assign(v3.begin(),v3.end());</span></span><br><span class="line">    v4 = v3;<span class="comment">//这两种方法都可以</span></span><br><span class="line">    printVector(v4);</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;v5(arr, arr+<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//swap来交换</span></span><br><span class="line">    v4.swap(v5) ;<span class="comment">//4与5交换了</span></span><br><span class="line">    printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">    v1.push_back(<span class="number">10</span>);</span><br><span class="line">    v1.push_back(<span class="number">20</span>);</span><br><span class="line">    v1.push_back(<span class="number">30</span>);</span><br><span class="line">    v1.push_back(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"size = "</span>&lt;&lt;v1.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1.empty())<span class="comment">//如果为空，返回值为1，不为空，返回值为0；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"V1 is empty"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"v1 is not empty"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    v1.resize(<span class="number">10</span>);<span class="comment">//不足10，默认0填充</span></span><br><span class="line"><span class="comment">//    printVector(v1);</span></span><br><span class="line">    v1.resize(<span class="number">10</span>,<span class="number">1000</span>);<span class="comment">//可以指定，默认为1000填充</span></span><br><span class="line"><span class="comment">//    printVector(v1);</span></span><br><span class="line">    v1.resize(<span class="number">3</span>);<span class="comment">//变短了，末尾超出容器的部分被删掉</span></span><br><span class="line"><span class="comment">//    printVector(v1);</span></span><br><span class="line">    v1.resize(<span class="number">4</span>);<span class="comment">//被删除后，恢复原来的长度，删除的数据不回复原</span></span><br><span class="line">    printVector(v1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The first elem of v1 is "</span>&lt;&lt;v1.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The last elem of v1 is "</span>&lt;&lt;v1.back()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/************************************************************/</span></span><br><span class="line">    v1.insert(v1.<span class="built_in">begin</span>(),<span class="number">1000</span>);<span class="comment">//插一个数</span></span><br><span class="line">    v1.insert(v1.<span class="built_in">begin</span>(),<span class="number">2</span>,<span class="number">2000</span>);<span class="comment">//插自定义</span></span><br><span class="line">    <span class="comment">//1000 10 20 30 0</span></span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    v1.push_back(<span class="number">999</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line">    v1.pop_back();</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    v1.erase(v1.<span class="built_in">begin</span>() );<span class="comment">//头部删除</span></span><br><span class="line">    printVector(v1);</span><br><span class="line">    v1.erase(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>());<span class="comment">//全部删除</span></span><br><span class="line">    printVector(v1);</span><br><span class="line">    v1.push_back(<span class="number">1</span>);</span><br><span class="line">    printVector(v1);</span><br><span class="line">    v1.<span class="built_in">clear</span>();<span class="comment">//清空  =v1.erase(v1.begin(),v1.end())；</span></span><br><span class="line">    printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************************/</span></span><br><span class="line"><span class="comment">//案例，巧用swap 收缩内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的容量"</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的大小"</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    v.resize(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"resize(3)以后"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的容量"</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的大小"</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"swap(v)以后,会收缩内存"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的容量"</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"v的大小"</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    用reserve预留空间！</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">int</span> num  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="comment">//当容量不够的时候，vector容器会找到新的空间，这时候p就不指向头部了</span></span><br><span class="line">        <span class="keyword">if</span>(p!= &amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"NUM ="</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">int</span> num  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    v.reserve(<span class="number">10000000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">        <span class="comment">//当容量预留后，p就没动过</span></span><br><span class="line">        <span class="keyword">if</span>(p!= &amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NUM ="</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************************************************************/</span></span><br><span class="line"><span class="comment">//逆序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">    v1.push_back(<span class="number">10</span>);</span><br><span class="line">    v1.push_back(<span class="number">20</span>);</span><br><span class="line">    v1.push_back(<span class="number">30</span>);</span><br><span class="line">    v1.push_back(<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"正序遍历"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printVector(v1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"逆序遍历"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it  = v1.rbegin();it!=v1.rend();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//vector 容器的迭代器，随机访问迭代器</span></span><br><span class="line">    <span class="comment">//如何让判断一个容器的迭代器是否支持随机访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itBegin = v1.<span class="built_in">begin</span>();</span><br><span class="line">    itBegin = itBegin+<span class="number">1</span>;</span><br><span class="line">    itBegin++;</span><br><span class="line">    itBegin--;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;l;</span><br><span class="line">    l.push_back(<span class="number">10</span>);</span><br><span class="line">    l .push_back(<span class="number">20</span>);</span><br><span class="line">    l.push_back(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it2 = l.<span class="built_in">begin</span>();</span><br><span class="line">    it2 ++;</span><br><span class="line">    it2 --;</span><br><span class="line"><span class="comment">//    it = it+1; 会报错！！！</span></span><br><span class="line"><span class="comment">//  list 容器不支持随机访问</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    test01();</span></span><br><span class="line"><span class="comment">//    test02();</span></span><br><span class="line"><span class="comment">//    test03();</span></span><br><span class="line"><span class="comment">//    test04();</span></span><br><span class="line"><span class="comment">//    test05();</span></span><br><span class="line"><span class="comment">//    test06();</span></span><br><span class="line">    test07();</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>不酸的肯尼亚</title>
    <url>/2020/04/19/%E4%B8%8D%E9%85%B8%E7%9A%84%E8%82%AF%E5%B0%BC%E4%BA%9A/</url>
    <content><![CDATA[<h1 id="不酸肯尼亚冲法"><a href="#不酸肯尼亚冲法" class="headerlink" title="不酸肯尼亚冲法"></a>不酸肯尼亚冲法</h1><ul>
<li>粉量20g</li>
<li>研磨度正常</li>
<li>水温93度</li>
<li>闷蒸40cc 30秒</li>
<li>小水推粉至180cc,慢慢推，推到最外围</li>
<li>挖沙冲法，给大水—让粉翻上来—往外推60cc</li>
<li>挖沙冲法，给大水—让粉翻上来—往外推 60cc</li>
</ul>
]]></content>
      <tags>
        <tag>coffee</tag>
      </tags>
  </entry>
  <entry>
    <title>分配排序</title>
    <url>/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="分配排序"><a href="#分配排序" class="headerlink" title="分配排序"></a>分配排序</h1><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul>
<li>分配排序不需要比较关键词的大小，根据关键词各位上的值，进行若干次分配和收集实现排序</li>
<li>桶排序将待排序序列划分成若干区间。每个区间形象的看作一个桶，如果桶中的记录多以一个则使用较快的排序方法进行排序，把每个桶中的记录收集起来，最终得到有序序列</li>
</ul>
<p><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/1.png" alt="示例"></p>
<h3 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h3><ul>
<li>桶排序的数据最好是均匀分布的，如果都在90分以上，那么都在一个桶内，那么就退化成了一般的排序。在理想的情况下，当数据均匀分布，桶的数量m足够大的时候，那么每一个桶内最多只有一个记录，不需要再进行排序，只需要O（N）的时间将所有的记录分配到桶中，再用O（N）的时间收集起来。但这样空间复杂度会很大</li>
<li>桶排序支队不同的数据选择的划分方法是不同的，例如序列（2，46，1278，89323，211，22，43，1）可以按照位数划分桶，1位数，2位数，3位数…</li>
<li>桶内排序的时候使用的比较排序算法也有可能不同，可以用插入排序，也可以用快速排序</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li>基数排序可以看作桶排序的一种扩展，是一种多关键词排序算法，如果记录按照多个关键词排序，则依次按照这些关键词进行排序。如果记录按照一个数值型的关键词排序，可以把该关键词看作是d位组成的多关键词排序，每一位的取值范围是[0,r)，其中r被称为基数。例如十进制数268由3位数组成，每一位取值都在[0,10)，十进制数的r为10，二进制为2，英文字母的基数为26.</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>求出待排序序列中最大关键词的位数d，然后从低位到高位进行基数排序</li>
<li>按个位将关键词<strong>依次</strong>分配到桶中，然后把每个桶中的数据依次收集起来</li>
<li>将十位关键词<strong>依次</strong>分配到桶中，然后把每个桶中的数据依次收集起来</li>
<li><strong>依次</strong>下去，直到d位处理完毕，得到一个有序的序列</li>
<li>拿68，75，54，70，83，48，80，12，92为例子</li>
</ol>
<ul>
<li>先按个位排序</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>70</td>
<td></td>
<td>12</td>
<td>83</td>
<td>54</td>
<td>75</td>
<td></td>
<td></td>
<td>68</td>
<td></td>
</tr>
<tr>
<td>80</td>
<td></td>
<td>92</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>48</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>按找桶的顺序收集，波浪化收集得到 70，80，12，92，83，54，75，68，48</li>
<li>再按照第一趟的排序结果十位排序</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>12</td>
<td></td>
<td></td>
<td>48</td>
<td>54</td>
<td>68</td>
<td>70</td>
<td>80</td>
<td>92</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>75</td>
<td>83</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>再按照桶的顺序收集，得到12，48，54，68，70，75，80，83，92</li>
</ul>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul>
<li>为啥一定要依次收集？如果不依次会怎么样</li>
<li><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/3.png" alt="示例"></li>
<li>因为在十位相同的数字，在它们个位排序的时候，桶标号较小的肯定要比桶标号大的要小，所以在收集生成序列的时候也要先于大的，这样在按照十位排序的时候小的先于大的入桶，达到排序目的</li>
<li>所以要用一个队列，先进先出，依次进行。可以采用队列保持桶中数据的进出顺序，从而保证排序结果的正确性。也就是说每一个桶内使用一个队列存储数据，可以使用顺序队列或者链式队列</li>
</ul>
<h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul>
<li>基数排序需要进行d次排序，每一次排序包含分配和收集两个操作，分配需要O(n)的时间，收集操作如果使用顺序队列也要O(n)的时间，如果使用链式队列则只需要将r个链队首尾相连即可，需要O(r)的时间，总的时间复杂度为O(d(n+r))</li>
<li>如果使用顺序队列，需要r个大小为n的队列，空间复杂度为O(rn)。如果使用链式队列，则需要额外的指针域，那么空间复杂度O(n+r)，比顺序队列的空间要少得多</li>
<li>基数排序时按关键字出现的顺序依次进行的，是<strong>稳定</strong>的排序方法</li>
<li>桶中的多个数据元素可以采用二维数组，链式存储，也可以采用一维辅助数组进行处理。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h5 id="二维数组代码的实现"><a href="#二维数组代码的实现" class="headerlink" title="二维数组代码的实现"></a>二维数组代码的实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="keyword">int</span> A[Maxsize];</span><br><span class="line"><span class="comment">//求出待排序序列中最大的元素位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Maxbit</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxvalue = A[<span class="number">0</span>],digits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;maxvalue)</span><br><span class="line">            maxvalue = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(maxvalue!= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        digits++;</span><br><span class="line">        maxvalue/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求xbit位上的数字，如238上的第2位上的数字是3</span></span><br><span class="line"><span class="comment">// bit = 1的时候，那么就是8</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bitnumber</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> <span class="built_in">bit</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="built_in">bit</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x/temp)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,j,k,<span class="built_in">bit</span>,maxbit;</span><br><span class="line">    maxbit = Maxbit(A,n);</span><br><span class="line">    <span class="comment">//构造一个动态二位数组</span></span><br><span class="line">    <span class="keyword">int</span> **B= <span class="keyword">new</span> <span class="keyword">int</span> *[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        B[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//第0位存储元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        B[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//先把元素个数默认为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里开始进行分配收集操作，一共进行maxbit次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">bit</span> = <span class="number">1</span>;<span class="built_in">bit</span>&lt;=maxbit;<span class="built_in">bit</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分配操作</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//取出位数</span></span><br><span class="line">            <span class="keyword">int</span> num = Bitnumber(A[j],<span class="built_in">bit</span>);</span><br><span class="line">            <span class="comment">//然后给A[j]分配桶内位置</span></span><br><span class="line">            <span class="keyword">int</span> index = ++B[num][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//存储</span></span><br><span class="line">            B[num][index] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//收集操作，一共有10个桶，那么一一串连</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=B[i][<span class="number">0</span>];k++)</span><br><span class="line">                A[j++] = B[i][k];</span><br><span class="line">            <span class="comment">//更新原来序列，因为j一直在加，最后会把原来的序列全更新一遍</span></span><br><span class="line">            B[i][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//收集完这个桶后元素置0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁数组</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入数列中的元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入数列中的元素"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    RadixSort(A,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"基数排序的结果:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一维数组实现"><a href="#一维数组实现" class="headerlink" title="一维数组实现"></a>一维数组实现</h5><ul>
<li>利用计数器数组计数</li>
<li>计数器累加</li>
<li>把数据反向遍历存储到临时数组中，这里如果用正向遍历，就不能正确输入数据了，在每次输入的时候，计数器相应元素-1，这样能实现巧妙地映射。最后会变成上一格的计数器的数字</li>
<li><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/4.png" alt="示例"></li>
<li>临时数组对原数组实现覆盖</li>
</ul>
<p>拿68，75，54，70，83，48，80，12，75*，92举例</p>
<p>第一次循环</p>
<ul>
<li>先计数</li>
<li><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/7.png" alt="示例"></li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>+ count数组累加</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>+ 68，75，54，70，83，48，80，12，75*，92 反向遍历，放入temp数组</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+ 拿到92，个位数是2，那么看到2的count数组对应4，因为我们是从0开始计数的，所以92放到temp[3]中，同时count[2]–</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>count</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>10</td>
<td>10</td>
</tr>
</tbody></table>
<p>temp</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td>92</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>以此类推，那么最后的结果就是这样</li>
</ul>
<p>count</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>10</td>
</tr>
</tbody></table>
<p>temp</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>70</td>
<td>80</td>
<td>12</td>
<td>92</td>
<td>83</td>
<td>54</td>
<td>75</td>
<td>75*</td>
<td>68</td>
<td>48</td>
</tr>
</tbody></table>
<p>第二次循环<br> 70   ， 80   ， 12   ， 92   ， 83   ， 54   ， 75   ， 75*  ， 68   ， 48</p>
<ul>
<li>先计数</li>
<li><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/8.png" alt="示例"></li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>+ count累加</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>+ 以此类推，那么最后的结果就是这样</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>count</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>9</td>
</tr>
</tbody></table>
<p>temp</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>48</td>
<td>54</td>
<td>68</td>
<td>70</td>
<td>75</td>
<td>75*</td>
<td>80</td>
<td>83</td>
<td>92</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//辅助函数，求数据的最大位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//扫描一遍就可以了，判断是不是比10，1000大</span></span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">1</span>;<span class="comment">//统计最大的位数</span></span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(data[i]&gt;=p)</span><br><span class="line">        &#123;</span><br><span class="line">            p*=<span class="number">10</span>;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d=maxbit(data,n); <span class="comment">//求最大位数</span></span><br><span class="line">    <span class="keyword">int</span> *tmp=<span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">int</span> *count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">int</span> radix=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=d;i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            count[j]=<span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k=(data[j]/radix)%<span class="number">10</span>; <span class="comment">//取出个位数，然后是十位数，...</span></span><br><span class="line">            count[k]++; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">            count[j]+=count[j<span class="number">-1</span>]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k=(data[j]/radix)%<span class="number">10</span>;</span><br><span class="line">            tmp[--count[k]]=data[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j]=tmp[j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i&lt;&lt;<span class="string">"次排序结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        radix=radix*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[]tmp;</span><br><span class="line">    <span class="keyword">delete</span>[]count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    radixsort(a,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加一段基数排序的gif，更容易理解"><a href="#加一段基数排序的gif，更容易理解" class="headerlink" title="加一段基数排序的gif，更容易理解"></a>加一段基数排序的gif，更容易理解</h3><p><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/1.gif" alt="示例"></p>
<p>视频来自可视化算法网站<a href="https://visualgo.net/zh" target="_blank" rel="noopener">https://visualgo.net/zh</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/6.png" alt="示例"></p>
<p><img src="/2020/05/06/%E5%88%86%E9%85%8D%E6%8E%92%E5%BA%8F/5.png" alt="示例"></p>
]]></content>
      <tags>
        <tag>Data_structure</tag>
        <tag>Rank</tag>
      </tags>
  </entry>
  <entry>
    <title>初识正则表达式</title>
    <url>/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式的探索与发现-爬虫项目系列博客"><a href="#正则表达式的探索与发现-爬虫项目系列博客" class="headerlink" title="正则表达式的探索与发现-爬虫项目系列博客"></a>正则表达式的探索与发现-爬虫项目系列博客</h1><p>​    因为要实现爬虫的功能，正则表达式是必须要掌握和简单应用的。那么这对于从来没看到过正则表达式的小白来说，它无疑是头痛的，因为它的长这个样子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url_reg = <span class="regexp">/\/(\d&#123;4&#125;)\/(\d&#123;2&#125;)-(\d&#123;2&#125;)\/(\d&#123;7&#125;).shtml/</span>;</span><br><span class="line"><span class="keyword">var</span> regExp = <span class="regexp">/((\d&#123;4&#125;|\d&#123;2&#125;)(\-|\/|\.)\d&#123;1,2&#125;\3\d&#123;1,2&#125;)|(\d&#123;4&#125;年\d&#123;1,2&#125;月\d&#123;1,2&#125;日)/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 正则表达式:也叫规则表达式,按照一定的规则组成的一个表达式,这个表达式的作用主要是匹配字符串的,</span></span><br><span class="line"><span class="comment">    * "我的电话:10086,他的电话:10010,你的电话:10000" 正则表达式,把这个字符串中的所有的数字找到</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 正则表达式的作用:匹配字符串的</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 在大多数编程语言中都可以使用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 正则表达式的组成:是由元字符或者是限定符组成的一个式子</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 元字符:</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * .  表示的是:除了\n以外的任意的一个字符   "fdsfs238"</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * [] 表示的是:范围,  [0-9] 表示的是0到9之间的任意的一个数字,  "789" [0-9]</span></span><br><span class="line"><span class="comment">    * [1-7] 表示的是1到7之间的任意的一个数字</span></span><br><span class="line"><span class="comment">    * [a-z] 表示的是:所有的小写的字母中的任意的一个</span></span><br><span class="line"><span class="comment">    * [A-Z] 表示的是:所有的大写的字母中的任意的一个</span></span><br><span class="line"><span class="comment">    * [a-zA-Z] 表示的是:所有的字母的任意的一个</span></span><br><span class="line"><span class="comment">    * [0-9a-zA-Z] 表示的是: 所有的数字或者是字母中的一个</span></span><br><span class="line"><span class="comment">    * [] 另一个含义: 把正则表达式中元字符的意义干掉    [.] 就是一个.</span></span><br><span class="line"><span class="comment">    * | 或者     [0-9]|[a-z] 表示的是要么是一个数字,要么是一个小写的字母</span></span><br><span class="line"><span class="comment">    * () 分组 提升优先级   [0-9]|([a-z])|[A-Z]</span></span><br><span class="line"><span class="comment">    * ([0-9])([1-5])([a-z]) 三组, 从最左边开始计算</span></span><br><span class="line"><span class="comment">    * (()(()))有几个左括号就有几组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 都是元字符,但是也可以叫限定符,下面的这些</span></span><br><span class="line"><span class="comment">    *    *   表示的是:前面的表达式出现了0次到多次</span></span><br><span class="line"><span class="comment">    *    [a-z][0-9]* 小写字母中的任意一个 后面是要么是没有数字的,要么是多个数字的</span></span><br><span class="line"><span class="comment">    *    "fdsfs3223323"  [a-z][0-9]* 这是能匹配的，s3223323能够匹配</span></span><br><span class="line"><span class="comment">    *     只要某一节字符串匹配，那么整个字符串都匹配</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *    +  表示的是:前面的表达式出现了1次到多次</span></span><br><span class="line"><span class="comment">    *    [a-z][9]+  小写字母一个后面最少一个9,或者多个9</span></span><br><span class="line"><span class="comment">    *    "fesfewww9fefds" 这也是可以匹配的，w9 能够匹配</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *    ?  表示的是:前面的表达式出现了0次到1次,最少是0次,最多1次 ,另一个含义:阻止贪婪模式</span></span><br><span class="line"><span class="comment">    *    [4][a-z]? "1231234ij"</span></span><br><span class="line"><span class="comment">    *  限定符:限定前面的表达式出现的次数</span></span><br><span class="line"><span class="comment">    *  &#123;&#125; 更加的明确前面的表达式出现的次数</span></span><br><span class="line"><span class="comment">    *  &#123;0,&#125; 表示的是前面的表达式出现了0次到多次,和 *一样的</span></span><br><span class="line"><span class="comment">    *  &#123;1,&#125; 表示的是前面的表达式出现了1次到多次,和 +一样的</span></span><br><span class="line"><span class="comment">    *  &#123;0,1&#125; 表示的是前面的表达式出现了0次到1次,和 ?一样的</span></span><br><span class="line"><span class="comment">    *  &#123;5,10&#125; 表示的是前面的表达式出现了5次到10次</span></span><br><span class="line"><span class="comment">    *  &#123;4&#125; 前面的表达式出现了4次</span></span><br><span class="line"><span class="comment">    *  &#123;,10&#125; 错误的========不能这么写</span></span><br><span class="line"><span class="comment">    *  ^ 表示的是以什么开始,或者是取非(取反)</span></span><br><span class="line"><span class="comment">    *  ^[0-9] 以数字开头</span></span><br><span class="line"><span class="comment">    *  ^[a-z] 以小写字母开始</span></span><br><span class="line"><span class="comment">    *  [^0-9] 取反,非数字</span></span><br><span class="line"><span class="comment">    *  [^a-z] 非小写字母</span></span><br><span class="line"><span class="comment">    *  [^0-9a-zA-Z_] _不是特舒符号</span></span><br><span class="line"><span class="comment">    *  $ 表示的是以什么结束   [0-9][a-z]$  必须以小写字母结束</span></span><br><span class="line"><span class="comment">    *  ^[0-9][a-z]$ 相当于是严格模式   "3f2432e"  "4f" ^限定开始，$限定结束 。有了^$,表示严格模式</span></span><br><span class="line"><span class="comment">    *   \d 数字中的任意一个,</span></span><br><span class="line"><span class="comment">    *   \D 非数字中的一个</span></span><br><span class="line"><span class="comment">    *   \s 空白符中的一个</span></span><br><span class="line"><span class="comment">    *   \S 非空白符</span></span><br><span class="line"><span class="comment">    *   \w 非特殊符号</span></span><br><span class="line"><span class="comment">    *   \W 特殊符号</span></span><br><span class="line"><span class="comment">    *   \b 单词的边界</span></span><br><span class="line"><span class="comment">    *   "what are you no sha lei"</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *    . 除了\n以外的任意一个单个字符</span></span><br><span class="line"><span class="comment">    *    []  范围</span></span><br><span class="line"><span class="comment">    *    () 分组,提升优先级</span></span><br><span class="line"><span class="comment">    *    | 或者</span></span><br><span class="line"><span class="comment">    *    * 0-多次</span></span><br><span class="line"><span class="comment">    *    + 1-多次</span></span><br><span class="line"><span class="comment">    *    ? 0-1次</span></span><br><span class="line"><span class="comment">    *    &#123;0,&#125; 和*一样</span></span><br><span class="line"><span class="comment">    *    &#123;1,&#125; 和+</span></span><br><span class="line"><span class="comment">    *    &#123;0,1&#125; 和?</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *    \d 数字中的一个</span></span><br><span class="line"><span class="comment">    *    \D 非数字</span></span><br><span class="line"><span class="comment">    *    \s 空白符</span></span><br><span class="line"><span class="comment">    *    \S 非空白符</span></span><br><span class="line"><span class="comment">    *     \W  特殊符号</span></span><br><span class="line"><span class="comment">    *     \w 非特殊符号 _ 等价于[A-Za-z0-9 ]</span></span><br><span class="line"><span class="comment">    *     ^ 取反,以什么开始</span></span><br><span class="line"><span class="comment">    *     $ 以什么结束</span></span><br><span class="line"><span class="comment">    *     \b 单词边界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 写正则表达式,根据字符串来写正则表达式进行匹配</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 经验: 1.找规律 2.不要追求完美</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 身份证的正则表达式</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 15位或者18位</span></span><br><span class="line"><span class="comment">    * ([1-9][0-9]&#123;14&#125;)|([1-9][0-9]&#123;16&#125;[0-9xX])</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * ([1-9][0-9]&#123;14&#125;)([0-9]&#123;2&#125;[0-9xX])?//问号表示前面的（）有没有出现过，0或1次</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 练习:</span></span><br><span class="line"><span class="comment">    * 1.座机号码的正则表达式</span></span><br><span class="line"><span class="comment">    * 010-19876754</span></span><br><span class="line"><span class="comment">    * 0431-87123490</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * [0-9]&#123;3,4&#125;[-][0-9]&#123;8&#125;</span></span><br><span class="line"><span class="comment">    * \d&#123;3,4&#125;[-]\d&#123;8&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * \d&#123;3,4&#125;[-][0-9]&#123;8&#125; 这种方式不工整</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 2.qq号码的正则表达式</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * [1-9][0-9]&#123;4,10&#125;</span></span><br><span class="line"><span class="comment">    * \d&#123;5,11&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 3.手机号码的正则表达式</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 130 131 132 133 134 135 136 137 138 139</span></span><br><span class="line"><span class="comment">    * 143 147</span></span><br><span class="line"><span class="comment">    * 150 151 152 153 154 155 156 157 158 159</span></span><br><span class="line"><span class="comment">    * 170 171 173 176 177</span></span><br><span class="line"><span class="comment">    * 180 181 182 183 184 185 186 187 188 189</span></span><br><span class="line"><span class="comment">    * ([1][358][0-9][0-9]&#123;8&#125;)|([1][4][37][0-9]&#123;8&#125;)|([1][7][01367][0-9]&#123;8&#125;)</span></span><br><span class="line"><span class="comment">    * \d&#123;11&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 邮箱的正则表达式,必须要记住的</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * sd2113_3.-fd@itcast.com.cn</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * [0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+)&#123;1,2&#125;有可能是.com 也有可能是.com.cn</span></span><br><span class="line"><span class="comment">    * + 表示一次到多次</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *[0-9a-zA-Z_.]+[@][0-9a-zA-Z._]+([.][a-zA-Z]+)&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br></pre></td></tr></table></figure>



<p>​    </p>
<p>翻阅了一下犀牛书，有看了几个网上的教学视频，总算有了点概念，接下来我先把书本的内容贴上来</p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/b1.jpg" alt="示例"></p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/b2.jpg" alt="示例"></p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/b3.jpg" alt="示例"></p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/b4.jpg" alt="示例"></p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/b5.jpg" alt="示例"></p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/b6.jpg" alt="示例"></p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/b7.jpg" alt="示例"></p>
<h4 id="先来看看第一个正则表达式"><a href="#先来看看第一个正则表达式" class="headerlink" title="先来看看第一个正则表达式"></a>先来看看第一个正则表达式</h4><p>我们要知道，正则表达式不是我们凭空捏造出来的，而是在我们找到目标网页后，根据源代码中子内容的编写规律对应着写下来的，老师的代码爬取的式中国新闻网的内容，所以我们先打开中国新闻网的源代码页面。</p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%96%B0%E9%97%BB%E4%B8%BB%E9%A1%B5.png" alt="示例"></p>
<p>我们看到了这一行行的新闻标题，心想：这不就是我想要的嘛！！！怎么才能获得呢！？？</p>
<p>不慌，按F12<del>进入坦克</del>进入DevTools</p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/devtools.png" alt="示例"></p>
<p>那么如何才能定位呢？我们点击左上方的那个小按钮，对，就是那个有鼠标一样的小按钮</p>
<p><del>新世界开启</del></p>
<p>我们只要把我们的鼠标移动到任何一处，图片，链接，窗口等等，devtools中就会自动显示对应的链接，太可了！</p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/shubiao.png" alt="示例"></p>
<p>这样看了几个新闻链接后，我们不难发现</p>
<p><a href="http://www.chinanews.com/gn/2020/04-20/9162393.shtml" target="_blank" rel="noopener">http://www.chinanews.com/gn/2020/04-20/9162393.shtml</a></p>
<p><a href="http://www.chinanews.com/gj/2020/04-20/9162621.shtml" target="_blank" rel="noopener">http://www.chinanews.com/gj/2020/04-20/9162621.shtml</a></p>
<p><a href="http://www.chinanews.com/cj/2020/04-20/9162059.shtml" target="_blank" rel="noopener">http://www.chinanews.com/cj/2020/04-20/9162059.shtml</a></p>
<p>好吧事不过三，我们发现这三个基本上具有相同的格式，只是中间的gn/gj/cn不同，日期可能不同和后边的编码不同，好，那么我们需要用正则表达式去匹配前面的<a href="http://www.chinanews.com嘛？其实并不需要，我们只需要找到这类链接的不同之处即可，否则就是浪费时间。那么再来分析一下我们的正则表达式">www.chinanews.com嘛？其实并不需要，我们只需要找到这类链接的不同之处即可，否则就是浪费时间。那么再来分析一下我们的正则表达式</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url_reg = <span class="regexp">/\/(\d&#123;4&#125;)\/(\d&#123;2&#125;)-(\d&#123;2&#125;)\/(\d&#123;7&#125;).shtml/</span>;</span><br><span class="line"><span class="comment">//  首尾两个/ 是在Js中的声明正则表达式的固定用法，可以略去</span></span><br><span class="line"><span class="comment">//  1.\ 是用来转义的 \/匹配的是/</span></span><br><span class="line"><span class="comment">//  2.(\d&#123;4&#125;)分成两个部分 ：\d 代表数字 &#123;4&#125;代表出现字数，这里很明显我们要匹配2020</span></span><br><span class="line"><span class="comment">// 	3.\/ 又是匹配/</span></span><br><span class="line"><span class="comment">// 	4.(\d&#123;2&#125;) 同理，这次我们来匹配月份，04</span></span><br><span class="line"><span class="comment">//	5. - 其实就是匹配04-20中的-</span></span><br><span class="line"><span class="comment">//	6. (\d&#123;2&#125;)匹配的是日期</span></span><br><span class="line"><span class="comment">// 	7. \/ 又是匹配/</span></span><br><span class="line"><span class="comment">//	8.(\d&#123;7&#125;) 匹配编号，不同网页都有独特的编号</span></span><br><span class="line"><span class="comment">// 	9  .shitml就是匹配 .shtml </span></span><br><span class="line"><span class="comment">// 值得注意的是，在这里.的意思是非\n的任意字符，包括了. 如果我们只要匹配 . 需要写[.]</span></span><br></pre></td></tr></table></figure>

<p><strong>分析完毕，我们来测试一下他的具体性能吧</strong></p>
<p><a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">https://c.runoob.com/front-end/854</a> 这是一个在线测试正则表达式的网站，在写爬虫的时候先跑一下看看到底能不能过滤出有效的信息来</p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/cainiaogongju.png" alt="示例"></p>
<p>可以看到这个正则表达式还是蛮厉害的，匹配到了200多条网页链接</p>
<h4 id="再来看看第二个正则表达式"><a href="#再来看看第二个正则表达式" class="headerlink" title="再来看看第二个正则表达式"></a>再来看看第二个正则表达式</h4><ul>
<li>我们来看看第二个正则表达式索要匹配的目标</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regExp = <span class="regexp">/((\d&#123;4&#125;|\d&#123;2&#125;)(\-|\/|\.)\d&#123;1,2&#125;\3\d&#123;1,2&#125;)|(\d&#123;4&#125;年\d&#123;1,2&#125;月\d&#123;1,2&#125;日)/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;span id=<span class="string">"pubtime_baidu"</span>&gt;<span class="number">2020</span><span class="number">-04</span><span class="number">-21</span> <span class="number">08</span>:<span class="number">53</span>:<span class="number">46</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">2. &lt;div class="left-t"&gt;2020年04月21日 09:08　来源：法制日报&lt;a href="#zw_cyhd" target="_self"&gt; </span></span><br><span class="line"><span class="regexp">3.也有可能是这种 20-03-11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其实我们要匹配的是这个出版时间,因为新闻嘛，总要讲究出版时间，所以我们要把他们都找出来</li>
<li>因为出版时间有多种形式，有可能是19-08-19类的，有可能是2020/03/20，也有可能是2020年04月21日</li>
</ul>
<ol>
<li>\d{4} 出现四个数字，也就是匹配年份</li>
<li>\d{2}  出现两个数字，也是年份，只不过可能是19-xx-xx也有可能是 2019-xx-xx 所以在中间加个|表示或</li>
<li>( \-|/|\.)其实是最难的，因为信息量很大，其实她想说的就是中间连字符的种类，可能是 -，可能是/,可能是 .  中间两个| 就是表示或者的意思</li>
<li>\d{1,2}是匹配月份的，有可能是 1，也有可能是01</li>
<li>\3比较难理解，这个\3其实就是匹配左边开始数第三个左括号的，也就是( \-|/|\.)，其实也是月和日之间的连接符</li>
<li>\d{1,2}匹配的是日期</li>
<li>前面完全是数字字符来表达年月日，不过也存在2020年4月21日这种情况，那么我们如何解决？| 就完事了</li>
<li>| 后面匹配的就是2020年4月21日这类的日期表达</li>
</ol>
<p>下图就是\3 这类\后面加上数字的作用</p>
<img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.png" class>

<h4 id="最后来看看我的爬虫中的正则表达式"><a href="#最后来看看我的爬虫中的正则表达式" class="headerlink" title="最后来看看我的爬虫中的正则表达式"></a>最后来看看我的爬虫中的正则表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/.\/.&#123;8&#125;\//</span></span><br></pre></td></tr></table></figure>

<p>我要爬取的网站是 <a href="https://www.smzdm.com/" target="_blank" rel="noopener">https://www.smzdm.com/</a> 什么值得买网站（为了找我喜欢的咖啡具）</p>
<p>然后我们来看看子网页</p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3.png" alt="示例"></p>
<p>按照上面的方法，我们来找找看子网页的url</p>
<p><a href="https://post.smzdm.com/p/alpwnzve/" target="_blank" rel="noopener">https://post.smzdm.com/p/alpwnzve/</a></p>
<p><a href="https://post.smzdm.com/p/awxqrv02/" target="_blank" rel="noopener">https://post.smzdm.com/p/awxqrv02/</a></p>
<p>规律是很明显的，我们需要匹配的就是  /p/alpwnzve/ </p>
<ol>
<li>/匹配的就是/</li>
<li>.匹配的是任何字符（除了\n),当然也可以用[a-zA-Z]代替</li>
<li>/又匹配的是/</li>
<li>.{8} 匹配的就是 连续八个字符，这里匹配的就是alpwnzve之类的</li>
<li>/匹配的还是/</li>
</ol>
<p>来看看我们的匹配结果</p>
<p><img src="/2020/04/20/%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/33.png" alt="示例"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写到这里，我们对正则表达式都有了一个基本的概念了，学会了正则表达式，在爬虫的项目中就解决了一个很大的难题。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>crawler</tag>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>从-1开始的python爬虫</title>
    <url>/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="从-1开始的python爬虫"><a href="#从-1开始的python爬虫" class="headerlink" title="从-1开始的python爬虫"></a>从-1开始的python爬虫</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>这篇长博客主要记录了我跟着一个公开课的内容从-1开始的爬虫经验，为什么是从-1呢，就是说我对python刚刚上手没几天，就开始学爬虫了QAQ</li>
<li>假设我们都已经安装了pycharm并配置好了所有库</li>
<li>我们要用的库是：pip3  install  requests  selenium beautifulsoup4 pyquery pymysql pymongo redis flask django jupyter</li>
<li>除了pyquery这类的包需要网上下载，其他都用pip3 install 包名解决，但是有时候很慢，有时候失败 ，多试几次8</li>
<li>谁能想到,仅仅安装这个包我就装了一个下午？？？</li>
</ul>
<h2 id="爬虫原理的讲解"><a href="#爬虫原理的讲解" class="headerlink" title="爬虫原理的讲解"></a>爬虫原理的讲解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/1.png" alt="示例"></p>
<h4 id="什么是Request和Response？"><a href="#什么是Request和Response？" class="headerlink" title="什么是Request和Response？"></a>什么是Request和Response？</h4><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/2.png" alt="示例"></p>
<ul>
<li>浏览器就发送消息给该网址所在的服务器，这个过程叫做HTTP Request</li>
<li>服务器收到浏览器发送的消息后，能够根据浏览器发送的内容做相应处理，然后把消息回传给浏览器。这个过程叫做HTTP Response</li>
</ul>
<h5 id="Request包含哪些方法？"><a href="#Request包含哪些方法？" class="headerlink" title="Request包含哪些方法？"></a>Request包含哪些方法？</h5><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/3.png" alt="示例"></p>
<h5 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h5><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/4.png" alt="示例"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(response.text)</span><br><span class="line">print(response.status_code)<span class="comment">#200 说明请求成功</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这三行代码就是我向百度发送了一个请求，然后把response返回给我们命名的response</p>
</li>
<li><p>然后打印出网页源代码</p>
</li>
<li><p>注意，这样的请求不能请求知乎这样的网站</p>
</li>
</ul>
<h4 id="能抓取怎样的数据"><a href="#能抓取怎样的数据" class="headerlink" title="能抓取怎样的数据"></a>能抓取怎样的数据</h4><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/5.png" alt="示例"></p>
<h4 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h4><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/6.png" alt="示例"></p>
<ul>
<li>request请求只会请求第一个html网页，而不会加载后面的Js文件，但是我们在dev-tool的Elements中看到的源代码是已经经过js渲染过后的，体量很大，行数很多，和一开始拿到的源代码完全不一样</li>
</ul>
<h4 id="那么，如何解决JavaScript渲染的问题"><a href="#那么，如何解决JavaScript渲染的问题" class="headerlink" title="那么，如何解决JavaScript渲染的问题"></a>那么，如何解决JavaScript渲染的问题</h4><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/7.png" alt="示例"></p>
<ul>
<li>我们在python中引入了selenium库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment">#driver.get('http://www.zhihu.com')</span></span><br><span class="line">driver.get(<span class="string">'http://www.taobao.com'</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/8.png" alt="示例"></p>
<p>用库不能获得js渲染后的源代码，但是driver.page_source 可以</p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/9.png" alt="示例"></p>
<h4 id="如何存储文件"><a href="#如何存储文件" class="headerlink" title="如何存储文件"></a>如何存储文件</h4><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/10.png" alt="示例"></p>
<h2 id="Urllib-库的基本使用"><a href="#Urllib-库的基本使用" class="headerlink" title="Urllib 库的基本使用"></a>Urllib 库的基本使用</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><a href="https://www.cnblogs.com/Caiyundo/p/12448948.html" target="_blank" rel="noopener">https://www.cnblogs.com/Caiyundo/p/12448948.html</a></p>
<h5 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h5><h6 id="get-类型请求"><a href="#get-类型请求" class="headerlink" title="get 类型请求"></a>get 类型请求</h6><p>返回源代码的所有内容，完成了爬虫的第一步，就是把网页给请求下来了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<h6 id="post类型请求-加了data就是以post方式"><a href="#post类型请求-加了data就是以post方式" class="headerlink" title="post类型请求,加了data就是以post方式"></a>post类型请求,加了data就是以post方式</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">data = bytes(urllib.parse.urlencode(&#123;<span class="string">'word'</span>:<span class="string">'hello'</span>&#125;),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://httpbin.org/post'</span>,data=data)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/12.png" alt="示例"></p>
<h6 id="timeout-参数-超时就报错，否则就返回"><a href="#timeout-参数-超时就报错，否则就返回" class="headerlink" title="timeout 参数:超时就报错，否则就返回"></a>timeout 参数:超时就报错，否则就返回</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://httpbin.org/get'</span>,timeout=<span class="number">1</span>)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/13.png" alt="示例"></p>
<h6 id="调用urllib-error判断原因"><a href="#调用urllib-error判断原因" class="headerlink" title="调用urllib.error判断原因"></a>调用urllib.error判断原因</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'http://httpbin.org/get'</span>,timeout = <span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> isinstance(e.reason,socket.timeout):</span><br><span class="line">        print(<span class="string">'Time Out!'</span>)</span><br><span class="line"><span class="comment"># 最后就返回Time Out</span></span><br></pre></td></tr></table></figure>

<h5 id="Response-1"><a href="#Response-1" class="headerlink" title="Response"></a>Response</h5><h6 id="响应类型"><a href="#响应类型" class="headerlink" title="响应类型"></a>响应类型</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://www.python.org'</span>)</span><br><span class="line">print(type(response))</span><br><span class="line"><span class="comment"># 显示 &lt;class 'http.client.HTTPResponse'&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="状态码，响应头"><a href="#状态码，响应头" class="headerlink" title="状态码，响应头"></a>状态码，响应头</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://www.python.org'</span>)</span><br><span class="line">print(response.status) <span class="comment"># 200</span></span><br><span class="line">print(response.getheaders()) <span class="comment"># 响应头</span></span><br><span class="line">print(response.getheader(<span class="string">'Server'</span>)) <span class="comment">#nginx</span></span><br><span class="line"><span class="string">""" 响应头如下，getheader是具体获得某个属性，比如这里('Server', 'nginx')</span></span><br><span class="line"><span class="string">[('Connection', 'close'), ('Content-Length', '48894'), ('Server', 'nginx'),</span></span><br><span class="line"><span class="string">('Content-Type', 'text/html; charset=utf-8'), ('X-Frame-Options', 'DENY'), </span></span><br><span class="line"><span class="string">('Via', '1.1 vegur'), ('Via', '1.1 varnish'), ('Accept-Ranges', 'bytes'), </span></span><br><span class="line"><span class="string">('Date', 'Fri, 01 May 2020 02:10:29 GMT'), ('Via', '1.1 varnish'), </span></span><br><span class="line"><span class="string">('Age', '2038'), ('X-Served-By', 'cache-bwi5143-BWI, cache-hkg17922-HKG'),</span></span><br><span class="line"><span class="string">('X-Cache', 'HIT, HIT'), ('X-Cache-Hits', '2, 1537'), </span></span><br><span class="line"><span class="string">('X-Timer', 'S1588299030.614786,VS0,VE0'), ('Vary', 'Cookie'), </span></span><br><span class="line"><span class="string">('Strict-Transport-Security', 'max-age=63072000; includeSubDomains')]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h6 id="read方法，返回响应的内容"><a href="#read方法，返回响应的内容" class="headerlink" title="read方法，返回响应的内容"></a>read方法，返回响应的内容</h6><ul>
<li>就是网页的源代码（js渲染之后）</li>
<li><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/14.png" alt="示例"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'http://www.python.org'</span>)</span><br><span class="line">print(response.read(),decode=(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<h5 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h5><h6 id="发送request对象-获得response的内容"><a href="#发送request对象-获得response的内容" class="headerlink" title="发送request对象 获得response的内容"></a>发送request对象 获得response的内容</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">request = urllib.request.Request(<span class="string">'http://www.python.org'</span>)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 和上面的一样，返回网页源代码</span></span><br></pre></td></tr></table></figure>

<h6 id="加入headers的参数"><a href="#加入headers的参数" class="headerlink" title="加入headers的参数"></a>加入headers的参数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span><span class="comment"># 构造一个post请求</span></span><br><span class="line"><span class="comment"># 把headers加进来</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (compatible;MSIE 5.5;Windows NT)'</span>,</span><br><span class="line">    <span class="string">'Host'</span>:<span class="string">'httpbin.org'</span></span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span> : <span class="string">'Jason'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 把data用bytes编码</span></span><br><span class="line">data = bytes(parse.urlencode(dict),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 利用Request方法，传入url，data，headers，method这些参数</span></span><br><span class="line">req = request.Request(url=url,data = data,headers=headers,method=<span class="string">'POST'</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<p>下面是返回的内容</p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/15.png" alt="示例"></p>
<h6 id="通过add-headers传入参数"><a href="#通过add-headers传入参数" class="headerlink" title="通过add_headers传入参数"></a>通过add_headers传入参数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span> : <span class="string">'Jason'</span></span><br><span class="line">&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">req = request.Request(url=url,data = data,method=<span class="string">'POST'</span>)</span><br><span class="line"><span class="comment"># 通过add_headers 传入我们设定的headers</span></span><br><span class="line">req.add_header(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (compatible;MSIE 5.5;Windows NT)'</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<p>内容和上图一样</p>
<h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>handler就是辅助的工具，用来做更高级的操作</p>
<p><a href="https://docs.python.org/3/library/urllib.html" target="_blank" rel="noopener">官方文档</a></p>
<h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">proxy_handler = urllib.request.ProxyHandler(&#123;</span><br><span class="line">    <span class="comment"># 这是我现在的代理（vpn）</span></span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">&#125;)</span><br><span class="line">opener = urllib.request.build_opener(proxy_handler)</span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>

<ul>
<li>传回来一堆东西,就是百度的源代码</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/16.png" alt="示例"></p>
<ul>
<li>如果换成httpbin.org,会返回一个ip地址</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/17.png" alt="示例"></p>
<p>稍做查询，我们可以知道这个199.193.124.87来自美国加利福尼亚洛杉矶</p>
<p>使用代理ip地址，可以伪装自己的ip地址，并保持切换，这样服务器就不会屏蔽我们这个爬虫</p>
<h6 id="Coockie"><a href="#Coockie" class="headerlink" title="Coockie"></a>Coockie</h6><ul>
<li><p>cookie 是保存用户信息的文件，在爬虫中可以用来维持用户登陆状态。在dev-tools中清楚coockie，再次刷新浏览器，就需要重新登陆了</p>
</li>
<li><p>利用cookie可以爬取一些需要认证的网页</p>
</li>
<li></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar,urllib.request</span><br><span class="line"><span class="comment"># 首先把cookie声明为一个cookieJar的对象</span></span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line"><span class="comment"># 借助handler 处理cookie</span></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line"><span class="comment"># build_opener把handler传过来</span></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"><span class="comment"># 最后用opener打开网站</span></span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="comment"># 遍历打印出cookie中的内容</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name + <span class="string">'='</span>+item.value)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">BAIDUID=2D4FA5F4570DED9E85DFD1316A950B5A:FG=1</span></span><br><span class="line"><span class="string">BIDUPSID=2D4FA5F4570DED9E52F2D6C2838FE7A0</span></span><br><span class="line"><span class="string">H_PS_PSSID=1442_31325_21078_31423_31341_31463_30824_31163</span></span><br><span class="line"><span class="string">PSTM=1588302459</span></span><br><span class="line"><span class="string">BDSVRTM=0</span></span><br><span class="line"><span class="string">BD_HOME=1</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果cookie没有失效，那么可以一直使用这个cookie维持登录状态</li>
</ul>
<h6 id="利用MozillaCookieJar保存我们的cookie文件"><a href="#利用MozillaCookieJar保存我们的cookie文件" class="headerlink" title="利用MozillaCookieJar保存我们的cookie文件"></a>利用MozillaCookieJar保存我们的cookie文件</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar,urllib.request</span><br><span class="line">filename = <span class="string">"cookie.txt"</span></span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar(filename)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>,ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>运行之后，文件夹里多出了一个cookie.txt 文件</p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/18.png" alt="示例"></p>
<h6 id="也可以用LWPcookieJar保存我们的cookie，只是格式不同"><a href="#也可以用LWPcookieJar保存我们的cookie，只是格式不同" class="headerlink" title="也可以用LWPcookieJar保存我们的cookie，只是格式不同"></a>也可以用LWPcookieJar保存我们的cookie，只是格式不同</h6><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/19.png" alt="示例"></p>
<h6 id="用load方法来把文件中的cookie赋值给新的cookie"><a href="#用load方法来把文件中的cookie赋值给新的cookie" class="headerlink" title="用load方法来把文件中的cookie赋值给新的cookie"></a>用load方法来把文件中的cookie赋值给新的cookie</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar,urllib.request</span><br><span class="line">cookie = http.cookiejar.LWPCookieJar()</span><br><span class="line"><span class="comment"># 这里我们已经把cookie文件保存下来，下面只是读取文本文件，赋值</span></span><br><span class="line">cookie.load(<span class="string">'cookie.txt'</span>,ignore_expires=<span class="literal">True</span>,ignore_discard=<span class="literal">True</span>)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"><span class="comment"># cookie没有过期的话，可以再次爬取我们的网页</span></span><br><span class="line"><span class="comment"># 如果网页是要登录才能看到的，那么这样就能保持我们的登陆状态</span></span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 最后打印的内容就是我们的网页源码</span></span><br></pre></td></tr></table></figure>

<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p><a href="https://docs.python.org/3/library/urllib.error.html" target="_blank" rel="noopener">官方文档</a></p>
<h6 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">'http://cuiqingcai.com/index.html'</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br><span class="line"><span class="comment"># 打印 Not Found</span></span><br><span class="line"><span class="comment"># 改成 http://jasonxqh.github.io 不显示错误，因为请求成功</span></span><br></pre></td></tr></table></figure>

<h6 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h6><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/20.png" alt="示例"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'http://www.baidu.com'</span>,timeout=<span class="number">0.01</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">     print(type(e.reason))</span><br><span class="line">    <span class="keyword">if</span> isinstance(e.reason,socket.timeout):</span><br><span class="line">        print(<span class="string">'Time Out'</span>)</span><br><span class="line">      <span class="comment">#打印&lt;class 'socket.timeout'&gt;</span></span><br><span class="line">	  <span class="comment">#    Time Out</span></span><br></pre></td></tr></table></figure>

<h5 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h5><h6 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a>urlparse</h6><ul>
<li>把URL拆分成几个标准的部分</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line">result = urlparse(<span class="string">'http://www.baidu.com/index.html;user?id=5#comment'</span>)</span><br><span class="line">print(type(result),result)</span><br><span class="line"><span class="comment"># 打印内容如下，</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">urllib</span>.<span class="title">parse</span>.<span class="title">ParseResult</span>'&gt; <span class="title">ParseResult</span><span class="params">(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>,</span></span></span><br><span class="line"><span class="class"><span class="params"> path=<span class="string">'/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>加上协议参数，如果本来就有http开头，那么第二个参数是不会生效的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line">result = urlparse(<span class="string">'www.baidu.com/index.html;user?id=5#comment'</span>,scheme=<span class="string">'https'</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 打印内容如下</span></span><br><span class="line">ParseResult(scheme=<span class="string">'https'</span>, netloc=<span class="string">''</span>, path=<span class="string">'www.baidu.com/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>allow_fragments参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line">result=urlparse(<span class="string">'http://www.baidu.com/index.html;user id=5#comment'</span>,allow_fragments=<span class="literal">False</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 打印内容如下 fragment 置空，拼接到上面一个非空参数中，如果query也为空，那么再拼到params中</span></span><br><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html'</span>, params=<span class="string">'user'</span>, </span><br><span class="line">query=<span class="string">'id=5#comment'</span>, fragment=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h6 id="urlunprse"><a href="#urlunprse" class="headerlink" title="urlunprse"></a>urlunprse</h6><ul>
<li>拼接url，就是urlparse的反函数</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/21.png" alt="示例"></p>
<h6 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a>urljoin</h6><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/22.png" alt="示例"></p>
<p>拼接两个字符串，因为一个url可以分成很多部分，如果后面的字符串的部分未出现，前面的来补，后面的出现了，那么以后面的为准</p>
<h6 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h6><p>把字典对象转换成get请求参数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span>  urlencode</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'Jason'</span>,</span><br><span class="line">    <span class="string">'age'</span> :<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">base_url = <span class="string">'http://www.baidu.com?'</span></span><br><span class="line">url = base_url+urlencode(params)</span><br><span class="line">print(url)</span><br><span class="line"><span class="comment"># 打印内容</span></span><br><span class="line"> http://www.baidu.com?name=Jason&amp;age=18</span><br></pre></td></tr></table></figure>

<h2 id="Requests库详解"><a href="#Requests库详解" class="headerlink" title="Requests库详解"></a>Requests库详解</h2><ul>
<li>requests库的代码量相较于urllib更为简单，而且是基于urllib3编写的库。所以在写爬虫代码的时候建议用Requests库</li>
</ul>
<h3 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(type(response))</span><br><span class="line">print(response.status_code)</span><br><span class="line">print(type(response.text))</span><br><span class="line">print(response.text)<span class="comment">#和urllib中的read()方法的功能相同</span></span><br><span class="line">print(response.cookies)<span class="comment">#不需要像urllib一样先声明一个cookie对象和handler</span></span><br><span class="line"><span class="comment"># 可以把我们想要的信息迅速打印出来</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/23.png" alt="示例"></p>
<h3 id="各种请求方式"><a href="#各种请求方式" class="headerlink" title="各种请求方式"></a>各种请求方式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">requests.post(<span class="string">'http://httpbin.org/post'</span>)</span><br><span class="line">requests.put(<span class="string">'http://httpbin.org/put'</span>)</span><br><span class="line">requests.delete(<span class="string">'http://httpbin.org/delete'</span>)</span><br><span class="line">requests.options(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">requests.head(<span class="string">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="基本get请求"><a href="#基本get请求" class="headerlink" title="基本get请求"></a>基本get请求</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>



<h4 id="带参数的Get请求"><a href="#带参数的Get请求" class="headerlink" title="带参数的Get请求"></a>带参数的Get请求</h4><h5 id="原来这么写"><a href="#原来这么写" class="headerlink" title="原来这么写"></a>原来这么写</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://httpbin.org/get?name=Jason&amp;age=19'</span>)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<h5 id="现在这么写"><a href="#现在这么写" class="headerlink" title="现在这么写"></a>现在这么写</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'Jason'</span>,</span><br><span class="line">     <span class="string">'age'</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">'http://httpbin.org/get'</span>,params=data)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回内容都是一样的。但是后面的更加直观易懂，不需要自己编码</li>
</ul>
<h4 id="解析json"><a href="#解析json" class="headerlink" title="解析json"></a>解析json</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">print(type(response.text))</span><br><span class="line">print(response.json())</span><br><span class="line">print(type(response.json()))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/24.png" alt="示例"></p>
<ul>
<li>response.json()相当于json库中的json.loads(response.txt)的用法</li>
</ul>
<h3 id="获取二进制数据"><a href="#获取二进制数据" class="headerlink" title="获取二进制数据"></a>获取二进制数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://github.com/favicon.ico'</span>)</span><br><span class="line">print(type(response.text),type(response.content))</span><br><span class="line">print(response.text)</span><br><span class="line">print(response.content)</span><br></pre></td></tr></table></figure>

<h5 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://github.com/favicon.ico'</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>,<span class="string">'wb'</span>)<span class="keyword">as</span> f:<span class="comment"># wb是写入模式</span></span><br><span class="line">    f.write(response.content)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>我们看到图片就这样被下载了</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/25.png" alt="示例"></p>
<h3 id="添加headers"><a href="#添加headers" class="headerlink" title="添加headers"></a>添加headers</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>不加headers，会被某些网站ban掉</p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/26.png" alt="示例"></p>
<ul>
<li>添加了headers后，好起来了</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">headers = &#123;</span><br><span class="line">     <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">'https://www.zhihu.com/explore'</span>,headers=headers)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<h3 id="基本post请求"><a href="#基本post请求" class="headerlink" title="基本post请求"></a>基本post请求</h3><p>可以非常方便的传入一个字典，在urllib还要转码，配置，比较繁琐</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;<span class="string">'name'</span>:<span class="string">'jason'</span>,<span class="string">'age'</span>:<span class="number">22</span>&#125;</span><br><span class="line">response = requests.post(<span class="string">"http://httpbin.org/post"</span>,data=data)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/28.png" alt="示例"></p>
<ul>
<li>加入一个headers</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;<span class="string">'name'</span>:<span class="string">'jason'</span>,<span class="string">'age'</span>:<span class="number">22</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">     <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) </span></span><br><span class="line"><span class="string">AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 </span></span><br><span class="line"><span class="string">Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line">response = </span><br><span class="line">requests.post(<span class="string">"http://httpbin.org/post"</span>,data=data,headers=headers)</span><br><span class="line">print(response.json())</span><br><span class="line"><span class="comment"># 打印json文件格式</span></span><br></pre></td></tr></table></figure>

<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><h4 id="response属性"><a href="#response属性" class="headerlink" title="response属性"></a>response属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.jianshu.com'</span>)</span><br><span class="line">print(type(response.status_code),response.status_code)</span><br><span class="line">print(type(response.headers),response.headers)</span><br><span class="line">print(type(response.cookies),response.cookies)</span><br><span class="line">print(type(response.url),response.url)</span><br><span class="line">print(type(response.history),response.history)</span><br></pre></td></tr></table></figure>

<h3 id="状态码判断"><a href="#状态码判断" class="headerlink" title="状态码判断"></a>状态码判断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.jianshu.com'</span>)</span><br><span class="line">exit()<span class="keyword">if</span> <span class="keyword">not</span> response.status_code==requests.codes.not_found <span class="keyword">else</span> print(<span class="string">'Request Not Found'</span>)</span><br><span class="line"><span class="comment"># not_found 可以更改为任何一个状态码后的文字内容</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/30.png" alt="示例"></p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/31.png" alt="示例"></p>
<h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 把这个文件读取出来</span></span><br><span class="line">files = &#123;<span class="string">'file'</span>:open(<span class="string">'favicon.ico'</span>,<span class="string">'rb'</span>)&#125;</span><br><span class="line"><span class="comment"># 利用post操作实现文件的上传</span></span><br><span class="line">response = requests.post(<span class="string">'http://httpbin.org/post'</span>,files=files)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/32.png" alt="示例"></p>
<h4 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h4><p>不用像urllib一样，用一个cookiejar然后再用handler获取cookie了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(response.cookies)</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> response.cookies.items():</span><br><span class="line">    print(key+<span class="string">'='</span>+value)</span><br><span class="line"><span class="string">'''  &lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;</span></span><br><span class="line"><span class="string">BDORZ=27315</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>

<h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><p>模拟登陆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># Session()方法是实现在同一个浏览器实现get和set</span></span><br><span class="line">s = requests.Session()</span><br><span class="line"><span class="comment"># 用sesson对象发起两次请求</span></span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">response = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(response.text)</span><br><span class="line">```</span><br><span class="line">输出内容如下，说明第二次访问的时候cookies已经保存下来了，说明会话维持住了</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cookies"</span>: &#123;</span><br><span class="line">    <span class="string">"number"</span>: <span class="string">"123456789"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h3 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h3><ul>
<li>如果要访问的网站的证书是不合法的，就会抛出一个错误，要避免这个错误就要设定一个verify参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.12306.cn'</span>,verify=<span class="literal">False</span>)<span class="comment">#会warning</span></span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 通过这样引入一个原生包可以避免warning的发生</span></span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">response = requests.get(<span class="string">'http://www.12306.cn'</span>,verify=<span class="literal">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure>

<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/33.png" alt="示例"></p>
<p>第一种是普通的，第二种是需要密码的，第三种是用socks代理的，需要pip一下socks包</p>
<h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">'http://www.taobao.com'</span>,timeout=<span class="number">0.01</span>)</span><br><span class="line">print(response.status_code)</span><br><span class="line"><span class="comment"># 会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="认证设置"><a href="#认证设置" class="headerlink" title="认证设置"></a>认证设置</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/34.png" alt="示例"></p>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/35.png" alt="示例"></p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/36.png" alt="示例"></p>
<p><a href="https://requests.readthedocs.io/en/master/_modules/requests/exceptions/#RequestException" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="BeautifulSoup-的基本用法"><a href="#BeautifulSoup-的基本用法" class="headerlink" title="BeautifulSoup 的基本用法"></a>BeautifulSoup 的基本用法</h2><ul>
<li>灵活又方便的网页解析库，处理高效，支持多种解析器。利用它不用编写正则表达式即可方便地实现网页信息的爬取</li>
</ul>
<h3 id="解析库"><a href="#解析库" class="headerlink" title="解析库"></a>解析库</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/37.png" alt="示例"></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang="zh" data-hairline="true" data-theme="light"&gt;&lt;head&gt;&lt;meta charSet="utf-8"/&gt;&lt;title data-react-helmet="true"&gt;请问心脏线r=a(1+ cosθ)的图像怎么画，和a有什么关系？ - 知乎&lt;/title&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/&gt;&lt;meta name="renderer" content="webkit"/&gt; </span></span><br><span class="line"><span class="string">  height: env(safe-area-inset-top) !important;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">.u-safeAreaInset-bottom &#123;</span></span><br><span class="line"><span class="string">  height: constant(safe-area-inset-bottom) !important;</span></span><br><span class="line"><span class="string">  height: env(safe-area-inset-bottom) !important;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.prettify())<span class="comment"># 就可以梅花我们残缺的html文件</span></span><br><span class="line">print(soup.title.string)<span class="comment"># 获取到我们html中的title</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们看到这就是结果</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/39.png" alt="示例"></p>
<ul>
<li>如果没有title标签，那么就会报错</li>
</ul>
<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><ul>
<li>这种选择器的选择速度是非常快的，根据标签的名字来选择</li>
<li>但是不能满足我们的一些需求，单纯用标签来选择是远远不够的</li>
</ul>
<h4 id="选择元素-标签"><a href="#选择元素-标签" class="headerlink" title="选择元素/标签"></a>选择元素/标签</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.title)</span><br><span class="line">print(type(soup.title))</span><br><span class="line">print(soup.head)</span><br><span class="line">print(soup.p)</span><br></pre></td></tr></table></figure>

<ul>
<li>我们很简单的把知乎的源代码当作html文件，这样我们看到打印出来的内容：</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/40.png" alt="示例"></p>
<h4 id="获取名称：返回最外层标签的名称"><a href="#获取名称：返回最外层标签的名称" class="headerlink" title="获取名称：返回最外层标签的名称"></a>获取名称：返回最外层标签的名称</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.title.name)</span><br></pre></td></tr></table></figure>

<h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/38.png" alt="示例"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.p.attr(<span class="string">'name'</span>))</span><br><span class="line">print(soup.p(<span class="string">'name'</span>))</span><br><span class="line"><span class="comment"># 输出dromouse</span></span><br></pre></td></tr></table></figure>

<h4 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.title.string)<span class="comment"># 获取到我们html中的title中的内容</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套选择"><a href="#嵌套选择" class="headerlink" title="嵌套选择"></a>嵌套选择</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment"># 获取head中的title标签的string属性</span></span><br><span class="line">print(soup.head.title.string)</span><br></pre></td></tr></table></figure>

<h4 id="子节点和子孙节点"><a href="#子节点和子孙节点" class="headerlink" title="子节点和子孙节点"></a>子节点和子孙节点</h4><ul>
<li>对子节点输出 ： child</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.p.child)</span><br><span class="line"><span class="comment"># child 会输出所有的子节点，返回的是迭代器</span></span><br><span class="line"><span class="keyword">for</span> l,child <span class="keyword">in</span> enumerate(soup.p.child):</span><br><span class="line">    print(l,child)</span><br></pre></td></tr></table></figure>
<ul>
<li>对所有子孙节点输出： descendants</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.p.descendants)</span><br><span class="line"><span class="comment"># descendants 会把子节点子孙节点全部打印出来，返回迭代器</span></span><br><span class="line"><span class="keyword">for</span> l,child <span class="keyword">in</span> enumerate(soup.p.descendants):</span><br><span class="line">    print(l,child)</span><br></pre></td></tr></table></figure>

<h4 id="父节点和祖先节点"><a href="#父节点和祖先节点" class="headerlink" title="父节点和祖先节点"></a>父节点和祖先节点</h4><ul>
<li>对指定标签的父节点进行输出：parent</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.a.parent)<span class="comment"># 对a标签的父节点进行输出</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对指定标签的父节点和祖父节点进行输出：parents</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.a.parents)</span><br><span class="line">print(list(enumerate(soup.a.parents)))</span><br></pre></td></tr></table></figure>

<h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><ul>
<li>next_siblings 和 previous_siblings</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(list(enumerate(soup.a.next_siblings)))<span class="comment"># 后面的兄弟节点</span></span><br><span class="line">print(list(enumerate(soup.a.previous_siblings)))<span class="comment"># 前面的兄弟节点</span></span><br></pre></td></tr></table></figure>

<h3 id="标准选择器-find-和-find-all"><a href="#标准选择器-find-和-find-all" class="headerlink" title="标准选择器 find 和 find_all"></a>标准选择器 find 和 find_all</h3><h4 id="find-all-name-attrs-recursive-text-kwargs"><a href="#find-all-name-attrs-recursive-text-kwargs" class="headerlink" title="find_all(name,attrs,recursive,text,**kwargs)"></a>find_all(name,attrs,recursive,text,**kwargs)</h4><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><ul>
<li>这里是找标签为ul的代码，并且返回一个迭代器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.find_all(<span class="string">'ul'</span>))</span><br><span class="line">print(type(soup.find_all(<span class="string">'ul'</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<ul>
<li>先把每一个ul拿出来，再嵌套一层遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.find_all(<span class="string">'ul'</span>):</span><br><span class="line">	print(ul.find_all(<span class="string">'li'</span>))</span><br></pre></td></tr></table></figure>

<h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><ul>
<li>传入一个字典，键名是属性名，键值是属性值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.find_all(attrs=(<span class="string">'id'</span>:<span class="string">'list-1'</span>)))</span><br></pre></td></tr></table></figure>

<ul>
<li>直接用等于会更加方便，也不会用到attrs了</li>
<li>class比较特殊，需要用class_</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.find_all(id=<span class="string">'list-1'</span>))</span><br><span class="line">print(soup.find_all(class_=<span class="string">'element'</span>))</span><br></pre></td></tr></table></figure>

<h5 id="text"><a href="#text" class="headerlink" title="text"></a>text</h5><ul>
<li>对文本的内容进行选择</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soup.find_all(text=<span class="string">'Foo'</span>))<span class="comment"># 直接返回里面的name，可以做内容匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="find-name-attrs-recursive-text-kwargs"><a href="#find-name-attrs-recursive-text-kwargs" class="headerlink" title="find(name,attrs,recursive,text,**kwargs)"></a>find(name,attrs,recursive,text,**kwargs)</h4><ul>
<li><p>find返回单个元素，find_all 返回所有元素</p>
</li>
<li><p>find_parents() 和find_parents()</p>
<ul>
<li>前者返回所有祖先节点，后者返回父节点</li>
</ul>
</li>
<li><p>find_previous_siblings()和find_previous_sibling ()</p>
<ul>
<li>前者返回所有的前面的兄弟节点，后者只返回前面的第一个兄弟节点</li>
</ul>
</li>
<li><p>find_next_siblings()和find_next_sibling ()</p>
<ul>
<li>前者返回所有的后面的兄弟节点，后者只返回后面的第一个兄弟节点</li>
</ul>
</li>
<li><p>find_all_next{} 和 find_next()</p>
<ul>
<li>前者返回节点后所有符合条件的节点，后面返回第一个符合条件的节点</li>
</ul>
</li>
<li><p>find_all_previous{}和find_previous()</p>
<ul>
<li>同理</li>
</ul>
</li>
</ul>
<h3 id="css-选择器-select"><a href="#css-选择器-select" class="headerlink" title="css 选择器 select()"></a>css 选择器 select()</h3><ul>
<li>通过select()直接传入CSS选择器即可完成选择</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment"># 如果标签中又class，那么选择器前面要加 . 查找panel里面的panel-heading</span></span><br><span class="line"><span class="comment"># 如&lt;div class = "panel"&gt;&lt;div class = "panel-heading"&gt;</span></span><br><span class="line">print(soup.select(<span class="string">'.panel .panel-heading'</span>))</span><br><span class="line"><span class="comment"># 选择ul中的li</span></span><br><span class="line">print(soup.select(<span class="string">'ul li'</span>))</span><br><span class="line"><span class="comment"># 选择id中的内容，那么要加#</span></span><br><span class="line"><span class="comment">#如 &lt;ul class = "xxx" id ="list-2"&gt;</span></span><br><span class="line">print(soup.select(<span class="string">'#list-2 .element'</span>))</span><br><span class="line">print(type(soup.select(<span class="string">'ul'</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<ul>
<li>层层迭代</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">'ul'</span>):</span><br><span class="line">	print(ul.select(<span class="string">'li'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="获取属性-1"><a href="#获取属性-1" class="headerlink" title="获取属性"></a>获取属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">'ul'</span>):</span><br><span class="line">	print(ul(<span class="string">'id'</span>))</span><br><span class="line">	print(ul.attr[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="获取内容-1"><a href="#获取内容-1" class="headerlink" title="获取内容"></a>获取内容</h4><ul>
<li>把所有指定的标签中的内容进行输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> soup.select(<span class="string">'li'</span>):</span><br><span class="line">	print(li.get_text())</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>推荐使用lxml解析库，必要时使用html.parser</li>
<li>标签选择筛选功能弱但是速度快</li>
<li>建议使用find()或者find_all()来匹配结果</li>
<li>如果对CSS选择器熟悉用 select()</li>
<li>记住常用的获取属性和文本值的方法</li>
</ul>
<h2 id="pyquery-的基本用法"><a href="#pyquery-的基本用法" class="headerlink" title="pyquery 的基本用法"></a>pyquery 的基本用法</h2><ul>
<li>强大灵活的网页解析库。熟悉jQuery的语法乐意选择PyQuery</li>
</ul>
<h2 id="Selenium的基本用法"><a href="#Selenium的基本用法" class="headerlink" title="Selenium的基本用法"></a>Selenium的基本用法</h2><ul>
<li><p>自动化测试工具，支持多种浏览器，爬虫中主要用来解决JavaScript渲染的问题</p>
</li>
<li><p>当urllib，requests无法获得渲染之后的源代码的时候，selenium可以派上用场</p>
</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="comment"># 声明浏览器的一个对象</span></span><br><span class="line">browser= webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 传入网址</span></span><br><span class="line">    browser.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="comment"># 把id=kw的内容赋值给input，这里就是搜索框</span></span><br><span class="line">    input = browser.find_element_by_id(<span class="string">'kw'</span>)</span><br><span class="line">    <span class="comment"># 在搜索框中敲入Python</span></span><br><span class="line">    input.send_keys(<span class="string">'Python'</span>)</span><br><span class="line">    <span class="comment"># 点击回车</span></span><br><span class="line">    input.send_keys(Keys.ENTER)</span><br><span class="line">    <span class="comment"># 等待浏览器，知道content_left被加载出来</span></span><br><span class="line">    wait = WebDriverWait(browser,<span class="number">10</span>)   wait.until(EC.presence_of_all_elements_located((By.ID,<span class="string">'content_left'</span>)))</span><br><span class="line">    <span class="comment"># 打印url</span></span><br><span class="line">    print(browser.current_url)</span><br><span class="line">    <span class="comment"># 打印cookies</span></span><br><span class="line">    print(browser.get_cookies())</span><br><span class="line">    <span class="comment"># 打印网页源代码</span></span><br><span class="line">    print(browser.page_source)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 关闭网页</span></span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># 只有安装了该浏览器，才能运行，建议使用chrome，因为会直接弹出，比较直观</span></span><br><span class="line">browser= webdriver.Chrome()</span><br><span class="line">browser= webdriver.Firefox()</span><br><span class="line">browser= webdriver.Edge()</span><br><span class="line">browser= webdriver.Safari()</span><br><span class="line">browser= webdriver.PhantomJS()</span><br></pre></td></tr></table></figure>

<h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">browser&#x3D; webdriver.Chrome()</span><br><span class="line">browser.get(&#39;http:&#x2F;&#x2F;www.taobao.com&#39;)</span><br><span class="line">print(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><h4 id="单个元素。find-element"><a href="#单个元素。find-element" class="headerlink" title="单个元素。find_element"></a>单个元素。find_element</h4><ul>
<li>找到输入框，输入信息。找到一些按钮，进行一些操作等等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser= webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.taobao.com'</span>)</span><br><span class="line"><span class="comment"># 通过id选择</span></span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line"><span class="comment"># 通过css_selector选择</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">'#q'</span>)</span><br><span class="line"><span class="comment"># 通过xpath选择</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line">print(input_first)</span><br><span class="line">print(input_second)</span><br><span class="line">print(input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>可以看到这三种查询结果是一样的</p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/46.png" alt="示例"></p>
<ul>
<li>常见的查找方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_xpath()</span><br><span class="line">browser.find_element_by_name()</span><br><span class="line">browser.find_element_by_link_text()</span><br><span class="line">browser.find_element_by_partial_link_text()</span><br><span class="line">browser.find_element_by_tag_name()</span><br><span class="line">browser.find_element_by_class_name()</span><br><span class="line">browser.find_element_by_css_selector()</span><br></pre></td></tr></table></figure>

<ul>
<li>通用查找方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">browser= webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.taobao.com'</span>)</span><br><span class="line"><span class="comment"># 直接调用find_element,第一个参数是By.查找类型，第二个就是查找内容</span></span><br><span class="line">input_first = browser.find_element(By.ID,<span class="string">'q'</span>)</span><br><span class="line">print(input_first)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h4 id="多个元素-find-elements"><a href="#多个元素-find-elements" class="headerlink" title="多个元素 find_elements"></a>多个元素 find_elements</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser= webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.taobao.com'</span>)</span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br><span class="line">print(lis)</span><br><span class="line"><span class="comment"># 最后输出一个元组</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>搜索的就是淘宝网的一些分类</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/47.png" alt="示例"></p>
<ul>
<li>通用查找方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">browser= webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.taobao.com'</span>)</span><br><span class="line">lis = browser.find_elements(By.CSS_SELECTOR,<span class="string">'.service-bd li'</span>)</span><br><span class="line">print(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="元素交互操作"><a href="#元素交互操作" class="headerlink" title="元素交互操作"></a>元素交互操作</h3><ul>
<li>对获取的元素调用交互方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.taobao.com'</span>)</span><br><span class="line"><span class="comment"># 找到浏览框</span></span><br><span class="line">input = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line"><span class="comment"># 输入iPhone</span></span><br><span class="line">input.send_keys(<span class="string">'iPhone'</span>)</span><br><span class="line"><span class="comment"># 保持一秒</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 清空</span></span><br><span class="line">input.clear()</span><br><span class="line"><span class="comment"># 输入iPad</span></span><br><span class="line">input.send_keys(<span class="string">'iPad'</span>)</span><br><span class="line"><span class="comment"># 找到搜索按钮</span></span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)</span><br><span class="line"><span class="comment"># 点击搜索按钮</span></span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>

<h3 id="交互动作"><a href="#交互动作" class="headerlink" title="交互动作"></a>交互动作</h3><ul>
<li>把动作附加到动作链中串行执行</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/48.png" alt="示例"></p>
<h3 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h3><ul>
<li>有些动作没有分装成api，所以我们传入JavaScript语句实现这个动作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.zhihu.com/explore'</span>)</span><br><span class="line"><span class="comment"># 把页面下拉到底部</span></span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0,document.body.scrollHeight)'</span>)</span><br><span class="line"><span class="comment"># 显示内容</span></span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="获取元素信息"><a href="#获取元素信息" class="headerlink" title="获取元素信息"></a>获取元素信息</h3><h4 id="获取属性-2"><a href="#获取属性-2" class="headerlink" title="获取属性"></a>获取属性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">logo = browser.find_element_by_id(<span class="string">'zh-top-link-logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.get_attribute(<span class="string">'class'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="获取文本值"><a href="#获取文本值" class="headerlink" title="获取文本值"></a>获取文本值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.text)</span><br></pre></td></tr></table></figure>

<h4 id="获取ID，位置，标签名，大小"><a href="#获取ID，位置，标签名，大小" class="headerlink" title="获取ID，位置，标签名，大小"></a>获取ID，位置，标签名，大小</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.zhihu.com/explore'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input.id)</span><br><span class="line">print(input.location)</span><br><span class="line">print(input.tag_name)</span><br><span class="line">print(input.size)<span class="comment"># 宽高</span></span><br></pre></td></tr></table></figure>

<h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><ul>
<li>在父级frame中查找子级内容，必须实现frame切换</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url= <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line"><span class="comment">#请求</span></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="comment"># 传入frame id 实现切换</span></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"><span class="comment"># 找到拖拽的对象并打印</span></span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">print(source)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试在子级frame中查找父frame</span></span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Logo'</span>)</span><br><span class="line"><span class="comment"># 切换到父frame</span></span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line"><span class="comment"># 再次查找logo</span></span><br><span class="line">logo= browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.text)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/49.png" alt="示例"></p>
<h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><ul>
<li>当使用了隐式等待执行测试的时候，如果WebDriver没有在Dom中找到元素，将继续等待，超出设定时间后抛出找不到元素的异常，换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找DOM，默认时间为0</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">browser.get(<span class="string">'http://www.zhihu.com/explore'</span>)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure>

<h4 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h4><ul>
<li>指定一个等待条件</li>
<li>指定一个最长等待时间</li>
<li>如果在等待时间内符合等待条件，那么继续等待，等待到超出等待时间为止</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/50.png" alt="示例"></p>
<p>下面是我们的等待条件，非常灵活可变</p>
<h3 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 依次打开以下网站</span></span><br><span class="line">browser.get(<span class="string">'http://www.baidu.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'http://www.taobao.com/'</span>)</span><br><span class="line">browser.get(<span class="string">'http://www.python.org/'</span>)</span><br><span class="line"><span class="comment"># 退回上一个网站</span></span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 前进到下一个网站</span></span><br><span class="line">browser.forward()</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'http://www.zhihu.com/explore'</span>)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.add_cookie(&#123;<span class="string">'name'</span>:<span class="string">'name'</span>,<span class="string">'domain'</span>:<span class="string">'www.zhihu.com'</span>,<span class="string">'value'</span>:<span class="string">'jason'</span>&#125;)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line">print(browser.get_cookies())</span><br></pre></td></tr></table></figure>

<ul>
<li>我们看到第二次打印的时候我们加上去的cookie已经出现了</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/51.png" alt="示例"></p>
<h3 id="选项卡（窗口）管理"><a href="#选项卡（窗口）管理" class="headerlink" title="选项卡（窗口）管理"></a>选项卡（窗口）管理</h3><ul>
<li>通过执行一个js代码，打开一个新窗口</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"><span class="comment"># 新建一个窗口</span></span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line"><span class="comment">#打印选项卡代号</span></span><br><span class="line">print(browser.window_handles)</span><br><span class="line"><span class="comment"># 切换窗口</span></span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'http://www.taobao.com'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 回切</span></span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'http://python.org'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="异常处理-2"><a href="#异常处理-2" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/52.png" alt="示例"></p>
<h2 id="用Requests-正则表达式爬取猫眼电影Top100"><a href="#用Requests-正则表达式爬取猫眼电影Top100" class="headerlink" title="用Requests+正则表达式爬取猫眼电影Top100"></a>用Requests+正则表达式爬取猫眼电影Top100</h2><ul>
<li>流程框架</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/41.png" alt="示例"></p>
<h3 id="源码一览"><a href="#源码一览" class="headerlink" title="源码一览"></a>源码一览</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="comment"># 猫眼电影直接爬不了，我伪装了一个headers和一个代理</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0"</span>&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:1080"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 写这个get函数还需要进行一个错误判断，否则容易中断</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url,proxies = proxies,headers=headers)</span><br><span class="line">        response.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code ==<span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment"># 利用正则表达式，筛选出满足我们正则表达式的内容，</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a'</span>+<span class="string">'.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;.*?releasetime"(.*?)&lt;/p&gt;'</span>+<span class="string">'.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>,re.S)</span><br><span class="line">    items = re.findall(pattern,html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">2</span>],</span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">5</span>]+item[<span class="number">6</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 把我们的item写入 一个txt文件       </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(content,ensure_ascii=<span class="literal">False</span>)+<span class="string">'\n'</span>)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后用一个字符串叠加的方式，抓取1-10页的所有内容    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4?offset='</span>+str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        print(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"><span class="comment"># 用一个遍历的方式，爬取1-10张网页，相当于运行10次main函数，每次爬取一张</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">      main(i*<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/42.png" alt="示例"></p>
<h3 id="分步解析"><a href="#分步解析" class="headerlink" title="分步解析"></a>分步解析</h3><h4 id="第一步-获取网页源代码"><a href="#第一步-获取网页源代码" class="headerlink" title="第一步:获取网页源代码"></a>第一步:获取网页源代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="comment"># 猫眼电影直接爬不了，我伪装了一个headers和一个代理</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0"</span>&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:1080"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 在get()中加入proxies和headers参数</span></span><br><span class="line">        response = requests.get(url, proxies=proxies, headers=headers)</span><br><span class="line">        <span class="comment"># 注意，这里必须要设定encoding参数，否则会乱码</span></span><br><span class="line">        response.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="comment"># 做一个状态码的判断</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="comment"># 最后用一个字符串叠加的方式，抓取1-10页的所有内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4'</span></span><br><span class="line">    html = get_one_page(url)</span><br><span class="line"> 	print(html)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<h4 id="第二步：对目标信息编写正则表达式"><a href="#第二步：对目标信息编写正则表达式" class="headerlink" title="第二步：对目标信息编写正则表达式"></a>第二步：对目标信息编写正则表达式</h4><ul>
<li>我们可以看到，我们得信息源如下</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/43.png" alt="示例"></p>
<p>括号括起来的内容，就是我们想要的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dd&gt; 			获取到标签 &lt;dd&gt;</span><br><span class="line">.*? 			匹配任意字符串</span><br><span class="line">board-index 	匹配 board-index </span><br><span class="line">.*?				匹配任意字符串</span><br><span class="line">&gt; 				匹配&gt;</span><br><span class="line">(\d*) 			匹配我们要的排名，即括号内的内容</span><br><span class="line">&lt;&#x2F;i&gt;			匹配标签&lt;&#x2F;i&gt;</span><br><span class="line">.*?				匹配任意字符串</span><br><span class="line">data-src&#x3D;&quot;(.*?)&quot;匹配封面图片得url，即括号内的内容</span><br><span class="line">.*?name&quot;&gt; 		匹配name标签</span><br><span class="line">&lt;a.*?&gt;		匹配a标签和后续内容</span><br><span class="line">(.*?)			匹配我们电影名字，即括号内的内容</span><br><span class="line">&lt;&#x2F;a&gt;			匹配a标签</span><br><span class="line">.*?				匹配任意字符串</span><br><span class="line">star&quot;&gt;			匹配star标签</span><br><span class="line">(.*?)			匹配我们主演人名，即括号内的内容</span><br><span class="line">&lt;&#x2F;p&gt;			匹配p标签</span><br><span class="line">.*?				匹配任意字符串</span><br><span class="line">releasetime“&gt;   匹配releasetime“&gt; </span><br><span class="line">(.*?)			匹配上映时间，即括号内的内容		</span><br><span class="line">.*?integer&quot;&gt;	匹配任意字符串和integer&quot;&gt;</span><br><span class="line">(.*?)			匹配评分中的整数内容，即括号内的内容	</span><br><span class="line">&lt;&#x2F;i&gt;			匹配&lt;&#x2F;i&gt;标签</span><br><span class="line">.*?fraction&quot;&gt;	匹配任意字符串和fraction&quot;&gt;	</span><br><span class="line">(.*?)			匹配评分中的小数内容，即括号内的内容	</span><br><span class="line">.*? 			匹配任意字符串</span><br><span class="line">,</span><br><span class="line">re.S			匹配任意字符，包括换行符</span><br><span class="line">合起来就是</span><br><span class="line">  pattern &#x3D; re.compile(&#39;&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;&#x2F;i&gt;.*?data-src&#x3D;&quot;(.*?)&quot;.*?name&quot;&gt;&lt;a&#39;+&#39;.*?&gt;(.*?)&lt;&#x2F;a&gt;.*?star&quot;&gt;(.*?)&lt;&#x2F;p&gt;.*?releasetime&quot;(.*?)&lt;&#x2F;p&gt;&#39;+&#39;.*?integer&quot;&gt;(.*?)&lt;&#x2F;i&gt;.*?fraction&quot;&gt;(.*?)&lt;&#x2F;i&gt;.*?&lt;&#x2F;dd&gt;&#39;,re.S)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">	pattern = re.compile(<span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;.*?releasetime"(.*?)&lt;/p&gt;.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>,re.S)</span><br><span class="line">	items = re.findall(pattern,html)</span><br><span class="line">	print(items)</span><br></pre></td></tr></table></figure>

<ul>
<li>把他们变成字典形式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">	pattern = re.compile(<span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;.*?releasetime"(.*?)&lt;/p&gt;.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>,re.S)</span><br><span class="line">	items = re.findall(pattern,html)</span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line"> 	  	<span class="keyword">yield</span> &#123;</span><br><span class="line">           <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">           <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">           <span class="string">'title'</span>: item[<span class="number">2</span>],</span><br><span class="line">           <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">           <span class="comment"># 主演：克里斯蒂安·贝尔,希斯·莱杰,阿伦·伊克哈特</span></span><br><span class="line">           <span class="comment"># 这里直接从第三个字符冒号后开始切片截取</span></span><br><span class="line">           <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">           <span class="comment">#上映时间：2008-07-14(阿根廷)</span></span><br><span class="line">           <span class="comment"># 这里直接从冒号后面开始切片</span></span><br><span class="line">           <span class="string">'score'</span>: item[<span class="number">5</span>]+item[<span class="number">6</span>]<span class="comment"># 把评分拼接</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h5 id="这一步的代码"><a href="#这一步的代码" class="headerlink" title="这一步的代码"></a>这一步的代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re <span class="comment">#即regular expression</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0"</span>&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:1080"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, proxies=proxies, headers=headers)</span><br><span class="line">        response.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern = re.compile(</span><br><span class="line">        <span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a'</span> + <span class="string">'.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;.*?releasetime"(.*?)&lt;/p&gt;'</span> + <span class="string">'.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>,</span><br><span class="line">        re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">2</span>],</span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:],</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">5</span>] + item[<span class="number">6</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">( )</span>:</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4?'</span>  </span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure>

<h5 id="效果如图"><a href="#效果如图" class="headerlink" title="效果如图"></a>效果如图</h5><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/44.png" alt="示例"></p>
<h4 id="第三步，把他们写入到我的文件中"><a href="#第三步，把他们写入到我的文件中" class="headerlink" title="第三步，把他们写入到我的文件中"></a>第三步，把他们写入到我的文件中</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把我们的item写入 一个txt文件       </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line"><span class="comment"># 用一个with的形式，'a'代表往后追加的方式，encoding代表编码，否则就是一堆乱七八糟的</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 使用json的api需要导入json包</span></span><br><span class="line">        <span class="comment"># 防止乱码，还需要这样，把ensure_ascii设置成False</span></span><br><span class="line">        f.write(json.dumps(content,ensure_ascii=<span class="literal">False</span>)+<span class="string">'\n'</span>)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<h5 id="加入这个函数后，效果如图"><a href="#加入这个函数后，效果如图" class="headerlink" title="加入这个函数后，效果如图"></a>加入这个函数后，效果如图</h5><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/45.png" alt="示例"></p>
<h4 id="第四步，通过字符串改造的方式爬取10页"><a href="#第四步，通过字符串改造的方式爬取10页" class="headerlink" title="第四步，通过字符串改造的方式爬取10页"></a>第四步，通过字符串改造的方式爬取10页</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最后用一个字符串叠加的方式，抓取1-10页的所有内容    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4?offset='</span>+str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        print(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"><span class="comment"># 用一个遍历的方式，爬取1-10张网页，相当于运行10次main函数，每次爬取一张</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">      main(i*<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h4 id="番外，利用多线程实现秒爬（但是这样Top100顺序就乱了）"><a href="#番外，利用多线程实现秒爬（但是这样Top100顺序就乱了）" class="headerlink" title="番外，利用多线程实现秒爬（但是这样Top100顺序就乱了）"></a>番外，利用多线程实现秒爬（但是这样Top100顺序就乱了）</h4><ul>
<li>开头引入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br></pre></td></tr></table></figure>

<ul>
<li>对结尾进行改造</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># 这是一个进程池，池还没有满就创建进程并运行，否则就待命</span></span><br><span class="line">	pool = Pool()</span><br><span class="line">	<span class="comment"># 把map中的元素提取出来创建进程</span></span><br><span class="line">	pool.map(main, [i*<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br></pre></td></tr></table></figure>

<h3 id="如法炮制，我也制作了一个爬取豆瓣top250的电影"><a href="#如法炮制，我也制作了一个爬取豆瓣top250的电影" class="headerlink" title="如法炮制，我也制作了一个爬取豆瓣top250的电影"></a>如法炮制，我也制作了一个爬取豆瓣top250的电影</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0"</span>&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:1080"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, proxies=proxies, headers=headers)</span><br><span class="line">        <span class="comment"># 注意，这里必须要设定encoding参数，否则会乱码</span></span><br><span class="line">        response.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        <span class="comment"># 做一个状态码的判断</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'&lt;li&gt;.*?em.*?&gt;(\d*)&lt;/em&gt;.*?src="(.*?)".*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?"title"&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?other"&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?bd"&gt;.*?class=""&gt;\s(.*?)&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;br&gt;(.*?)&amp;nbsp;/&amp;nbsp;(.*?)&amp;nbsp;/&amp;nbsp;(.*?)&lt;/p&gt;.*?average"&gt;(\d.\d).*?inq"&gt;(.*?)&lt;/span&gt;'</span>,re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">2</span>],</span><br><span class="line">            <span class="string">'other title'</span>: item[<span class="number">3</span>]+item[<span class="number">4</span>],</span><br><span class="line">            <span class="string">'director'</span>: item[<span class="number">5</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">6</span>].strip()[<span class="number">3</span>:] ,</span><br><span class="line">            <span class="string">'time'</span>:item[<span class="number">7</span>].strip()[<span class="number">0</span>:],</span><br><span class="line">            <span class="string">'country'</span>:item[<span class="number">8</span>],</span><br><span class="line">            <span class="string">'sort'</span>:item[<span class="number">9</span>].strip()[:<span class="number">20</span>],</span><br><span class="line">            <span class="string">'score'</span>:item[<span class="number">10</span>],</span><br><span class="line">            <span class="string">'quote'</span>:item[<span class="number">11</span>]</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment"># 把我们的item写入 一个txt文件a</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'result.txt'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(content,ensure_ascii=<span class="literal">False</span>)+<span class="string">'\n'</span>)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    url = <span class="string">'https://movie.douban.com/top250?start='</span>+str(offset)+<span class="string">'&amp;filter='</span></span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        print(item)</span><br><span class="line">        write_to_file(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            main(i * <span class="number">25</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>结果如下</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/54.png" alt="示例"></p>
<h2 id="用selenium-Chrome-爬取淘宝宝贝信息"><a href="#用selenium-Chrome-爬取淘宝宝贝信息" class="headerlink" title="用selenium + Chrome 爬取淘宝宝贝信息"></a>用selenium + Chrome 爬取淘宝宝贝信息</h2><h4 id="所用工具：-selenium包，Chrome-driver无头浏览器，pymongo-MongoDB数据库"><a href="#所用工具：-selenium包，Chrome-driver无头浏览器，pymongo-MongoDB数据库" class="headerlink" title="所用工具： selenium包，Chrome.driver无头浏览器，pymongo+MongoDB数据库"></a>所用工具： selenium包，Chrome.driver无头浏览器，pymongo+MongoDB数据库</h4><h3 id="源码一览-1"><a href="#源码一览-1" class="headerlink" title="源码一览"></a>源码一览</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(MONGO_URL)</span><br><span class="line">db = client[MONGO_DB]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(<span class="string">'http://www.taobao.com'</span> )</span><br><span class="line">        input = wait.until(EC.presence_of_element_located((By.XPATH, <span class="string">'//*[@id="q"]'</span>)))</span><br><span class="line">        submit = wait.until(</span><br><span class="line">            EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'#J_TSearchForm &gt; div.search-button &gt; button'</span>)))</span><br><span class="line">        input.send_keys(<span class="string">'美食'</span>)</span><br><span class="line">        submit.click()</span><br><span class="line">        total = wait.until(</span><br><span class="line">            EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.total'</span>)))</span><br><span class="line">        get_products()</span><br><span class="line">        <span class="keyword">return</span> total.text</span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        <span class="keyword">return</span> search()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_page</span><span class="params">(page_number)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        input = wait.until(</span><br><span class="line">            EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input'</span>)))</span><br><span class="line">        submit = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit'</span>)))</span><br><span class="line">        input.clear()</span><br><span class="line">        input.send_keys(page_number)</span><br><span class="line">        submit.click()</span><br><span class="line">        wait.until(EC.text_to_be_present_in_element(</span><br><span class="line">            (By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; ul &gt; li.item.active &gt; span'</span>),str(page_number)))</span><br><span class="line">        get_products()</span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        next_page(page_number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_products</span><span class="params">()</span>:</span></span><br><span class="line">    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,<span class="string">'#mainsrp-itemlist .items .item'</span>)))</span><br><span class="line">    html=browser.page_source</span><br><span class="line">    doc=pq(html)</span><br><span class="line">    items = doc(<span class="string">'#mainsrp-itemlist .items .item'</span>).items()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        product = &#123;</span><br><span class="line">            <span class="string">'image'</span>: item.find(<span class="string">'.pic .img'</span>).attr(<span class="string">'src'</span>),</span><br><span class="line">            <span class="string">'price'</span>: item.find(<span class="string">'.price'</span>).text(),</span><br><span class="line">            <span class="string">'deal'</span>: item.find(<span class="string">'.deal-cnt'</span>).text()[:<span class="number">-3</span>],</span><br><span class="line">            <span class="string">'title'</span>: item.find(<span class="string">'.title'</span>).text(),</span><br><span class="line">            <span class="string">'shop'</span>: item.find(<span class="string">'.shop'</span>).text(),</span><br><span class="line">            <span class="string">'location'</span>: item.find(<span class="string">'.location'</span>).text(),</span><br><span class="line">        &#125;</span><br><span class="line">        print(product)</span><br><span class="line">        save_to_mongo(product)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_mongo</span><span class="params">(result)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> db[MONGO_TABLE].insert(result):</span><br><span class="line">            print(<span class="string">'存储到MONGODB成功'</span>,result)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">'存储到MonGoDB失败'</span>,result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    total = search()</span><br><span class="line">    total = int(re.compile(<span class="string">'(\d+)'</span>).search(total).group(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, total + <span class="number">1</span>):</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        next_page(i)</span><br><span class="line">    browser.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="成果展示-1"><a href="#成果展示-1" class="headerlink" title="成果展示"></a>成果展示</h3><p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/55.png" alt="示例"></p>
<h3 id="分步解析-1"><a href="#分步解析-1" class="headerlink" title="分步解析"></a>分步解析</h3><h4 id="搜索关键字"><a href="#搜索关键字" class="headerlink" title="搜索关键字"></a>搜索关键字</h4><ul>
<li>我们这一步的目的就是模拟搜索关键字的操作<ul>
<li>找到搜索框</li>
<li>点击搜索</li>
</ul>
</li>
<li>我们需要判断浏览器是否已经达到了我们想要的操作，要实现这一点，selenium中的wait模块可以解决<a href="https://selenium-python.readthedocs.io/waits.html" target="_blank" rel="noopener">Selenium官方文档</a> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">"http://somedomain/url_that_delays_loading"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 设置时间</span></span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        <span class="comment"># 设置条件，设置要加载的目标</span></span><br><span class="line">        EC.presence_of_element_located((By.ID<span class="comment">#这是个选择器, "myDynamicElement"))</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>

<p>在我们的代码中，需要改一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wait = WebDriverWait(browser, <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(<span class="string">'http://www.taobao.com'</span> )</span><br><span class="line">        input = </span><br><span class="line">        <span class="comment"># 只要在dev_tool中在标签点击右键copy，选择类型即可</span></span><br><span class="line">        wait.until(EC.presence_of_element_located((By.XPATH, <span class="string">'//*[@id="q"]'</span>)))<span class="comment"># 这里找的是输入框直到加载出来才完成操作</span></span><br><span class="line">        submit = wait.until(</span><br><span class="line">            <span class="comment"># 这里找的是确定按钮，这里的条件是等到按钮能够点击，才结束</span></span><br><span class="line">            EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'#J_TSearchForm &gt; div.search-button &gt; button'</span>)))</span><br><span class="line">        <span class="comment"># 输入美食这个关键字</span></span><br><span class="line">        input.send_keys(<span class="string">'美食'</span>)</span><br><span class="line">        submit.click()</span><br><span class="line">        total = wait.until(</span><br><span class="line">            <span class="comment"># 这里找的是一共有多少页的显示框，条件是当这个框显示出来的时候</span></span><br><span class="line">            EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.total'</span>)))</span><br><span class="line">        <span class="comment"># 返回我们的总页数</span></span><br><span class="line">        <span class="keyword">return</span> total.text</span><br><span class="line">    <span class="comment"># 用except捕捉这个错误</span></span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        <span class="comment"># 如果出现了错误，我们递归一下</span></span><br><span class="line">        <span class="keyword">return</span> search()</span><br></pre></td></tr></table></figure>

<ul>
<li>在main函数中的操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 这里调用search</span></span><br><span class="line">    search()</span><br><span class="line">    <span class="comment"># total接受了search()返回的内容，我们要在这里提取出总页数来</span></span><br><span class="line">    total = search()</span><br><span class="line">    <span class="comment"># 利用正则表达式模块剔除汉字获得数字，在total中serach，然后类型转换为int类型</span></span><br><span class="line">    total = int(re.compile(<span class="string">'(\d+)'</span>).search(total).group(<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 通过一个循环，从第二页开始一直到最后，用range实现遍历操作</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, total + <span class="number">1</span>):</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        next_page(i)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<h4 id="分析页码并翻页"><a href="#分析页码并翻页" class="headerlink" title="分析页码并翻页"></a>分析页码并翻页</h4><ul>
<li><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/57.png" alt="示例"></li>
</ul>
<p>我们可以看到，要实现这个翻页，一页一页按那个高亮按钮不太实际（每一个按钮的标签可能都不一样），所以我们在搜索框中输入第几页，然后点击确定后，再做一个判断即可完成</p>
<ul>
<li>所以我们首先要拿到第几页这个输入框，然后拿到旁边的确定按钮，最后传入数字点击确认</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_page</span><span class="params">(page_number)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获取到目标输入框</span></span><br><span class="line">        input = wait.until(</span><br><span class="line">            EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input'</span>)))</span><br><span class="line">        <span class="comment"># 获取到确认提交按钮</span></span><br><span class="line">        submit = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit'</span>)))</span><br><span class="line">        <span class="comment"># 首先清除框中内容</span></span><br><span class="line">        input.clear()</span><br><span class="line">        <span class="comment"># 然后把这个循环对应得号码传入</span></span><br><span class="line">        input.send_keys(page_number)</span><br><span class="line">        <span class="comment"># 点击确认</span></span><br><span class="line">        submit.click()</span><br><span class="line">        <span class="comment">#这里做一个text_to_be_present_in_element类型得判断，就是当高亮页面标中的内容与我们传入的页数一致的时候，说明完成操作</span></span><br><span class="line">        wait.until(EC.text_to_be_present_in_element(</span><br><span class="line">            (By.CSS_SELECTOR, <span class="string">'#mainsrp-pager &gt; div &gt; div &gt; div &gt; ul &gt; li.item.active &gt; span'</span>),str(page_number)))</span><br><span class="line">        <span class="comment"># 最后捕捉错误信息，如果出错那么重新来过</span></span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        next_page(page_number)</span><br></pre></td></tr></table></figure>

<h4 id="分析提取商品内容"><a href="#分析提取商品内容" class="headerlink" title="分析提取商品内容"></a>分析提取商品内容</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_products</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 先做一个判断，如果这个地方通过，说明这个页面中所有的宝贝信息都已经加载好了</span></span><br><span class="line">    <span class="comment"># 这个所有的宝贝标签都是这个标签下的子标签</span></span><br><span class="line">    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR,<span class="string">'#mainsrp-itemlist .items .item'</span>)))</span><br><span class="line">    <span class="comment"># 获取网页源代码信息</span></span><br><span class="line">    html=browser.page_source</span><br><span class="line">    <span class="comment"># 利用pyquery解析我们的网页源代码</span></span><br><span class="line">    doc=pq(html)</span><br><span class="line">    <span class="comment"># 然后把源代码这个标签下的所有</span></span><br><span class="line">    items = doc(<span class="string">'#mainsrp-itemlist .items .item'</span>).items()<span class="comment"># 获取所有选择的内容</span></span><br><span class="line">    <span class="comment"># 分析每个item中的内容</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        product = &#123;</span><br><span class="line">            <span class="comment"># 找到这个标签中，属性为src的内容作为我们的图片信息</span></span><br><span class="line">            <span class="string">'image'</span>: item.find(<span class="string">'.pic .img'</span>).attr(<span class="string">'src'</span>),</span><br><span class="line">            <span class="comment"># 找到这个price标签 ，提取价格</span></span><br><span class="line">            <span class="string">'price'</span>: item.find(<span class="string">'.price'</span>).text(),</span><br><span class="line">            <span class="comment"># 找到.deal-cnt这个标签，然后从开头直到倒数第三个，为了截取我们想要的成交量</span></span><br><span class="line">            <span class="string">'deal'</span>: item.find(<span class="string">'.deal-cnt'</span>).text()[:<span class="number">-3</span>],</span><br><span class="line">            <span class="comment"># 找到class为title的标签，提取标题</span></span><br><span class="line">            <span class="string">'title'</span>: item.find(<span class="string">'.title'</span>).text(),</span><br><span class="line">            <span class="comment"># 找到class= shop的标签，提取商家名字</span></span><br><span class="line">            <span class="string">'shop'</span>: item.find(<span class="string">'.shop'</span>).text(),</span><br><span class="line">            <span class="comment"># 找到class= location的标签，提取卖家地点</span></span><br><span class="line">            <span class="string">'location'</span>: item.find(<span class="string">'.location'</span>).text(),</span><br><span class="line">        &#125;</span><br><span class="line">        print(product)</span><br></pre></td></tr></table></figure>

<ul>
<li>写完get_products操作以后，需要在一开始的search函数中调用一下（因为next_page(page_number)是从第二页开始的，所以要获取第一页的宝贝信息</li>
<li>此外在next_page 这个函数中也要调用，来获得2-100页的所有宝贝信息</li>
</ul>
<h4 id="存储到MongoDB"><a href="#存储到MongoDB" class="headerlink" title="存储到MongoDB"></a>存储到MongoDB</h4><p>新建一个config文件，存储一些连接到MongoDB的基本信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 账户时localhost</span></span><br><span class="line">MONGO_URL = <span class="string">'localhost'</span></span><br><span class="line"><span class="comment"># 数据库是taobao，如果没有那么会自动新建</span></span><br><span class="line">MONGO_DB = <span class="string">'taobao'</span></span><br><span class="line"><span class="comment"># 数据表名叫做product</span></span><br><span class="line">MONGO_TABLE = <span class="string">'product'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在开头设置一下配置信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="comment"># 设定账户</span></span><br><span class="line">client = pymongo.MongoClient(MONGO_URL)</span><br><span class="line"><span class="comment"># 设定数据库</span></span><br><span class="line">db = client[MONGO_DB]</span><br></pre></td></tr></table></figure>

<ul>
<li>写一个写入函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_mongo</span><span class="params">(result)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 插入到目标数据表中，并判断成功与否</span></span><br><span class="line">        <span class="keyword">if</span> db[MONGO_TABLE].insert(result):</span><br><span class="line">            print(<span class="string">'存储到MONGODB成功'</span>,result)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">'存储到MonGoDB失败'</span>,result)</span><br></pre></td></tr></table></figure>

<ul>
<li>然后再get_product函数的item遍历中调用，把每条宝贝信息传入数据库</li>
</ul>
<h4 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h4><ul>
<li><p>虽然是照着视频一步一步写下来的，但是中间仍然出现了很多错误和困难</p>
</li>
<li><p>淘宝网现在出了反爬虫机制，如果爬的太快我们就会受到永远都通不过的滑块验证码，这是因为淘宝检测出了你使用的webdriver，我在晚上爬取一次后换个关键词，也仍然解决不了问题（看来有冷却时间）第二天又运行一遍后才回复正常。不过我们写爬虫只是练手，并不要求高效率。所以我把等待时间调整为每次爬取一页停留十秒，这样在第一次爬取的时候可以轻松爬完100页。（再试一次就又有问题了）</p>
</li>
<li><p>通过这个爬虫经历学会了如何把数据存储到MongoDB中，这样稍作修改，那么我先前爬取的豆瓣电影和猫眼电影都可以通过这种方式存储了</p>
</li>
<li><p>这是两张电影排行表的最终效果<img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/58.png" alt="示例"></p>
</li>
</ul>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/59.png" alt="示例"></p>
<p><img src="/2020/04/30/%E4%BB%8E-1%E5%BC%80%E5%A7%8B%E7%9A%84python%E7%88%AC%E8%99%AB/60.png" alt="示例"></p>
<h2 id="有话要说"><a href="#有话要说" class="headerlink" title="有话要说"></a>有话要说</h2><p>python爬虫的故事到这里还并没有结束，只不过下面开始要进入PySpider框架和Scrapy框架的学习了，所占用的时间和空间过于繁琐，故另起炉灶。</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ul>
<li>堆排序是一种树形选择排序算法，简单选择排序算法每次选择一个关键词最小的记录需要O(n)的时间，而堆排序选择一个关键词最小的机组只需要O(logn)的时间</li>
<li>堆可以看作一颗完全二叉树的顺序存储结构，在这颗完全二叉树中，如果每一个节点的值都大于等于左右孩子的值，称为最大堆。如果每一个节点的值都小于等于左右孩子的值，成为最小堆。左右孩子谁大谁小不要求。</li>
<li>完全二叉树中除了最后一层，其他节点都是满的。最后一层是从左到右按照顺序出现的</li>
</ul>
<h3 id="完全二叉树举例"><a href="#完全二叉树举例" class="headerlink" title="完全二叉树举例"></a>完全二叉树举例</h3><p><img src="/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/2.png" alt="示例"></p>
<ul>
<li><p>完全二叉树可以顺序存储，存到一个数组当中。上面的二叉树是一个最大堆。</p>
</li>
<li><p>如果这是一个完全二叉树，那么这个节点键值为i的左孩子一定是2i，右孩子一定是2i+1.他的父亲节点一定是i/2.</p>
</li>
<li><p>根据完全二叉树的性值，如果一个节点的下标为i,其左孩子下标为2i,其有孩子下标为2i+1,其双亲的下标为i/2.且具有n个节点的完全二叉树的深度为$\log_2n +1$</p>
</li>
<li><p>堆排序充分利用堆顶记录最大最小的性质进行排序，每次将对顶的记录交换到最后，剩余记录调整为堆即可</p>
</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>构建初始堆</li>
<li>堆顶和最后一个记录交换，即r[1]和r[n]交换，将r[1…n-1]重新调整为堆</li>
<li>堆顶和最后一个记录交换，即r[1]和r[n-1]交换，将r[1…n-2]重新调整为堆</li>
<li>循环n-1次，得到一个有序序列</li>
</ol>
<p>因为构建初始堆需要反复调整为堆，所以先说明如何调整堆，然后再讲解如何构建初始堆，然后再讲解如何构建初始堆，进行堆排序</p>
<h4 id="调整堆（下沉）"><a href="#调整堆（下沉）" class="headerlink" title="调整堆（下沉）"></a>调整堆（下沉）</h4><ul>
<li>交换后除了堆顶之外，其他节点都满足最大堆的定义，只需要将堆顶执行“下沉”操作就行了。</li>
<li>“下沉”操作：堆顶与左右孩子比较，如果比孩子大，则调整为堆；如果比孩子小，则与较大的孩子交换，交换到新的位置后，继续向下比较，从根节点一直比较到叶子</li>
<li>排好序之后，根节点就不在堆之内了</li>
<li>下面是一个在最大堆中提取根节点后的调整堆操作，可以清楚的观察到是如何比较完成下沉的</li>
</ul>
<p><img src="/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/3.gif" alt="示例"></p>
<p>视频截取自可视化算法网站  <a href="https://visualgo.net/zh" target="_blank" rel="noopener">visualgo.net</a>,太香了，推荐给大家</p>
<h5 id="下沉的代码实现"><a href="#下沉的代码实现" class="headerlink" title="下沉的代码实现"></a>下沉的代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k ,<span class="keyword">int</span> n)</span><span class="comment">//下沉操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*k&lt;=n)<span class="comment">//如果有左孩子，k的左孩子为2k，右孩子为2k+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n&amp;&amp;A[j]&lt;A[j+<span class="number">1</span>])<span class="comment">//如果有右孩子，且左孩子比右孩子小</span></span><br><span class="line">            j++;<span class="comment">//j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(A[k]&gt;A[j])<span class="comment">//比“较大的孩子”大</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 已满足堆</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            swap(A[k],A[j]);<span class="comment">//与较大的孩子交换</span></span><br><span class="line">        k=j;<span class="comment">//k指向交换后的新位置，继续向下比较，一直下沉到叶子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构建初始堆"><a href="#构建初始堆" class="headerlink" title="构建初始堆"></a>构建初始堆</h4><ul>
<li>构建初始堆的过程：首先按照完全二叉树顺序构建一棵完全二叉树。然后从最后一个分支节点n/2开始调整堆，依次将序号为 n/2-1,n/2-2,n/2-3……,1的节点执行下沉操作调整为堆。因为从叶子节点没什么可以调整的。没办法下沉了</li>
<li>下面是一个构建初始堆的操作</li>
</ul>
<p><img src="/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/2.gif" alt="示例"></p>
<h5 id="构建初始堆代码实现"><a href="#构建初始堆代码实现" class="headerlink" title="构建初始堆代码实现"></a>构建初始堆代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		Sink(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><ul>
<li>构建初始堆之后， 开始进行堆排序。因为最大堆的堆顶是最大的记录，可以将堆顶交换到最后一个元素的位置，然后堆顶执行下沉操作，调整r[1…n-1]为堆即可。重复此过程，直到剩余一个节点，得到有序序列</li>
<li>下面是一个完整的堆排序操作</li>
</ul>
<p><img src="/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/1.gif" alt="示例"></p>
<h5 id="堆排序代码实现"><a href="#堆排序代码实现" class="headerlink" title="堆排序代码实现"></a>堆排序代码实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//堆排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CreatHeap(n);</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(A[<span class="number">1</span>],A[n--]);<span class="comment">//堆顶和最后一个记录交换，交换后n-1</span></span><br><span class="line">        sink(<span class="number">1</span>,n);<span class="comment">//堆顶下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>堆排序的运行时间主要耗费在构建初始堆和反复调整堆上。构建初始堆需要从最后一个分支节点（n/2)到第一个节点进行下沉操作，下沉操作最多达到树的深度logn,因此构建初始堆的时间复杂度的上界是O(nlogn)，而实际上这是一个比较大的上界，大多数的分支节点下沉的操作少于logn 。构建n个记录的堆，只需要少于2n次的比较和少于n次的交换，构建初始堆的时间复杂度是线性阶O(n)。堆排序的过程中，每一趟排序需要从堆顶下沉到叶子，下沉操作为树的深度logn ，一共n-1次排序，总的时间复杂度为O(nlogn)</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>交换记录时需要一个辅助空间，所以空间复杂度为O(1)</p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>对排序的时候多次交换关键字，可能会发生相等关键字排序前后位置不一致的情况，因此堆排序是不稳定的排序方法</p>
<p><img src="/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/0.png" alt="示例"></p>
<p><img src="/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/1.png" alt="示例"></p>
<h3 id="代码一览"><a href="#代码一览" class="headerlink" title="代码一览"></a>代码一览</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="keyword">int</span> A[Maxsize];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k ,<span class="keyword">int</span> n)</span><span class="comment">//下沉操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*k&lt;=n)<span class="comment">//如果有左孩子，k的左孩子为2k，右孩子为2k+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n&amp;&amp;A[j]&lt;A[j+<span class="number">1</span>])<span class="comment">//如果有右孩子，且左孩子比右孩子小</span></span><br><span class="line">            j++;<span class="comment">//j指向右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(A[k]&gt;A[j])<span class="comment">//比“较大的孩子”大</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 已满足堆</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            swap(A[k],A[j]);<span class="comment">//与较大的孩子交换</span></span><br><span class="line">        k=j;<span class="comment">//k指向交换后的新位置，继续向下比较，一直下沉到叶子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHeap</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        sink(i,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"堆排序的结果"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">"  "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//堆排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=n;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    CreatHeap(n);</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(A[<span class="number">1</span>],A[n--]);<span class="comment">//堆顶和最后一个记录交换，交换后n-1</span></span><br><span class="line">        sink(<span class="number">1</span>,n);<span class="comment">//堆顶下沉</span></span><br><span class="line">        <span class="built_in">print</span>(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入数列中的元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入数列中的元素"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    HeapSort(n);</span><br><span class="line">    <span class="built_in">print</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Data_structure</tag>
        <tag>Rank</tag>
      </tags>
  </entry>
  <entry>
    <title>如何把数据存储到MySql中</title>
    <url>/2020/04/24/%E5%A6%82%E4%BD%95%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0MySql%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="如何把数据存储到MySql中"><a href="#如何把数据存储到MySql中" class="headerlink" title="如何把数据存储到MySql中"></a>如何把数据存储到MySql中</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>这篇博客主要记录了在学习了老师得课程之后如何把爬取下来的文件存储到MySql中去</li>
<li>数据库的安装和配置在这里略去不讲</li>
<li>目标如下：</li>
<li><ol>
<li>数据库存储爬取的数据</li>
<li>爬取新闻页面之前先查询数据库，是否该url已经爬取过了</li>
<li>设置爬虫定时工作</li>
</ol>
</li>
</ul>
<h3 id="用npm引入mysql模块"><a href="#用npm引入mysql模块" class="headerlink" title="用npm引入mysql模块"></a>用npm引入mysql模块</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install mysql --save</span><br></pre></td></tr></table></figure>

<h3 id="给root用户授权从客户端访问"><a href="#给root用户授权从客户端访问" class="headerlink" title="给root用户授权从客户端访问"></a>给root用户授权从客户端访问</h3><p>在mysql中敲入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user&#39;root&#39;@&#39;localhost&#39;identified with mysql_native_password by &#39;root&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<ul>
<li>目的是让其他客户端，也能访问我的mysql </li>
</ul>
<p><img src="/2020/04/24/%E5%A6%82%E4%BD%95%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0MySql%E4%B8%AD/1.png" alt="示例"></p>
<h3 id="使用mysql创造一个数据库和一张用来存放数据的表"><a href="#使用mysql创造一个数据库和一张用来存放数据的表" class="headerlink" title="使用mysql创造一个数据库和一张用来存放数据的表"></a>使用mysql创造一个数据库和一张用来存放数据的表</h3><ul>
<li>建库代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database crawl;(crawl就是新的数据库名字)</span><br><span class="line">use crawl;(切换数据库)</span><br></pre></td></tr></table></figure>

<ul>
<li>建表代码，老师的最为详细，我一一来解释，同时也会附上我的建表码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;fetches&#96; (</span><br><span class="line">    &#x2F;&#x2F;id_fetches 就是每段信息的标号，默认从1开始递增</span><br><span class="line">  &#96;id_fetches&#96; int(11)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#x2F;&#x2F;url 就是我们爬取个网站的链接</span><br><span class="line">  &#96;url&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F;source_name 就是每个网站的题目，比如什么值得买，中国新闻网，网易等等</span><br><span class="line">  &#96;source_name&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F;source_encoding 就是编码，可以实GBK，也可以是UTF-8，根据网站编码来定</span><br><span class="line">  &#96;source_encoding&#96; varchar(45) DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F;title 就是标题</span><br><span class="line">  &#96;title&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F;keywords 就是关键字</span><br><span class="line">  &#96;keywords&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F; author 就是作者</span><br><span class="line">  &#96;author&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F; publish_date 就是出版时间</span><br><span class="line">  &#96;publish_date&#96; date DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F; crawltime 就是爬取信息的时间</span><br><span class="line">  &#96;crawltime&#96; datetime DEFAULT NULL,</span><br><span class="line">    &#x2F;&#x2F;content就是内容，主体</span><br><span class="line">  &#96;content&#96; longtext,</span><br><span class="line">    &#x2F;&#x2F; createtime就是创造这行数据所用的时间</span><br><span class="line">  &#96;createtime&#96; datetime DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">    &#x2F;&#x2F;下面是默认设置</span><br><span class="line">  PRIMARY KEY (&#96;id_fetches&#96;),&#x2F;&#x2F;primary key是主键的意思</span><br><span class="line">1，主键非空，也就是说被设定为主键的列在插入数据的时候就不能为空，如果为度空就会报错。</span><br><span class="line">2，主键是唯一的，一个表通过一个主键可以确定一条记录。</span><br><span class="line">3，有时可以用专两个字段来建立主键，这叫联合主键。这种情况出现在当一个字段无法唯一的时候要借助属另一个字段来确保唯一性的时候。</span><br><span class="line"> &#x2F;&#x2F;这里，把id设为主键，就是用来标号的，</span><br><span class="line">  UNIQUE KEY &#96;id_fetches_UNIQUE&#96; (&#96;id_fetches&#96;),&#x2F;&#x2F;就是说id是不能重复的</span><br><span class="line">  UNIQUE KEY &#96;url_UNIQUE&#96; (&#96;url&#96;)&#x2F;&#x2F;就是说url字段是不能重复的</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;&#x2F;&#x2F;编码</span><br></pre></td></tr></table></figure>

<ul>
<li>我爬取的数据分类比较少，除了改动一行代码的名字之外，删了几行不需要的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;fetches&#96; (</span><br><span class="line">  &#96;id_fetches&#96; int(11)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;url&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">  &#96;source_name&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">  &#96;source_encoding&#96; varchar(45) DEFAULT NULL,</span><br><span class="line">  &#96;interface_format&#96; longtext,&#x2F;&#x2F;这个其实就是存放标题的</span><br><span class="line">  &#96;crawltime&#96; datetime DEFAULT NULL,</span><br><span class="line">  &#96;content_format&#96; longtext,</span><br><span class="line">  &#96;createtime&#96; datetime DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (&#96;id_fetches&#96;),</span><br><span class="line">  UNIQUE KEY &#96;id_fetches_UNIQUE&#96; (&#96;id_fetches&#96;),</span><br><span class="line">  UNIQUE KEY &#96;url_UNIQUE&#96; (&#96;url&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<h3 id="用node调用mysql"><a href="#用node调用mysql" class="headerlink" title="用node调用mysql"></a>用node调用mysql</h3><ul>
<li>我们通过引用分文件的方式。也就是说新建一个mysql.js文件，在里面写上具体操作，然后在主爬虫程序中引入即可,我们还是通过讲解代码的方式来介绍。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这个文件里真正引入了mysql模块</span></span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">"mysql"</span>);</span><br><span class="line"><span class="comment">//定义了mysql的一些基本信息</span></span><br><span class="line"><span class="keyword">var</span> pool = mysql.createPool(&#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,<span class="comment">//本机</span></span><br><span class="line">    user: <span class="string">'root'</span>,<span class="comment">//用户名，这里是root</span></span><br><span class="line">    password: <span class="string">'root'</span>,<span class="comment">//密码，这里也是root</span></span><br><span class="line">    database: <span class="string">'crawl'</span><span class="comment">//database:要导入的数据库，这里是crawl数据库</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//下面是两种不同的链接数据库的方式，我们在没有系统学习mysql之前，略去不讲</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="function"><span class="keyword">function</span>(<span class="params">sql, sqlparam, callback</span>) </span>&#123;</span><br><span class="line">    pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">err, conn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            callback(err, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.query(sql, sqlparam, <span class="function"><span class="keyword">function</span>(<span class="params">qerr, vals, fields</span>) </span>&#123;</span><br><span class="line">                conn.release(); <span class="comment">//释放连接 </span></span><br><span class="line">                callback(qerr, vals, fields); <span class="comment">//事件驱动回调 </span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> query_noparam = <span class="function"><span class="keyword">function</span>(<span class="params">sql, callback</span>) </span>&#123;</span><br><span class="line">    pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">err, conn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            callback(err, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.query(sql, <span class="function"><span class="keyword">function</span>(<span class="params">qerr, vals, fields</span>) </span>&#123;</span><br><span class="line">                conn.release(); <span class="comment">//释放连接 </span></span><br><span class="line">                callback(qerr, vals, fields); <span class="comment">//事件驱动回调 </span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">exports.query = query;</span><br><span class="line">exports.query_noparam = query_noparam;</span><br></pre></td></tr></table></figure>

<h3 id="改写主函数脚本—主要两方面"><a href="#改写主函数脚本—主要两方面" class="headerlink" title="改写主函数脚本—主要两方面"></a>改写主函数脚本—主要两方面</h3><h4 id="在文件开始"><a href="#在文件开始" class="headerlink" title="在文件开始"></a>在文件开始</h4><p>需要用var mysql = require(‘./mysql.js’）,前提是两个文件放在同一个文件夹下。关于js中调用同文件夹的语法，这里略去不讲</p>
<h4 id="在newsGet函数的最后修改"><a href="#在newsGet函数的最后修改" class="headerlink" title="在newsGet函数的最后修改"></a>在newsGet函数的最后修改</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为老师的代码更为详细，所以那他的举例子，具体到我自己写的每个爬虫，只需要在原基础上删改即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面注释掉的是原来写入文件的操作，现在我们要把他写入数据库中</span></span><br><span class="line"><span class="comment">// var filename = source_name + "_" + (new Date()).toFormat("YYYY-MM-DD") +</span></span><br><span class="line"><span class="comment">//     "_" + myURL.substr(myURL.lastIndexOf('/') + 1) + ".json";</span></span><br><span class="line"><span class="comment">// 存储json</span></span><br><span class="line"><span class="comment">// fs.writeFileSync(filename, JSON.stringify(fetch));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//INSERT INTO fetches就是要把信息写入我们建立出来的fetches表中</span></span><br><span class="line"><span class="comment">//后面跟着的就是我们要写入的数据种类，注意，要一一对应：括号内的类型，创建表的时候定义的类型，问号个数</span></span><br><span class="line"><span class="keyword">var</span> fetchAddSql = <span class="string">'INSERT INTO fetches(url,source_name,source_encoding,title,'</span> </span><br><span class="line">+<span class="string">'keywords,author,publish_date,crawltime,content) VALUES(?,?,?,?,?,?,?,?,?)'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个params数组中的值，就是要具体传给上面问号里的，所以也要一一对应</span></span><br><span class="line"><span class="keyword">var</span> fetchAddSql_Params = [fetch.url, fetch.source_name, fetch.source_encoding,</span><br><span class="line">            fetch.title, fetch.keywords, fetch.author, fetch.publish_date,</span><br><span class="line">            fetch.crawltime.toFormat(<span class="string">"YYYY-MM-DD HH24:MI:SS"</span>), fetch.content</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后，执行sql，数据库中fetch表里的url属性是unique的，不会把重复的url内容写入数据库</span></span><br><span class="line">mysql.query(fetchAddSql, fetchAddSql_Params, <span class="function"><span class="keyword">function</span>(<span class="params">qerr, vals, fields</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (qerr) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(qerr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">//mysql写入</span></span><br></pre></td></tr></table></figure>

<h3 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h3><p>经过了上面的操作，我们来分别看看老师的爬虫和我的爬虫分别爬取到的信息吧！</p>
<ul>
<li>老师的爬虫</li>
</ul>
<p><img src="/2020/04/24/%E5%A6%82%E4%BD%95%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0MySql%E4%B8%AD/3.png" alt="示例"></p>
<ul>
<li>我的爬虫</li>
</ul>
<p><img src="/2020/04/24/%E5%A6%82%E4%BD%95%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0MySql%E4%B8%AD/4.png" alt="示例"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>其实我真的只是想看看大佬们都买了那些咖啡玩具，QAQ</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用数组来控制指针实现链表</title>
    <url>/2020/04/20/%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="如何用数组来控制指针实现链表-md"><a href="#如何用数组来控制指针实现链表-md" class="headerlink" title="如何用数组来控制指针实现链表.md"></a>如何用数组来控制指针实现链表.md</h1><ul>
<li>我们一般看到的链表定义都是这样的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="但是，我们可以用一个下标数组，来实现-next的操作-我们可以用数组实现next指针的功能，并实现排序"><a href="#但是，我们可以用一个下标数组，来实现-next的操作-我们可以用数组实现next指针的功能，并实现排序" class="headerlink" title="但是，我们可以用一个下标数组，来实现 *next的操作 我们可以用数组实现next指针的功能，并实现排序"></a>但是，我们可以用一个下标数组，来实现 *next的操作 我们可以用数组实现next指针的功能，并实现排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如这样，我们建立两个数组，第一个数组存储具体数字，第二个数组存储下标</span></span><br><span class="line"><span class="comment">//一般，我们要对头节点进行操作的话，需要设立dummyNode,这里A[0]就是个哑节点</span></span><br><span class="line"><span class="comment">//那么，我们要实现一个排序操作，我们就要对他的next数组进行操作。</span></span><br><span class="line"><span class="comment">//首先我们吧next数组初始化为-1</span></span><br><span class="line">	A[<span class="number">7</span>]= &#123;<span class="number">0</span>,<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//排序完成后，A的下标数组如下</span></span><br><span class="line"> 	Next[<span class="number">7</span>]=&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">1</span>，<span class="number">4</span>，<span class="number">6</span>，<span class="number">-1</span>，<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//我们可见，操作完成后，0节点指向2，2节点指向1，1结点指向3，3节点指向4.4节点指向6</span></span><br><span class="line"><span class="comment">//6节点指向5，5节点指向-1。然后映射到A[7]上，就完成了排列,</span></span><br><span class="line"><span class="comment">//打印顺序</span></span><br><span class="line">A[<span class="number">0</span>]（不打印）-&gt;A[<span class="number">2</span>]-&gt;A[<span class="number">1</span>]-&gt;A[<span class="number">3</span>]-&gt;A[<span class="number">4</span>]-&gt;A[<span class="number">6</span>]-&gt;A[<span class="number">5</span>]</span><br><span class="line"><span class="comment">//  所以，用数组来存储指针，并不改变A数组中元素的顺序，只改变A数组的打印顺序</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//那么，每次新输入一个数，如何来实现A数组的排序呢</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1.首先，把next数组初始化为 -1</span></span><br><span class="line"><span class="comment">	2.需要两个类似于迭代器的东西，然后，每次，都让迭代器从0开始遍历，一直到新插入的数所在的位置后</span></span><br><span class="line"><span class="comment">	也就是 A[p]&lt;A[q]&lt;A[nxt[p]]的时候。我们更新next[p]和next[q]的位置</span></span><br><span class="line"><span class="comment">	3.这时候next[q] = next[p] </span></span><br><span class="line"><span class="comment">	       next[p] = q</span></span><br><span class="line"><span class="comment"> 	4.事实上，这就实现了插入操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//核心的部分讲完了，我们现在要进行一些函数的封装</span></span><br><span class="line">    <span class="number">1.</span>如果我们要实现自定义的数据类型的有序列表操作，我们还需要建立一个Record类，在其中重写运算符</span><br><span class="line">    <span class="number">2.</span>建立链表类，里面含有next数组和A数组，以及初始化函数</span><br><span class="line">    <span class="number">3.</span>派生出一个新的有序链表类，让他继承链表类</span><br><span class="line">    <span class="number">4.</span>在有序链表类中完成上述操作，再设定一个打印操作</span><br><span class="line">   </span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作一：建立一个Record 类*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">typeName</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Record</span>&#123;</span></span><br><span class="line">    tp v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Record &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v&lt;t.v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> Record &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v&gt;t.v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Record &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v ==t.v;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> Maxn = <span class="number">40</span>;</span><br><span class="line"><span class="comment">/*操作2：建立链表类，里面含有next数组和A数组，以及初始化函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span></span><br><span class="line">    Record&lt;<span class="keyword">int</span>&gt;A[Maxn];</span><br><span class="line">    <span class="keyword">int</span> next[Maxn],tot;</span><br><span class="line">    LinkList()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(next,<span class="number">-1</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addElem</span> <span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        A[++tot].v = x;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125; 	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span>:</span><span class="keyword">public</span> LinkList&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;<span class="comment">//从0开始遍历</span></span><br><span class="line">        <span class="keyword">int</span> q = addElem(x);<span class="comment">//获取到x再A数组中的位置</span></span><br><span class="line">        <span class="keyword">while</span>(next[p]!=<span class="number">-1</span>&amp;&amp;A[next[p]]&lt;A[q])</span><br><span class="line">        &#123;</span><br><span class="line">            p = next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在 A[p]&lt;A[q]&lt;A[nxt[p]]</span></span><br><span class="line">        <span class="comment">//开始更新</span></span><br><span class="line">        next[q] = next[p];</span><br><span class="line">        next[p] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(next[cur]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = next[p];</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;A[p].v&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*最后实现main函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OrderedList l;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),x!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        l.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    l.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体每次运行的结果，请看运行数据.md</li>
</ul>
<h3 id="上面的是简单的排序操作，我们再结合一下例题"><a href="#上面的是简单的排序操作，我们再结合一下例题" class="headerlink" title="上面的是简单的排序操作，我们再结合一下例题"></a>上面的是简单的排序操作，我们再结合一下例题</h3><p><img src="/2020/04/20/%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/1.png" alt="示例"></p>
<ul>
<li><p>有n个盒子在桌子上的一条线上从左到右编号为1……n。你的任务是模拟四种操作</p>
<p>1 X Y 移动盒子编号X到盒子编号Y的左边（如果X已经在Y的左边了就忽略）</p>
<p>2 X Y 移动盒子编号X到盒子编号Y的右边（如果X已经在Y的右边了就忽略）</p>
<p>3 X Y 交换盒子编号X与盒子编号Y的位置</p>
<p>4 将整条线反转</p>
<p>操作保证合法，X不等于Y</p>
<p>举一个例子，如果n=6，操作 1 1 4然后就变成了2 3 1 4 5 6；再操作 2 3 5就变成了 2 1 4 5 3 6；再操作 3 1 6 就变成 2 6 4 5 3 1；最后操作4，就变成了 1 3 5 4 6 2</p>
<p>输入</p>
<p>最多有10组数据，每个数据会包含两个整数n,m（1≤n,m&lt;100,000）, 接下来是m行数据，表示操作。</p>
<p>输出</p>
<p>对于每组数据，输出他们奇数位置的编号的和。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这道题，也可以用数组来模仿链表来实现，而且，数组的操作方式更加高效</span></span><br><span class="line"><span class="comment">	上面的排序例子，我们只设计了一个next数组，但是这道题目，需要把链表断开来再连上去</span></span><br><span class="line"><span class="comment">	需要前后相连，所以，我们需要设计一个 prev数组。 同样，我们要新建一个 dummyNode</span></span><br><span class="line"><span class="comment">	首先，dummyNode的前驱，是n； dummyNode 的后继是1；</span></span><br><span class="line"><span class="comment">	所以我们看到这个链表其实是一个循环链表！</span></span><br><span class="line"><span class="comment">	因为这是从1，2，3，4......n的n个盒子。所以，不需要再建立一个数组存储数据</span></span><br><span class="line"><span class="comment">	所以不用建立一个映射，数组的下标其实就代表了第n个盒子的标号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">100000</span>+<span class="number">5</span>],l[<span class="number">100000</span>+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i]=i<span class="number">-1</span>;<span class="comment">//1到n的前驱，就是0，1，2，.....n-1；</span></span><br><span class="line">        r[i]=(i+<span class="number">1</span>)%(n+<span class="number">1</span>);<span class="comment">//1-n的后继，就是2，3，4，......0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此外还要规定dummyNode的前驱和后继</span></span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//后继</span></span><br><span class="line">    l[<span class="number">0</span>]=n;<span class="comment">//前驱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数的作用，是把L和R相连也就是说实现 L-&gt;R</span></span><br><span class="line"><span class="comment">//那么很显然 L-&gt;R只有一个链接，所以L的后继为R，R的前驱为L。这是双向的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[L] =R;</span><br><span class="line">    l[R]=L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, x, y, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">                flag = !flag;<span class="comment">//有可能多次反转！</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="number">3</span> &amp;&amp; r[y] == x) swap(x, y);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                交换xy的值，不是交换r[x],r[y]的值。反正是互换，这里把x移到y左边，易于操作</span></span><br><span class="line"><span class="comment">                比如说 链表为 1 2 3 4 5，交换x=4与y=3 ，符合上面的条件</span></span><br><span class="line"><span class="comment">                那么我们换成x=3，y=4</span></span><br><span class="line"><span class="comment">                这样的swap其实是不会影响结果的，只是因为方便后面的判断 if (r[x] == y) </span></span><br><span class="line"><span class="comment">                因为到后面还是交换3，4的值，不管x，y是哪一种，结果都是 1 2 4 3 5</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                那么本来不是紧挨着的，那么可以换吗？？</span></span><br><span class="line"><span class="comment">                可以，但没必要，因为本来不是紧挨者的，再后面的操作，换不换无所谓</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> (a != <span class="number">3</span> &amp;&amp; flag) </span><br><span class="line">                    &#123;</span><br><span class="line">                        a = <span class="number">3</span> - a;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; x == l[y])<span class="comment">//如果x本来就在y左边，那么不需要操作</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="number">2</span> &amp;&amp; x == r[y])<span class="comment">//如果x本来就在y右边，那么不需要操作</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                	<span class="comment">//分别定义x，y的前驱和后继</span></span><br><span class="line">                    <span class="keyword">int</span> Lx = l[x], Rx = r[x], Ly = l[y], Ry = r[y];</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果a=1，那么就需要实现 x---&gt;y</span></span><br><span class="line">                        link(Lx, Rx);<span class="comment">//先让x的前驱后继相连，等于说x脱离链表</span></span><br><span class="line">                        link(Ly, x);<span class="comment">//现在要把y的前驱于x相连，实现y于前驱断开</span></span><br><span class="line">                        link(x, y);<span class="comment">//然后让x于y相连，实现x于y相连，x成为y的新前驱</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果a= 2，那么就需要实现y------&gt;x</span></span><br><span class="line">                        link(Lx, Rx);<span class="comment">// 等于说x脱离链表</span></span><br><span class="line">                        link(y, x);<span class="comment">//让y于x相连，y成为x的新前驱</span></span><br><span class="line">                        link(x, Ry);<span class="comment">//让本来y的后继成为x的后继，实现x的插入</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果a=3，那么就需要实现x和y的 交换</span></span><br><span class="line">                        <span class="comment">//如果x本来就在y的左边，那么只要交换x，y两个的位置</span></span><br><span class="line">                        <span class="keyword">if</span> (r[x] == y)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//让x的前驱连接y</span></span><br><span class="line">                            link(Lx, y);</span><br><span class="line">                            <span class="comment">//让y链接x</span></span><br><span class="line">                            link(y, x);</span><br><span class="line">                            <span class="comment">//让x链接y原来的后继</span></span><br><span class="line">                            link(x, Ry);</span><br><span class="line">                        &#125; <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//如果是有点距离的，那么需要多一点的操作</span></span><br><span class="line">                            <span class="comment">//让x的前驱链接y</span></span><br><span class="line">                            link(Lx, y);</span><br><span class="line">                            <span class="comment">//让y链接x的后继</span></span><br><span class="line">                            link(y, Rx);</span><br><span class="line">                            <span class="comment">//现在，y已经处于x的位置了</span></span><br><span class="line">                            </span><br><span class="line">                            link(Ly, x);</span><br><span class="line">                            <span class="comment">//让y的前驱和x相连</span></span><br><span class="line">                            link(x, Ry);</span><br><span class="line">                            <span class="comment">//让x的后继与y原来的后继相连</span></span><br><span class="line">                            <span class="comment">//现在，xy已经实现交换了</span></span><br><span class="line">                        &#125;</span><br><span class="line">               	 	&#125;</span><br><span class="line">           		 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t = r[t];</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                sum+=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = (<span class="keyword">long</span> <span class="keyword">long</span>)n*(n+<span class="number">1</span>)/<span class="number">2</span>-sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;++k&lt;&lt;<span class="string">": "</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>综上，我们可以用数组来模拟链表，并做一些类似于链表的操作，还有链式前项星等应用也是通过数组模仿链表来实现的，如果需要操作的对象是无序的，我们需要不仅要建立指针数组，还要建立一个存储数据的数组，来做一个映射。但是如果操作的是有序的1，2，3，…..n的话，其实没必要再新建一个数组存放数据了，直接用数组下标就可以完成操作了</li>
<li>其次，我们在做题目分析的时候需要判断头节点是否会被操作，如果需要被操作，我们还要新建一个dummyNode作为哨兵节点。</li>
</ul>
<h3 id="下面是运行的数据"><a href="#下面是运行的数据" class="headerlink" title="下面是运行的数据"></a>下面是运行的数据</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">​```c++</span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">-1</span> nxt[<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">-1</span> nxt[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">-1</span> nxt[<span class="number">3</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">3</span> nxt[<span class="number">3</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">3</span> nxt[<span class="number">3</span>] = <span class="number">-1</span> nxt[<span class="number">4</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">4</span> nxt[<span class="number">3</span>] = <span class="number">-1</span> nxt[<span class="number">4</span>] = <span class="number">3</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">4</span> nxt[<span class="number">3</span>] = <span class="number">-1</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">4</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">4</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">2</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">7</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">2</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">7</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">2</span> nxt[<span class="number">8</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span>  A[<span class="number">8</span>]= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">8</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">2</span> nxt[<span class="number">8</span>] = <span class="number">7</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span>  A[<span class="number">8</span>]= <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">1</span> nxt[<span class="number">1</span>] = <span class="number">8</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">2</span> nxt[<span class="number">8</span>] = <span class="number">7</span> nxt[<span class="number">9</span>] = <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span>  A[<span class="number">8</span>]= <span class="number">4</span>  A[<span class="number">9</span>]= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">9</span> nxt[<span class="number">1</span>] = <span class="number">8</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">2</span> nxt[<span class="number">8</span>] = <span class="number">7</span> nxt[<span class="number">9</span>] = <span class="number">1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span>  A[<span class="number">8</span>]= <span class="number">4</span>  A[<span class="number">9</span>]= <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">Before the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">9</span> nxt[<span class="number">1</span>] = <span class="number">8</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">2</span> nxt[<span class="number">8</span>] = <span class="number">7</span> nxt[<span class="number">9</span>] = <span class="number">1</span> nxt[<span class="number">10</span>] =</span><br><span class="line"> <span class="number">-1</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span>  A[<span class="number">8</span>]= <span class="number">4</span>  A[<span class="number">9</span>]= <span class="number">2</span>  A[<span class="number">10</span>]= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">After the Operation</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">10</span> nxt[<span class="number">1</span>] = <span class="number">8</span> nxt[<span class="number">2</span>] = <span class="number">6</span> nxt[<span class="number">3</span>] = <span class="number">5</span> nxt[<span class="number">4</span>] = <span class="number">3</span> nxt[<span class="number">5</span>] = <span class="number">-1</span> nxt[<span class="number">6</span>] = <span class="number">4</span> nxt[<span class="number">7</span>] = <span class="number">2</span> nxt[<span class="number">8</span>] = <span class="number">7</span> nxt[<span class="number">9</span>] = <span class="number">1</span> nxt[<span class="number">10</span>]</span><br><span class="line">= <span class="number">9</span></span><br><span class="line"> A[<span class="number">0</span>]= <span class="number">-1</span>  A[<span class="number">1</span>]= <span class="number">3</span>  A[<span class="number">2</span>]= <span class="number">6</span>  A[<span class="number">3</span>]= <span class="number">9</span>  A[<span class="number">4</span>]= <span class="number">8</span>  A[<span class="number">5</span>]= <span class="number">10</span>  A[<span class="number">6</span>]= <span class="number">7</span>  A[<span class="number">7</span>]= <span class="number">5</span>  A[<span class="number">8</span>]= <span class="number">4</span>  A[<span class="number">9</span>]= <span class="number">2</span>  A[<span class="number">10</span>]= <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure>


<pre><code>



</code></pre>]]></content>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用表格显示查询结果</title>
    <url>/2020/04/26/%E5%A6%82%E4%BD%95%E7%94%A8%E8%A1%A8%E6%A0%BC%E6%98%BE%E7%A4%BA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="如何用表格显示查询结果"><a href="#如何用表格显示查询结果" class="headerlink" title="如何用表格显示查询结果"></a>如何用表格显示查询结果</h1><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul>
<li>这篇博客记录了如何通过express框架让我们前端能出现表格式的查询内容</li>
<li>我会先讲述老师的操作</li>
<li>然后，我会以 我建立的 经济新闻 为例子，展示搜索成果</li>
</ul>
<h3 id="1-老师操作：如何搭建express网站并实现查找"><a href="#1-老师操作：如何搭建express网站并实现查找" class="headerlink" title="1.老师操作：如何搭建express网站并实现查找"></a>1.老师操作：如何搭建express网站并实现查找</h3><h4 id="第一步，建立文件夹"><a href="#第一步，建立文件夹" class="headerlink" title="第一步，建立文件夹"></a>第一步，建立文件夹</h4><ul>
<li>我们用express 脚手架来创建一个网站框架</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">express -e search_site</span><br><span class="line"><span class="comment">//-e 的参数说明我们用ejs作为缺省view引擎，而非采用jade（这句话不是很理解）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>然后 这样就可以建立一个search_site 文件夹</p>
</li>
<li><p>由于我们需要使用mysql，因此将mysql.js拷贝到这个文件夹</p>
</li>
<li><p>这里值得一提的是，因为我全把数据存储到一个database中了，也就是说，我们所有文件都可以引用这个mysql.js，但是如果是说存放在不同的databas中的话，我们就需要修改mysql.js中的database: ‘’中的值，名字就是你的database</p>
</li>
<li><p>建立好后，我们还需要引入一些配置</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//npm install mysql --save</span></span><br><span class="line"><span class="comment">//- --save表示将mysql包安装到该项目中，并且将依赖项存进package.json里</span></span><br><span class="line"><span class="comment">//在search_site文件夹内cmd运行npm instll</span></span><br><span class="line"><span class="comment">//- 将package.json中列举的依赖项全部安装，完成网站搭建</span></span><br></pre></td></tr></table></figure>

<h4 id="第二步，修改index-js和search-html"><a href="#第二步，修改index-js和search-html" class="headerlink" title="第二步，修改index.js和search.html"></a>第二步，修改index.js和search.html</h4><ul>
<li>修改index.js</li>
<li>具体的express用法我不是很明白，更多的是照葫芦画瓢罢了，有时间会系统学习express框架</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express模块，引入mysql.js 注意，这个mysql.js在上层文件夹中，所以要用 ../</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'../mysql.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.render(<span class="string">'index'</span>, &#123; <span class="attr">title</span>: <span class="string">'Express'</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/process_get'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//sql字符串和参数,和前面一样，搜索我们需要的东西</span></span><br><span class="line">    <span class="keyword">var</span> fetchSql = <span class="string">"select url,source_name,title,author,publish_date "</span> +</span><br><span class="line">        <span class="string">"from fetches where title like '%"</span> + request.query.title + <span class="string">"%'"</span>;</span><br><span class="line">    mysql.query(fetchSql, <span class="function"><span class="keyword">function</span>(<span class="params">err, result, fields</span>) </span>&#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">        &#125;);</span><br><span class="line">        response.write(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">        response.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建search.html,在public文件夹下创建</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span> 标题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title_text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-submit"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"查询"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cardLayout"</span> <span class="attr">style</span>=<span class="string">"margin: 10px 0px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">id</span>=<span class="string">"record2"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//上面是引入jquery的包，下面是操作代码。但是jquery我也没系统学习过，所以这里很多功能不是很明白</span></span></span><br><span class="line"><span class="javascript">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//对查询按钮进行了一个操作，就是click后会进行下面操作</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"input:button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                $.get(<span class="string">'/process_get?title='</span> + $(<span class="string">"input:text"</span>).val(), <span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="string">"#record2"</span>).empty();</span></span><br><span class="line"><span class="handlebars"><span class="xml">                    $("#record2").append('<span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"cardLayout"</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>url<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>source_name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>' +</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        '<span class="tag">&lt;<span class="name">td</span>&gt;</span>title<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>author<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>publish_date<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>');</span></span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//查询完后，信息放在data当中</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">let</span> list <span class="keyword">of</span> data) &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">                        let table = '<span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"cardLayout"</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>';</span></span></span><br><span class="line"><span class="actionscript">                        <span class="comment">//对其遍历，每一行都把具体的数据放到每一行中去</span></span></span><br><span class="line"><span class="javascript">                        <span class="built_in">Object</span>.values(list).forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">                            table += (element + '<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>');</span></span></span><br><span class="line">                        &#125;);</span><br><span class="line"><span class="javascript">                        $(<span class="string">"#record2"</span>).append(table + <span class="string">'&lt;/td&gt;&lt;/tr&gt;'</span>);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的讲解很生疏，也不是很明白具体原理，望见谅！</li>
</ul>
<h4 id="第三步，显示查询结果"><a href="#第三步，显示查询结果" class="headerlink" title="第三步，显示查询结果"></a>第三步，显示查询结果</h4><ul>
<li>在search_site 文件夹下 的终端 打入以下命令</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node bin/www</span><br></pre></td></tr></table></figure>

<ul>
<li>用chrome打开 <a href="http://127.0.0.1:3000/search.html" target="_blank" rel="noopener">http://127.0.0.1:3000/search.html</a></li>
<li>输入关键词，即可查询</li>
</ul>
<p><img src="/2020/04/26/%E5%A6%82%E4%BD%95%E7%94%A8%E8%A1%A8%E6%A0%BC%E6%98%BE%E7%A4%BA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/1.png" alt="示例"></p>
<h3 id="2-模仿老师，建立自己查询页面"><a href="#2-模仿老师，建立自己查询页面" class="headerlink" title="2.模仿老师，建立自己查询页面"></a>2.模仿老师，建立自己查询页面</h3><h4 id="首先建立一个search-economy的文件夹，完成基本配置"><a href="#首先建立一个search-economy的文件夹，完成基本配置" class="headerlink" title="首先建立一个search_economy的文件夹，完成基本配置"></a>首先建立一个search_economy的文件夹，完成基本配置</h4><p><img src="/2020/04/26/%E5%A6%82%E4%BD%95%E7%94%A8%E8%A1%A8%E6%A0%BC%E6%98%BE%E7%A4%BA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/2.png" alt="示例"></p>
<p>然后修改html和index的代码，主要集中在一句话上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">('<span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"cardLayout"</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>url<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>source_name<span class="tag">&lt;/<span class="name">td</span>&gt;</span>' +</span><br><span class="line">                        '<span class="tag">&lt;<span class="name">td</span>&gt;</span>title<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>crawltime<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>author<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>');</span><br></pre></td></tr></table></figure>

<ul>
<li>说穿了就是改变类型，把原来的publish_date换成了crawltime，在最后加了个author</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetchSql = <span class="string">"select url,source_name,title_format,crawltime,author "</span> +</span><br><span class="line">    <span class="string">"from 经济新闻 where title_format like '%"</span> + request.query.title + <span class="string">"%'"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在index.js中修改搜寻的表和内容样式</li>
</ul>
<h4 id="开始自己的搜寻"><a href="#开始自己的搜寻" class="headerlink" title="开始自己的搜寻"></a>开始自己的搜寻</h4><p><img src="/2020/04/26/%E5%A6%82%E4%BD%95%E7%94%A8%E8%A1%A8%E6%A0%BC%E6%98%BE%E7%A4%BA%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/3.png" alt="示例"></p>
<p>这时候，爬取好几个网站的重要性就体现出来了，我们可以看到不同门户网站上的不同新闻，在这里，我的关键词是”股“</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这是系列博客的最后一篇，但是我并不会停止学习的脚步。在这个基础上，我还有很多工作可以做，比如美化操作界面，增加表格的美观程度，增加第二关键词搜索等功能。一周以来，我基本实现了每天更新爬虫博客，有些可能是JavaScript语法内容，也有可能是最新写的一些文章。我最大的感受就是：只要把时间花下去，肯定会有产出和收获。这也给我漫漫人生路增添了一段美好的经验和记忆。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>对弧长的曲线积分</title>
    <url>/2020/05/07/%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="对弧长的曲线积分"><a href="#对弧长的曲线积分" class="headerlink" title="对弧长的曲线积分"></a>对弧长的曲线积分</h1><script type="math/tex; mode=display">曲线积分\left\{ \begin{aligned} 对弧长的曲线积分\\对坐标的曲线积分\\积分区域:曲线弧\end{aligned} \right.</script><h3 id="对弧长的曲线积分的概念与性质"><a href="#对弧长的曲线积分的概念与性质" class="headerlink" title="对弧长的曲线积分的概念与性质"></a>对弧长的曲线积分的概念与性质</h3><h4 id="如何求曲线形构件的质量"><a href="#如何求曲线形构件的质量" class="headerlink" title="如何求曲线形构件的质量"></a>如何求曲线形构件的质量</h4><p><img src="/2020/05/07/%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/1.png" alt="示例" style="zoom:67%;"></p>
<ul>
<li>大化小，常代变，近似和，求极限</li>
</ul>
<p>可得出$M = \lim\limits_{\lambda-&gt;0}\sum_{k=1}^{n}\rho(\xi,\eta,\zeta)\Delta s_k$</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="空间区域中"><a href="#空间区域中" class="headerlink" title="空间区域中"></a>空间区域中</h5><p>设$\Gamma$是空间中一条有限长的光滑曲线，f(x,y,z)是定义在$\Gamma $上的一个优先函数，若通过$\Gamma$的任意分割和对局部的任意取点，下列 乘积和式极限，</p>
<p>$\lim\limits_{\lambda-&gt;0}\sum_{k=1}^{n}\rho(\xi,\eta,\zeta)\Delta s_k=\int_{\Gamma}f(x,y,z)ds$ （s是弧长的微元）都存在，则称这是$f(x,y,z)$在曲线$\Gamma$上对弧长的曲线积分或第一类曲线积分。 $f(x,y,z)$被称为被积函数，$\Gamma$被称为积分弧段。所以曲线形构件的质量就是</p>
<p>$M = \lim\limits_{\lambda-&gt;0}\sum_{k=1}^{n}\rho(\xi,\eta,\zeta)\Delta s_k=\int_{\Gamma}\rho(x,y,z)ds$</p>
<h5 id="平面积分中"><a href="#平面积分中" class="headerlink" title="平面积分中"></a>平面积分中</h5><p>如果L是xOy面上的曲线弧，则定义对弧长的曲线积分为</p>
<p>$\int_{\Gamma}f(x,y)ds= \lim\limits_{\lambda-&gt;0}\sum_{k=1}^nf(\xi,\eta)\Delta s_k$</p>
<p>如果L 是闭曲线，则记为$\oint_Lf(x,y)ds$</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>$\int_{\Gamma}f(x,y)ds$不是定积分，是曲线积分</li>
<li>若在$\Gamma$上f(x,y)===1,问$\int_{\Gamma}ds$是什么？ <ul>
<li>是该曲线的长度</li>
</ul>
</li>
<li>定积分是否可以看作弧长曲线积分的特例？<ul>
<li>不是，对弧长的曲线积分要求ds&gt;=0,但是定积分中dx可能为负</li>
</ul>
</li>
</ul>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>$\int_{\Gamma}[\alpha f(x,y,z)+\beta g(x,y,z)]ds= \alpha \int_{\Gamma}f(x,y,z)ds+\beta\int_{\Gamma}g(x,y,z)ds$</li>
<li>$\int_{\Gamma}f(x,y,z)ds= \int_{\Gamma_1}f(x,y,z)ds+\int_{\Gamma_2}f(x,y,z)ds$</li>
<li>设在$\Gamma$上的$f(x,y,z)&lt;=g(x,y,z)$则$\int_{\Gamma}f(x,y,z)ds&lt;=\int_{\Gamma}g(x,y,z)ds$</li>
<li>$\int_{\Gamma}ds=l(l为弧长的长度)$</li>
</ol>
<h3 id="对曲线积分的计算"><a href="#对曲线积分的计算" class="headerlink" title="对曲线积分的计算"></a>对曲线积分的计算</h3><p><img src="/2020/05/07/%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/3.png" alt="示例"></p>
<h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><ol>
<li>画出被积曲线</li>
<li>把参数带入到f(x,y)中</li>
<li>计算括号内的内容</li>
<li>转化为定积分计算</li>
</ol>
<h3 id="例题简析"><a href="#例题简析" class="headerlink" title="例题简析"></a>例题简析</h3><hr>
<p>1.$\oint (2xy+3x^2+4y^2)ds ,L$为椭圆$\frac{x^2}{4}+\frac{y^2}{3}=1$ ,其周长为a</p>
<ul>
<li>一般的，如果曲线L对于y轴对称那么</li>
</ul>
<script type="math/tex; mode=display">\int_Lf(x,y)ds=\left\{ \begin{aligned} 2\int_{L1}f(x,y)ds,f(-x,y)=f(x,y)\\0,f(-x,y)=-f(x,y)\end{aligned} \right.</script><ul>
<li>反之，如果曲线L对于x轴对称那么</li>
</ul>
<script type="math/tex; mode=display">\int_Lf(x,y)ds=\left\{ \begin{aligned} 2\int_{L1}f(x,y)ds,f(x,-y)=f(x,y)\\0,f(x,-y)=-f(x,y)\end{aligned} \right.</script><p>那么原式 = $\oint_L(3x^2+4y^2)ds=\oint_L12ds=12a$</p>
<hr>
<p>2.$\oint\sqrt{x^2+y^2}ds,L$为圆周$x^2+y^2=ax$</p>
<ul>
<li>根据上面的结论，我们知道只要求半圆的两倍即可</li>
<li>这里还需要注意，因为这里要求y对于x的导数非常麻烦，所以设参数比较方便</li>
<li>所以设$x(\theta)=\frac{a}{2}+\frac{acos\theta}{2},y(\theta)=\frac{a\sin\theta}{2}$</li>
<li>=$2\int_0^\pi\sqrt{ax(\theta)}\sqrt{x^{‘2}(\theta)+y^{‘2}(\theta)}d\theta$</li>
<li>=$2\cdot\frac{a}{\sqrt{2}}\cdot \frac{a}{2}\int_0^\pi\sqrt{1+cos\theta}d\theta$</li>
<li>=$\frac{a^2}{\sqrt{2}}*\int_0^{\pi}\sqrt2|cos\frac{\theta}{2}|d\theta$</li>
<li>=$a^2*2sin\theta|_0^\pi$</li>
</ul>
<hr>
<p>3.$\oint_L x^2 ds 其中L为圆周x^2+y^2+z^2=a^2,x+y+z=0$</p>
<p>根据这种没什么头绪的题目，看起来既不能用参数解决，也不能直接暴力求解。我们就要想到对称。因为这个图像是关于x=y=z轮番对称的，所以$\oint_L x^2 ds=\oint_L y^2 ds=\oint_L z^2 ds$</p>
<p>$=\frac 1 3\int_L(x^2+y^2+z^2)ds=\frac 1 3 \int {a^2}{ds}$</p>
<p>$= \frac 13 a^22\pi a$</p>
]]></content>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/05/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p>归并排序采用分治策略实现对n个元素进行排序算法，是分治法的一个典型应用和完美体现，它是一种平衡，简单的二分分治策略，过程大致分为：</p>
<ol>
<li>分解——将待排序的元素分成大小大致相同的两个子序列</li>
<li>治理——对两个子序列进行合并排序</li>
<li>合并——将排好序的有序子序列进行合并，得到最终的有序列。</li>
</ol>
<p><img src="/2020/05/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1.png" alt="示例">递归树高nlogn</p>
<h3 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h3><ul>
<li>新开辟一段数组，数组长为 $high- low +1$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span> [high- low +<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">//左序列指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j])</span><br><span class="line">        &#123; temp[t++] = arr[i++]; &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; temp[t++] = arr[j++]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">        temp[t++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">        temp[t++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将temp中的元素全部拷贝到原数组中,因为temp只是一个辅助数组</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;=  high)&#123; arr[low++] = temp[t++]; &#125;</span><br><span class="line">    <span class="keyword">delete</span> []temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归操作"><a href="#递归操作" class="headerlink" title="递归操作"></a>递归操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//对A[low:mid]中的元素进行合并排序</span></span><br><span class="line">        MergeSort(A,low,mid);</span><br><span class="line">        <span class="comment">//对A[mid+1:high]中的元素进行合并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">        <span class="comment">//合并操作,两个有序序列的合并</span></span><br><span class="line">        merge(A,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="keyword">int</span> A[Maxsize];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span><span class="comment">//合并函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *B=<span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];<span class="comment">//申请一个辅助数组</span></span><br><span class="line">    <span class="keyword">int</span> i=low, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=high) &#123;<span class="comment">//按从小到大存放到辅助数组B[]中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;=A[j])</span><br><span class="line">            B[k++]=A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            B[k++]=A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) B[k++]=A[i++];<span class="comment">//将数组中剩下的元素放置B中</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) B[k++]=A[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=low, k=<span class="number">0</span>; i&lt;=high; i++)</span><br><span class="line">        A[i]=B[k++];</span><br><span class="line">    <span class="keyword">delete</span> []B;<span class="comment">//释放空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//对A[low:mid]中的元素进行合并排序</span></span><br><span class="line">        MergeSort(A,low,mid);</span><br><span class="line">        <span class="comment">//对A[mid+1:high]中的元素进行合并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">        <span class="comment">//合并操作,两个有序序列的合并</span></span><br><span class="line">        Merge(A,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入数列中的元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入数列中的元素"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    MergeSort(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"快速排序的结果:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ol>
<li>分解： 这一步仅仅是计算出子序列的中间位置，需要常数时间O(1)</li>
<li>解决子问题：递归求解两个规模为n/2的子问题，所需时间为2T(n/2)</li>
<li>合并： Merge算法可以在O（n)的时间完成</li>
</ol>
<p>所以运行总时间为</p>
<p>$$ T(n):\left{ \begin{aligned} O(1),n = 1\ T(n-1)+O(n),n&gt;1 \end{aligned} \right. $$ </p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，每调用一个适当大小的缓冲去，且退出时会释放。最多分配大小为n，所以空间复杂度为O(n),递归调用所使用的栈空间是O(logn) 因为递归树高logn</p>
<p><img src="/2020/05/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/2.png" alt="示例"></p>
<h3 id="最后贴一段gif-便于理解"><a href="#最后贴一段gif-便于理解" class="headerlink" title="最后贴一段gif,便于理解"></a>最后贴一段gif,便于理解</h3><p><img src="/2020/05/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1.gif" alt="示例"></p>
<p>视频来自于可视化算法网站 <a href="https://visualgo.net/zh" target="_blank" rel="noopener">https://visualgo.net/zh</a></p>
]]></content>
      <tags>
        <tag>Data_structure</tag>
        <tag>Rank</tag>
      </tags>
  </entry>
  <entry>
    <title>当只能访问一个节点时，如何删除这个节点</title>
    <url>/2020/04/20/%E5%BD%93%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E8%BF%99%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="当只能访问该节点时，如何删除该节点"><a href="#当只能访问该节点时，如何删除该节点" class="headerlink" title="当只能访问该节点时，如何删除该节点"></a>当只能访问该节点时，如何删除该节点</h1><h2 id="那就是鸠占鹊巢，将下一个结点的值和指向赋给当前节点，再删除下一个节点"><a href="#那就是鸠占鹊巢，将下一个结点的值和指向赋给当前节点，再删除下一个节点" class="headerlink" title="那就是鸠占鹊巢，将下一个结点的值和指向赋给当前节点，再删除下一个节点"></a>那就是鸠占鹊巢，将下一个结点的值和指向赋给当前节点，再删除下一个节点</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//令当前节点的下一节点</span></span><br><span class="line">        ListNode *temp = node-&gt;next;</span><br><span class="line">        <span class="comment">//把下一个节点的所有信息赋给当前节点</span></span><br><span class="line">        node-&gt;val = temp -&gt;val;</span><br><span class="line">        node-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="comment">//删除下一个节点</span></span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>当没有dummynode时实现链表头插</title>
    <url>/2020/04/20/%E5%BD%93%E6%B2%A1%E6%9C%89dummynode%E6%97%B6%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92/</url>
    <content><![CDATA[<h1 id="如何实现链表的头插？"><a href="#如何实现链表的头插？" class="headerlink" title="如何实现链表的头插？"></a>如何实现链表的头插？</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表一般是尾插的，那么怎么实现头插呢？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertFromHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//比如我要新插入一个节点 newNode，值为1；</span></span><br><span class="line">    <span class="comment">//先建立一个临时节点prev，让prev指向head</span></span><br><span class="line">    ListNode* prev;</span><br><span class="line">    ListNode* newNode;</span><br><span class="line">    prev = head;</span><br><span class="line">    <span class="comment">//新建一个节点</span></span><br><span class="line">    newNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//让新节点指向临时节点prev</span></span><br><span class="line">    newNode-&gt;next = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/05/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的基本思想是基于分治策略的，其算法思想如下</p>
<ul>
<li>分解：先从数列中取出一个元素作为基准元素，以基准元素为标准，将问题分解为两个子序列，让小于或等于基准元素的子序列在左侧，让大于基准元素的子序列在右侧</li>
<li>治理：对两个子序列进行快速排序</li>
<li>合并：将排好序的两个子序列合并在一起（快速排序什么都不用做）</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li><p>如何分解是一个难题，因为如果基准元素选取不当，有可能分解成规模为0，n-1 的量的子序列，那么这样快速排序就退化为冒泡排序了。一般来说，基准元素选取有以下几种方法</p>
<ul>
<li><p>取第一个元素</p>
</li>
<li><p>取最后一个元素</p>
</li>
<li><p>取中间位置的元素</p>
</li>
<li><p>取第一个，最后一个，和中间位置元素三者中的中位数</p>
</li>
<li><p>取第一个和最后一个位置之间的随机数k,(low&lt;=k&lt;=high)选R[k]做基准元素，可以避免每次都他妈的最坏8</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">srand(time(<span class="number">0</span>));	<span class="comment">//选时间做种子</span></span><br><span class="line">rand()%(high-low+<span class="number">1</span>)+low;<span class="comment">//产生一个low-high 之间的随机下标</span></span><br></pre></td></tr></table></figure>

<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>首先取数组的第一个元素作为基准元素 pivot = R[low], i = low ,j = high</li>
<li>从右向左扫描，找到小于等于pivot的数，如果找到，R[i]和R[j] 交换，i++</li>
<li>从左向右扫描，找到大于等于pivot的数，如果找到，R[i]和R[j] 交换，j –</li>
<li>重复步骤2-3，直到i和j指针重合，返回该位置mid=i 该位置的数正好是pivot元素</li>
<li>至此完成一趟排序，此时mid为界，将元数据分为两个子序列，左侧子序列元素都比pivot小，右边都比pivot大，然后再分别对这两个子序列进行快排</li>
</ol>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><table>
<thead>
<tr>
<th>low,i</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>high,j</th>
</tr>
</thead>
<tbody><tr>
<td>30</td>
<td>24</td>
<td>5</td>
<td>58</td>
<td>18</td>
<td>36</td>
<td>12</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>low</th>
<th>i</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>j</th>
<th></th>
<th>high</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>24</td>
<td>5</td>
<td>58</td>
<td>18</td>
<td>36</td>
<td>30</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>low</th>
<th></th>
<th></th>
<th>i</th>
<th></th>
<th>j</th>
<th></th>
<th></th>
<th>high</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>24</td>
<td>5</td>
<td>30</td>
<td>18</td>
<td>36</td>
<td>58</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>low</th>
<th></th>
<th></th>
<th>mid-1</th>
<th>j,i,mid</th>
<th>mid+1</th>
<th></th>
<th></th>
<th>high</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>24</td>
<td>5</td>
<td>30</td>
<td>18</td>
<td>36</td>
<td>58</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="keyword">int</span> A[Maxsize];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span><span class="comment">//划分函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设定基准元素</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j = high,pivot = r[low];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;r[j]&gt;pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            swap(r[i++],r[j]);</span><br><span class="line">        <span class="comment">//r[i]和r[j]交换后，i右移一位</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;r[i]&lt;=pivot)</span><br><span class="line">            i++;<span class="comment">//向右扫描</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            swap(r[i],r[j--]);</span><br><span class="line">        <span class="comment">//r[i]和r[j]交换后，i右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = i;</span><br><span class="line">    <span class="keyword">return</span> mid;<span class="comment">//返回我们的中间界限</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = Partition(R,low,high);</span><br><span class="line">        QuickSort(R,low,mid<span class="number">-1</span>);</span><br><span class="line">        QuickSort(R,mid+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入数列中的元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入数列中的元素"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"快速排序的结果:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h4><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>分解：划分Partition需要扫描每个元素，每次扫描的元素个数不超过n，因此时间复杂度为O(n)</li>
<li>治理：在理想情况下，每次划分将问题分解为两个规模为n/2的子问题，递归求解连个规模为 n/2的自问题，所需的时间为 2T(n/2)</li>
<li>合并：因为是原地排序，合并操作不需要时间复杂度</li>
<li><img src="/2020/05/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/05/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/1.png" class></li>
<li>$$ T(n):\left{ \begin{aligned} O(1),n = 1\2T(n/2)+O(n),n&gt;1 \end{aligned} \right. $$ </li>
<li>最终 $T(n) = 2^xT(\frac{n}{2^x})+xO(n),x = \log n$</li>
<li>所以 代入得 $T(n) = nT(1)+\log n*O(n)= O(n\log n)$</li>
</ul>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ul>
<li>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的。递归调用所使用的栈空间为递归树的深度 logn ，那么空间复杂度为 O(logn)</li>
</ul>
<h4 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h4><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><ul>
<li>分解：划分Partition需要扫描每个元素，每次扫描的元素个数不超过n，因此时间复杂度为O(n)</li>
<li>治理：在最坏的情况下，每次划分将问题分解后，基准元素的左侧（或者右侧） 没有元素，基准元素的另一侧为1个规模为n-1的子问题。递归求解这个规模为n-1的子问题，所需的时间为T(n-1) </li>
<li>合并：因为是原地排序，合并操作不需要时间复杂度</li>
<li>$$ T(n):\left{ \begin{aligned} O(1),n = 1\ T(n-1)+O(n),n&gt;1 \end{aligned} \right. $$ </li>
<li>相当于冒泡排序，这种情况下最坏的时间复杂度为O(n^2)</li>
</ul>
<h5 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ul>
<li>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的。递归调用所使用的栈空间为递归树的深度 n ，那么空间复杂度为 O(n),因为递归调用了n次</li>
</ul>
<h4 id="平均情况"><a href="#平均情况" class="headerlink" title="平均情况"></a>平均情况</h4><h5 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>假设我们划分后基准元素的位置在第k个</p>
<p>$T(n) = \frac 1{n}\sum_1^n(T(n-k)+T(n-1))+O(n)$</p>
<p>$= \frac1{n}(T(n-1)+T(0)+T(n-2)+T(1)+…+T(1)+T(n-2)+T(0)+T(n-1))+O(n)$</p>
<p>$=\frac2{n}\sum_{k=1}^{n-1}T(k)+O(n)$</p>
<p>用归纳法可得出，时间复杂度也为O(nlog n)</p>
<h5 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ul>
<li>程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的。递归调用所使用的栈空间为递归树的深度 logn ，那么空间复杂度为 O(logn)</li>
</ul>
<p><img src="/2020/05/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/0.png" alt="示例"></p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>因为前后两个方向扫描并交换，相等的两个元素有可能出现排序前后位置不一样的情况，因此快速排序是不稳定的排序方法，比如题目告诉你 70 70 排序后第一个70仍然要在第二个70之前，这时候就不能用快速排序了</p>
<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><ul>
<li>从上述算法可以看出，每次交换都是在和基准元素进行交换，实际上没必要这么做，我们的目的就是想把原序列分成以基准元素为界的两个子序列，左侧子序列小于等于基准元素，右侧子序列大于基准元素。</li>
<li>那么有很多方法可以实现，我们可以从右向左扫描，找到小于pivot的数R[j],让R[i]与R[j]交换，一直交替进行贸易知道i和j碰头为止，这时将基准元素与R[i]交换即可。这样完成一次划分过程交换的元素个数就少了很多</li>
</ul>
<table>
<thead>
<tr>
<th>low,i</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>high,j</th>
</tr>
</thead>
<tbody><tr>
<td>30</td>
<td>24</td>
<td>5</td>
<td>58</td>
<td>18</td>
<td>36</td>
<td>12</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>low</th>
<th></th>
<th></th>
<th>i</th>
<th></th>
<th></th>
<th>j</th>
<th></th>
<th>high</th>
</tr>
</thead>
<tbody><tr>
<td>30</td>
<td>24</td>
<td>5</td>
<td>12</td>
<td>18</td>
<td>36</td>
<td>58</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>low</th>
<th></th>
<th></th>
<th></th>
<th>i,j</th>
<th></th>
<th></th>
<th></th>
<th>high,j</th>
</tr>
</thead>
<tbody><tr>
<td>30</td>
<td>24</td>
<td>5</td>
<td>12</td>
<td>18</td>
<td>36</td>
<td>58</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>low</th>
<th></th>
<th></th>
<th></th>
<th>i,j</th>
<th></th>
<th></th>
<th></th>
<th>high</th>
</tr>
</thead>
<tbody><tr>
<td>18</td>
<td>24</td>
<td>5</td>
<td>12</td>
<td>30</td>
<td>36</td>
<td>58</td>
<td>42</td>
<td>39</td>
</tr>
</tbody></table>
<ul>
<li>优化算法降低时间空间复杂度是很难的，但是常数级的优化是容易的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span><span class="comment">//划分函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设定基准元素</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j = high, pivot = r[low];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( i&lt;j&amp;&amp;r[j]&gt;pivot&amp;&amp;j!=low)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> ( i&lt;j&amp;&amp;r[i]&lt;=pivot&amp;&amp;i!=high)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            swap(r[i],r[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(r[low],r[j]);</span><br><span class="line">    <span class="keyword">int</span> mid = i;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Data_structure</tag>
        <tag>Rank</tag>
      </tags>
  </entry>
  <entry>
    <title>极浅烘焙冲煮方式</title>
    <url>/2020/04/19/%E6%9E%81%E6%B5%85%E7%83%98%E7%84%99%E5%86%B2%E7%85%AE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="极浅烘焙冲煮方式"><a href="#极浅烘焙冲煮方式" class="headerlink" title="极浅烘焙冲煮方式"></a>极浅烘焙冲煮方式</h1><ul>
<li>V60滤杯</li>
<li>准备汤匙</li>
<li>研磨的：不到2：30 细一点点，超过2：30 粗一点点</li>
<li>用94度的水温</li>
<li>直接给150CC的水，不用闷蒸</li>
<li>用汤匙快速搅拌</li>
<li>时间大概在45-50s左右</li>
<li>给第二段的水</li>
<li>中间给水20-30cc后往外绕，然后往外推，推到300cc</li>
<li>浸泡状态</li>
</ul>
]]></content>
      <tags>
        <tag>coffee</tag>
      </tags>
  </entry>
  <entry>
    <title>模仿老师的代码开始自己的爬虫项目</title>
    <url>/2020/04/23/%E6%A8%A1%E4%BB%BF%E8%80%81%E5%B8%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BC%80%E5%A7%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="模仿老师的代码开始自己的爬虫项目"><a href="#模仿老师的代码开始自己的爬虫项目" class="headerlink" title="模仿老师的代码开始自己的爬虫项目"></a>模仿老师的代码开始自己的爬虫项目</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>这篇子博客主要是记录我写的三个爬虫得心得，主要把精力集中在第一个爬取什么值得买网站上了，剩下两个通过修改爬取信息和正则表达式，可以很快的运作起来</li>
<li>我会运用一一讲解代码的形式来介绍为什么要这么做，或者这么做有什么作用（第一个例子）</li>
<li>剩下，我爬取了十个左右的网站，因为代码大多数重复，所以我就简要介绍一下他们的不同之处</li>
</ul>
<h3 id="什么值得买-网站"><a href="#什么值得买-网站" class="headerlink" title="什么值得买 网站"></a>什么值得买 网站</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"什么值得买？"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'https://post.smzdm.com'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'https://post.smzdm.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href，这是为了获取到源代码中所有a开头的链接</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/.\/.&#123;8&#125;\//</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> interface_format = <span class="string">"$('h1.item-name').text()"</span>;<span class="comment">//标题内容</span></span><br><span class="line"><span class="keyword">var</span> content_format = <span class="string">"$('.m-contant').text()"</span>;<span class="comment">//正文内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是引环节，具体的讲解在我的另一篇：爬虫项目中引用的包极其用法有所讲解</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> myRequest = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"><span class="keyword">var</span> myCheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"><span class="keyword">var</span> myIconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'date-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为很多网站会防止爬虫，所以我们必须伪装成一个浏览器来防止屏蔽</span></span><br><span class="line"><span class="keyword">var</span> headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面的代码块，我在request模块讲解时有所提及，这里略去不讲</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        url: url,</span><br><span class="line">        encoding: <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">//proxy: 'http://x.x.x.x:8080',//过代理</span></span><br><span class="line">        headers: headers,</span><br><span class="line">        timeout: <span class="number">10000</span> <span class="comment">//多长时间没有反应，就不去理他了</span></span><br><span class="line">    &#125;</span><br><span class="line">    myRequest(options, callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的代码块的作用是搜索主网的源代码，找出符合条件的子网页的链接</span></span><br><span class="line">request(seedURL,<span class="function"><span class="keyword">function</span> (<span class="params">err,res,body</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> html = myIconv.decode(body, myEncoding);</span><br><span class="line">    <span class="built_in">console</span>.log(html);</span><br><span class="line">    <span class="comment">//准备用cheerio解析html</span></span><br><span class="line">    <span class="keyword">var</span> $ = myCheerio.load(html, &#123; <span class="attr">decodeEntities</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">//定义一个子网页数组，然后让他把我想要的所有目标链接都写进去，这里，还没有做进一步筛选</span></span><br><span class="line">    <span class="keyword">var</span> seedurl_news;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        seedurl_news = <span class="built_in">eval</span>(seedURL_format);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="built_in">console</span>.log(<span class="string">'url列表所处的html块识别出错：'</span> + e) &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里做了进一步筛选，搜索我们新闻链接数组中的每一个元素</span></span><br><span class="line">    seedurl_news.each(<span class="function"><span class="keyword">function</span> (<span class="params">i,e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个子链接字符串</span></span><br><span class="line">        <span class="keyword">var</span> myURL =<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> href = <span class="string">""</span>;</span><br><span class="line"><span class="comment">//让href等于  &lt;a href="https://post.smzdm.com/p/alpwnzve/"  源代码中href后面的字符串、</span></span><br><span class="line"><span class="comment">//也就是我们想要的子网站的链接          </span></span><br><span class="line">            href = $(e).attr(<span class="string">"href"</span>);     </span><br><span class="line">            <span class="keyword">if</span>(href.toLocaleString().indexOf(<span class="string">'https://'</span>)&gt;=<span class="number">0</span>||href.toLocaleString().indexOf(<span class="string">'http://'</span>)&gt;=<span class="number">0</span>)</span><br><span class="line">                <span class="comment">//这里再做一个判断，如果成功，我们就让子链接等于href</span></span><br><span class="line">            myURL =   href; <span class="comment">//其他</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123; <span class="built_in">console</span>.log(<span class="string">'识别种子页面中的论坛链接出错：'</span> + e) &#125;</span><br><span class="line">        <span class="comment">//同时，如果子链接是不复合我们的正则表达式的，那么，我们就需要遍历下一个。</span></span><br><span class="line">        <span class="keyword">if</span>(!regExp.test(myURL))<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//最后经过三层筛选，我们终于可以进一步读取了，这里用自己定义的newsGet函数</span></span><br><span class="line">        newsGet(myURL);<span class="comment">//读取论坛页面</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//下面是newsGet函数的具体内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newsGet</span>(<span class="params">myURL</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//首先做一个对myURL的访问</span></span><br><span class="line">    request(myURL,<span class="function"><span class="keyword">function</span> (<span class="params">err,res,body</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 然后做一个转码</span></span><br><span class="line">        <span class="keyword">var</span> html_news = myIconv.decode(body,myEncoding);</span><br><span class="line">        <span class="comment">//用cheerio解析，并把我们需要的内容分别存给了各个$开头的内容</span></span><br><span class="line">        <span class="comment">//关于$是怎么操作的，请看我的博客：爬虫项目中引用的包及其用法</span></span><br><span class="line">        <span class="keyword">var</span> $ = myCheerio.load(html_news, &#123; <span class="attr">decodeEntities</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">		<span class="comment">//进行到这一步，我们可以说已经把所有子页面中我们需要的</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"转码读取成功:"</span> + myURL);</span><br><span class="line">        <span class="comment">//然后就定义一个对象，把所有我们需要的信息都放到对象中的属性中去</span></span><br><span class="line">        <span class="keyword">var</span> fetch = &#123;&#125;</span><br><span class="line">        fetch.url = myURL;</span><br><span class="line">        fetch.content = <span class="string">""</span>;</span><br><span class="line">        fetch.crawltime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        fetch.source_encoding = myEncoding; <span class="comment">//编码</span></span><br><span class="line">        fetch.source_name = source_name;</span><br><span class="line">        fetch.interface_format = <span class="built_in">eval</span>(interface_format);</span><br><span class="line">        fetch.content = <span class="built_in">eval</span>(content_format); <span class="comment">//内容</span></span><br><span class="line">		<span class="comment">//最后做一个json文件的存储，关于存储时遇到的问题，我再主博客的问题6有所介绍</span></span><br><span class="line">        <span class="keyword">var</span> filename = source_name + <span class="string">"_"</span> +(<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf() +<span class="string">".json"</span>;</span><br><span class="line">        <span class="comment">// 存储json</span></span><br><span class="line">        fs.writeFileSync(filename, <span class="built_in">JSON</span>.stringify(fetch));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从下面开始的十一个网站，就是如法炮制一般，可以批量生产了，唯一要改动的，就是编码格式，正则表达式，还有更具不同网页源代码改变不同存储类型中的样式</li>
<li>比如，同样是title_format 虎扑后面就是  #j_data 网易就是 h1 这种非常灵活，需要我们一一对照devtool</li>
</ul>
<h3 id="虎扑论坛"><a href="#虎扑论坛" class="headerlink" title="虎扑论坛"></a>虎扑论坛</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"虎扑"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'https://www.hupu.com/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'https://www.hupu.com/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/\d+[.]html/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('#j_data').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> user_format =<span class="string">"$('.u').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.quote-content').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> title_format2 = <span class="string">"$('.headline').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format2 =<span class="string">"$('.artical-main-content').text()"</span>;</span><br></pre></td></tr></table></figure>



<h3 id="网易新闻"><a href="#网易新闻" class="headerlink" title="网易新闻"></a>网易新闻</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"网易"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'https://www.163.com/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"GBK"</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'https://www.163.com/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/\d&#123;2&#125;\/\d&#123;4&#125;\/\d&#123;2&#125;\/.+[.]html/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('#ne_article_source').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('h1').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('.ep-editor').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.post_text').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.post_time_source').text()"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>值得注意的是，网易的编码是GBK而不是utf-8如果以utf-8的编码格式这样把他存入数据库或者保存在json文件夹中，会出现乱码</li>
</ul>
<p><img src="/2020/04/23/%E6%A8%A1%E4%BB%BF%E8%80%81%E5%B8%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BC%80%E5%A7%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/1.png" alt="示例"></p>
<ul>
<li>只要改成myEncoding = “GBK”就可以完美规避这个问题</li>
</ul>
<h3 id="新浪"><a href="#新浪" class="headerlink" title="新浪"></a>新浪</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"新浪体育"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'http://sports.sina.com.cn/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'http://sports.sina.com.cn/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/.+\/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;\/.+[.]shtml/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('.main-title').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('.source ent-source').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.article').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('.show_author').text()"</span>;</span><br><span class="line"><span class="comment">// var content_format2 ="$('.artical-main-content').text()";</span></span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.date').text()"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="东方财富"><a href="#东方财富" class="headerlink" title="东方财富"></a>东方财富</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"东方财富网"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'https://www.eastmoney.com/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'https://www.eastmoney.com/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/.\/\d+[.]html/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('h1').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.time').text()"</span>;</span><br><span class="line"><span class="comment">// var article_source = "$('.source data-source').text()";</span></span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.Body').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('.res-edit').text()"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="雪球财经"><a href="#雪球财经" class="headerlink" title="雪球财经"></a>雪球财经</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"雪球财经"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'https://xueqiu.com/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'https://xueqiu.com/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/\d+\/\d&#123;9&#125;/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('.article__bd__title').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.time').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('.source').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.article__bd__detail').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('.avatar__name').text()"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="中国证券网"><a href="#中国证券网" class="headerlink" title="中国证券网"></a>中国证券网</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"中国证券网"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'http://www.cnstock.com/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"GBK"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'http://www.cnstock.com/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/news,[a-zA-Z]&#123;4&#125;-\d&#123;6&#125;-\d+[.]/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('.title').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.timer').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('.source').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.content').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('.author').text()"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里同样注意，中国证券网也是GBK编码的</li>
</ul>
<h3 id="中财网"><a href="#中财网" class="headerlink" title="中财网"></a>中财网</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"中财网"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'http://www.cfi.net.cn/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'http://www.cfi.net.cn/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/[a-z]\d+[.]/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('h1').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.time').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('.source data-source').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.Body').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('.res-edit').text()"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="凤凰财经"><a href="#凤凰财经" class="headerlink" title="凤凰财经"></a>凤凰财经</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"凤凰财经"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'http://finance.ifeng.com/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'http://finance.ifeng.com/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/.\/[1-9a-zA-Z]&#123;10&#125;/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('.topic-3bY8Hw-9').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.time-hm3v7ddj').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('.source-2pXi2vGI').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.text-3zQ3cZD4').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('#editor_baidu').text()"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="新浪财经"><a href="#新浪财经" class="headerlink" title="新浪财经"></a>新浪财经</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"新浪财经"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'https://finance.sina.com.cn/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'https://finance.sina.com.cn/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/.+\/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;\/.+[.]shtml/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('.main-title').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.date').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('.source ent-source').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('#artibody').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('.article-editor').text()"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="财经网"><a href="#财经网" class="headerlink" title="财经网"></a>财经网</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"财经网"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'http://www.caijing.com.cn/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'http://www.caijing.com.cn/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/\d+\/\d+[.]shtml/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('#cont_title').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('#pubtime_baidu').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('#source_baidu').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('#the_content').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('#editor_baidu').text()"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="金融界"><a href="#金融界" class="headerlink" title="金融界"></a>金融界</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source_name = <span class="string">"金融界"</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">'http://www.jrj.com.cn/'</span>;</span><br><span class="line"><span class="keyword">var</span> myEncoding = <span class="string">"GBK"</span>;</span><br><span class="line"><span class="keyword">var</span> seedURL = <span class="string">'http://www.jrj.com.cn/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;<span class="comment">//a-href</span></span><br><span class="line"><span class="keyword">var</span> regExp =<span class="regexp">/\/\d&#123;4&#125;\/\d&#123;2&#125;\/\d+[.]/</span>;<span class="comment">//获取a href的正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('h1').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> pubtime = <span class="string">"$('.inftop').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> article_source = <span class="string">"$('h1').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format =<span class="string">"$('.texttit_m1').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author =<span class="string">"$('h1').text()"</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>注意，金融界也是GBK编码的网站</li>
</ul>
<h2 id="这些网站的爬虫，我也都有存储至MySQL"><a href="#这些网站的爬虫，我也都有存储至MySQL" class="headerlink" title="这些网站的爬虫，我也都有存储至MySQL"></a>这些网站的爬虫，我也都有存储至MySQL</h2><ul>
<li><p>这里牵扯到一些复杂的分类问题</p>
</li>
<li><p>一开始我想把所有文件分开来放在不同databse下的不同table</p>
</li>
<li><p>但是后来我觉得切换不是很方便，所以直接把所有table放在同一个crawl 数据库下</p>
</li>
<li><p>最后，因为爬取了很多金融网站，而且为了给最后的express框架做一些内容上的支撑，所以我把所有的财经类网站放到了一张名为经济新闻的表中，这时候我们可以看到一张巨大的表格</p>
</li>
<li><p><img src="/2020/04/23/%E6%A8%A1%E4%BB%BF%E8%80%81%E5%B8%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BC%80%E5%A7%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/2.png" alt="示例"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>浅烘4/6冲煮法</title>
    <url>/2020/04/19/%E6%B5%85%E7%83%984-6%E5%86%B2%E7%85%AE%E6%B3%95/</url>
    <content><![CDATA[<p>00’00’’  —————50g</p>
<p>00‘45’‘—————–120g</p>
<p>01’30‘’—————–180g</p>
<p>02‘10’‘—————240g</p>
<p>02’45‘’—————-300g</p>
<p>03‘30’‘—————-结束</p>
<p>粉量：20 g，总水量：300g</p>
<p>水温：88摄氏度</p>
]]></content>
      <tags>
        <tag>coffee</tag>
      </tags>
  </entry>
  <entry>
    <title>清爽的肯尼亚</title>
    <url>/2020/04/19/%E6%B8%85%E7%88%BD%E7%9A%84%E6%9B%BC%E7%89%B9%E5%AE%81/</url>
    <content><![CDATA[<h1 id="清爽的曼特宁"><a href="#清爽的曼特宁" class="headerlink" title="清爽的曼特宁"></a>清爽的曼特宁</h1><ul>
<li>20g</li>
<li>研磨度略粗</li>
<li>水温90度</li>
<li>闷蒸40cc</li>
<li>等15-20s</li>
<li>中间给水，逐渐拉高 ，至200cc</li>
<li>流完</li>
<li>推粉100cc。做甜感</li>
<li>流完</li>
</ul>
]]></content>
      <tags>
        <tag>coffee</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫项目中引用的包及其用法</title>
    <url>/2020/04/23/%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%85%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="爬虫项目中引用的包及其用法"><a href="#爬虫项目中引用的包及其用法" class="headerlink" title="爬虫项目中引用的包及其用法"></a>爬虫项目中引用的包及其用法</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>爬虫项目，需要用到一下几个包</li>
</ul>
<ol>
<li>fs</li>
<li>request</li>
<li>iconv</li>
<li>cheerio</li>
</ol>
<h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><p>fs模块是内置模块，无需通过npm下载，只要在一开始通过这行代码引用就行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>fs里面的api很多，但是在爬虫项目中，我们只用了一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.writeFileSync(filename, <span class="built_in">JSON</span>.stringify(fetch));</span><br></pre></td></tr></table></figure>

<ul>
<li>writeFileSync()这个函数主要是用来同步写入文件的，第一个参数是文件路径，第二个是写入文件的字符串，第三个是文件编码，默认是utf8</li>
</ul>
<h3 id="request模块"><a href="#request模块" class="headerlink" title="request模块"></a>request模块</h3><p>request模块需要调用npm导入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install request --save</span><br></pre></td></tr></table></figure>

<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.65 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//header就是伪装成一个浏览器，为了防止网站的反爬虫机制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        url: url,</span><br><span class="line">        encoding: <span class="literal">null</span>,<span class="comment">//编码</span></span><br><span class="line">        <span class="comment">//proxy: 'http://x.x.x.x:8080',</span></span><br><span class="line">        headers: headers,<span class="comment">//上面写的headers</span></span><br><span class="line">        timeout: <span class="number">10000</span> <span class="comment">//反应时间，超过这个毫秒数，我们就放弃这个网页</span></span><br><span class="line">    &#125;</span><br><span class="line">    myRequest(options, callback)</span><br><span class="line">    <span class="comment">//这里需要知道options和callback是什么意思</span></span><br><span class="line">    <span class="comment">//options是构建请求的必要参数</span></span><br><span class="line">	<span class="comment">//callback是请求成功后执行的回调函数</span></span><br><span class="line">    <span class="comment">//也就是我们要请求访问网站的一个动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>写好request函数之后我们需要在以下两个函数中调用</li>
</ul>
<ol>
<li><p>读取种子页面，遍历新闻链接的时候（此时在母网站）</p>
</li>
<li><p>读取新闻链接的时候（此时在子网站）</p>
</li>
</ol>
<p>因为这篇文章知识介绍各个模块的作用和功能，所以函数具体如何展开不予以讨论</p>
<h3 id="iconv-lite模块"><a href="#iconv-lite模块" class="headerlink" title="iconv-lite模块"></a>iconv-lite模块</h3><p>iconv-lite模块需要用npm导入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install iconv-lite --save</span><br></pre></td></tr></table></figure>

<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>iconv-lite的作用就是转码，比如在这行代码中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = myIconv.decode(body, myEncoding);</span><br><span class="line"><span class="keyword">var</span> html_news = myIconv.decode(body, myEncoding);</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以看到 用iconv-lite.decode( , )可以转码，这里myEncoding已经设置成了’utf-8’</li>
<li>通过转码能规避乱码现象</li>
</ul>
<h3 id="cheerio模块"><a href="#cheerio模块" class="headerlink" title="cheerio模块"></a>cheerio模块</h3><p>cheerio 模块需要用npm导入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install cheerio --save</span><br></pre></td></tr></table></figure>

<h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><ul>
<li>cheerio 模块是爬虫中很重要的一个模块最主要的作用就是加载你想要访问的HTML页面，可以说，就是把html页面翻译给我们的处理器。有了它我们才能对网页做进一步处理操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"><span class="comment">//在引用过后，myCheerio在爬虫项目中在以下两个地方使用到了</span></span><br><span class="line"><span class="keyword">var</span> html =myIconv.decode(body, myEncoding);</span><br><span class="line"><span class="keyword">var</span> $ = myCheerio.load(html, &#123; <span class="attr">decodeEntities</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> html_news = myIconv.decode(body, myEncoding); </span><br><span class="line"><span class="keyword">var</span> $ = myCheerio.load(html_news, &#123; <span class="attr">decodeEntities</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var $ = cheerio.load(html,&#123;decodeEntities:false&#125;);</span></span><br><span class="line"><span class="comment">load函数的第一个参数html就是之前http.get方法中所获得的数据；第二个参数可选，主要是用来设置格式，比如decodeEntities:false设置了不会出现中文乱码。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="关于-符号的问题"><a href="#关于-符号的问题" class="headerlink" title="关于 $ 符号的问题"></a>关于 $ 符号的问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seedURL_format = <span class="string">"$('a')"</span>;</span><br><span class="line"><span class="keyword">var</span> keywords_format = <span class="string">" $('meta[name=\"keywords\"]').eq(0).attr(\"content\")"</span>;</span><br><span class="line"><span class="keyword">var</span> title_format = <span class="string">"$('title').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> date_format = <span class="string">"$('#pubtime_baidu').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> author_format = <span class="string">"$('#editor_baidu').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> content_format = <span class="string">"$('.left_zw').text()"</span>;</span><br><span class="line"><span class="keyword">var</span> desc_format = </span><br><span class="line"><span class="string">" $('meta[name=\"description\"]').eq(0).attr(\"content\")"</span>;</span><br><span class="line"><span class="keyword">var</span> source_format = <span class="string">"$('#source_baidu').text()"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	在这里，$ 符号就是查找的意思</span></span><br><span class="line"><span class="comment">	1 $('a') 查找的就是以a打头的 子网页链接</span></span><br><span class="line"><span class="comment">	&lt;a href="//www.chinanews.com/gn/2020/04-22/9164904.shtml"&gt;</span></span><br><span class="line"><span class="comment">	2 $('meta[name=\"keywords\"]').eq(0).attr(\"content\")"</span></span><br><span class="line"><span class="comment">	查找的就是这一类标签中的content内容，eq（0）就是从头开始把你后面content里的东西都取出来</span></span><br><span class="line"><span class="comment">	&lt;meta name="keywords" content="确诊病例,出院,疑似病例,死亡病例,治愈" /&gt;</span></span><br><span class="line"><span class="comment">	3.$('title').text()</span></span><br><span class="line"><span class="comment">	查找的就是&lt;title&gt;标签中的text内容</span></span><br><span class="line"><span class="comment">	&lt;title&gt;31省份新增新冠肺炎确诊病例 其中4例为本土病例-中新网&lt;/title&gt;</span></span><br><span class="line"><span class="comment">	4. $('#pubtime_baidu').text()</span></span><br><span class="line"><span class="comment">	查找的就是&lt;span id="pubtime_baidu"&gt;2020-04-23 08:40:21&lt;/span&gt;</span></span><br><span class="line"><span class="comment">	中的text内容</span></span><br><span class="line"><span class="comment">		注意，这里的#的作用就是表示 id的名字</span></span><br><span class="line"><span class="comment">	5.$('#editor_baidu').text()</span></span><br><span class="line"><span class="comment">	查找的是  &lt;span id="editor_baidu"&gt;责任编辑：于晓&lt;/span&gt;中的text内容</span></span><br><span class="line"><span class="comment">	6.$('.left_zw').text()</span></span><br><span class="line"><span class="comment">	查找的就是&lt;div class="left_zw"&gt; </span></span><br><span class="line"><span class="comment">	注意，这里我们要在left_zw前面加上一个 . 具体原因应该是和class有关系</span></span><br><span class="line"><span class="comment">	7.8 就不讲了</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//随后，在用cheerio读取网站源代码的时候，网站内的信息会分门别类存储到各自对印的$中去，完成信息爬取</span></span><br><span class="line">  <span class="keyword">var</span> $ = myCheerio.load(html_news, &#123; <span class="attr">decodeEntities</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>耶加雪菲超香冲法</title>
    <url>/2020/04/19/%E8%80%B6%E5%8A%A0%E9%9B%AA%E8%8F%B2%E8%B6%85%E9%A6%99%E5%86%B2%E6%B3%95/</url>
    <content><![CDATA[<h1 id="耶加雪菲超香冲法"><a href="#耶加雪菲超香冲法" class="headerlink" title="耶加雪菲超香冲法"></a>耶加雪菲超香冲法</h1><h2 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h2><ul>
<li>20g豆子</li>
<li>研磨度4.5</li>
<li>V60滤杯</li>
<li>水温 92度</li>
<li>第一段闷蒸40cc 中间三秒绕三圈</li>
<li>给大水100cc ，把白色泡泡挖出</li>
<li>等水全部流完</li>
<li>分两段给水，给75cc</li>
<li>等全部流完，给第二次断水</li>
<li>给道300cc</li>
<li>2min40s</li>
</ul>
]]></content>
      <tags>
        <tag>coffee</tag>
      </tags>
  </entry>
  <entry>
    <title>用nodejs来制作一个简单的爬虫来爬取网页信息</title>
    <url>/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="用nodejs来制作一个简单的爬虫来爬取网页信息"><a href="#用nodejs来制作一个简单的爬虫来爬取网页信息" class="headerlink" title="用nodejs来制作一个简单的爬虫来爬取网页信息"></a>用nodejs来制作一个简单的爬虫来爬取网页信息</h1><h2 id="写在前面——知其然也要知其所以然"><a href="#写在前面——知其然也要知其所以然" class="headerlink" title="写在前面——知其然也要知其所以然"></a>写在前面——知其然也要知其所以然</h2><ul>
<li><p>像我这样连冲个咖啡豆要记笔记的人，怎么能写自己都看不懂的博客呢？所以我的目标是你读完了我的博客，也可以写出爬虫来。</p>
</li>
<li><p>这一篇是目录性质的博客，冰冻三尺非一日之寒，爬虫项目只写一篇博客是完全不够的，所以我打算用分而治之的框架来完成这篇博客的内容。我想把它分成几个部分，逐个击破，已达到融会贯通的地步（显然这是基本不可能的）</p>
</li>
<li><p>最近学校的web编程课要求我们做一个爬虫来爬取网页信息，老师给出了一个新闻网站的爬取，但是因为缺少对JavaScript语言的认识和运用，用nodejs来写显得举步维艰。（水平过于低下）</p>
</li>
<li><p>前三个问题，注重于基础知识，是为正式的爬虫项目打基础、做准备的，罗马不是一天建成的，有了前面的基础知识，对爬虫有了初步了解，才能够有能力看得懂（我说只是有能力看懂）每一步的操作</p>
</li>
</ul>
<ol>
<li><h6 id="对JavaScript语法的陌生"><a href="#对JavaScript语法的陌生" class="headerlink" title="对JavaScript语法的陌生"></a>对JavaScript语法的陌生</h6></li>
<li><h6 id="对爬虫原理的陌生"><a href="#对爬虫原理的陌生" class="headerlink" title="对爬虫原理的陌生"></a>对爬虫原理的陌生</h6></li>
<li><p>对正则表达式的陌生</p>
</li>
<li><p>爬虫项目中引用的包及其用法</p>
</li>
<li><p>如何选定一个网站，并模仿老师的代码开始我的爬虫项目？</p>
</li>
<li><p>用JSON格式存储时的重名问题</p>
</li>
<li><p>对爬取特定信息的格式问题</p>
</li>
<li><p>将数据存储到MySql时遇到的问题</p>
</li>
<li><p>如何用mysql查询已经爬取的数据</p>
</li>
<li><p>用网页发送请求到后端查询</p>
</li>
<li><p>用express构建网站访问mysql</p>
</li>
<li><p>用表格显示查询结果</p>
</li>
<li><p>爬虫定时工作</p>
</li>
<li><p>尝试其他的扩展（留给读者，或者无限期暂停更新）</p>
</li>
</ol>
<ul>
<li>所以，这篇文章列举了我在写爬虫项目时候的种种问题和解答，如果篇幅不长，我会直接在博文里介绍，如果篇幅过长，我会另写一篇博客，并在这里附上链接，以供读者方便切换阅读</li>
</ul>
<h3 id="1-对JavaScript语法的陌生"><a href="#1-对JavaScript语法的陌生" class="headerlink" title="1.对JavaScript语法的陌生"></a>1.对JavaScript语法的陌生</h3><h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>在大一下之前，我对JavaScript一脸茫然，甚至认为JavaScript和Java是一种语言，这显然是过于荒唐的一件事。认真学习JavaScript也是在网课进行了一个半月之后。</p>
<h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>对于老师的每章节网课，我都有在博客上记笔记，可以看看我的JavaScript语法系列博客</p>
<p><a href="https://jasonxqh.github.io/2020/04/20/JavaScript-4表达式和运算符/" target="_blank" rel="noopener">Javascript表达式和运算符</a></p>
<p><a href="https://jasonxqh.github.io/2020/04/21/Javascript-5语句/" target="_blank" rel="noopener">Javascript语句</a></p>
<p><a href="https://jasonxqh.github.io/2020/04/21/Javascript-6对象/" target="_blank" rel="noopener">Javascript对象</a></p>
<p><a href="https://jasonxqh.github.io/2020/04/21/Javascript-7数组/" target="_blank" rel="noopener">Javascript数组</a></p>
<p><a href="https://jasonxqh.github.io/2020/04/21/Javascript-8函数/" target="_blank" rel="noopener">JavaScript函数</a></p>
<p>在没有学习过Javascript语法的时候，就上手爬虫项目，无异于以卵击石，自不量力。对于每一句话，每一个函数，都在脑子中缓缓打出一个？</p>
<h3 id="2-对爬虫原理的陌生"><a href="#2-对爬虫原理的陌生" class="headerlink" title="2.对爬虫原理的陌生"></a>2.对爬虫原理的陌生</h3><h4 id="起因-1"><a href="#起因-1" class="headerlink" title="起因"></a>起因</h4><p> 这方面对于没有学过爬虫原理的我来说要理解起来确实有点困难，但是幸好老师提供了几期视频来阐述，于是懵懵懂懂有个概念。</p>
<h4 id="如何解决？-1"><a href="#如何解决？-1" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>看了几遍老师的代码和讲解后，可以简单得将爬虫的思想列举一下</p>
<ol>
<li>首先我们搜索主页面，获取我们想要的子网页的URL<ul>
<li>通过request请求，cheerio解析，each遍历</li>
</ul>
</li>
<li>搜索出我们子网页页面中我们需要的信息：标题，正文等<ul>
<li>通过request请求，cheerio解析</li>
</ul>
</li>
<li>将这些我们需要的信息保存下来，通过各种形式访问到这种信息<ul>
<li>建立fetch(文件对象)，输入文件信息，fs /mysql模块写入</li>
</ul>
</li>
</ol>
<p>读到这里，你只需要了解我们要一步步完成的目标就行，具体的工具我会在接下来的文章中一一讲述。</p>
<h3 id="3-对正则表达式的陌生"><a href="#3-对正则表达式的陌生" class="headerlink" title="3.对正则表达式的陌生"></a>3.对正则表达式的陌生</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>没有接触过正则表达式，一开始看到的时候感叹——这像天书般的/{}$.+-[]根本无从下手<br>有一说一，我就是因为看不懂这么几行正则表达式，才迟迟不开始爬虫作业（特别不好学）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url_reg = <span class="regexp">/\/(\d&#123;4&#125;)\/(\d&#123;2&#125;)-(\d&#123;2&#125;)\/(\d&#123;7&#125;).shtml/</span>;</span><br><span class="line"><span class="keyword">var</span> regExp = <span class="regexp">/((\d&#123;4&#125;|\d&#123;2&#125;)(\-|\/|\.)\d&#123;1,2&#125;\3\d&#123;1,2&#125;)|(\d&#123;4&#125;年\d&#123;1,2&#125;月\d&#123;1,2&#125;日)/</span></span><br></pre></td></tr></table></figure>

<h4 id="如何解决？-2"><a href="#如何解决？-2" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>显然，ddl是第一生产力。只剩下两周的时间了，我找了几期正则表达式的教学视频来补习了一下，也是勉强有了大概，并且用了这个页面上的正则表达式检测器练习了几遍。</p>
<ul>
<li><a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">菜鸟工具</a></li>
<li>咦，他叫自己菜鸟工具，正好，非常适合我。</li>
<li>这里补充一下练习模式，就是在某一个网站上找源代码，然后找全部都是一种模式的网址或者图片。对着他写下你的正则表达式，然后把源代码复制到这个菜鸟工具中，检测一下是否把你想要的哪些网站都搜索出来了。</li>
<li>笨方法才是好方法，要写自己看的懂的，不要用很巧妙的正则表达式，当然大佬自动忽略。</li>
<li>程度，现在勉强可以看着网址写出他的正则表达式了</li>
<li>关于我如何学习正则表达式和正则表达式的具体概念，参见我的另一篇博客 —初识正则表达式   </li>
<li><a href="https://jasonxqh.github.io/2020/04/20/初识正则表达式/" target="_blank" rel="noopener">初识正则表达式</a>  </li>
</ul>
<h3 id="4-爬虫项目中引用的包及其用法"><a href="#4-爬虫项目中引用的包及其用法" class="headerlink" title="4.爬虫项目中引用的包及其用法"></a>4.爬虫项目中引用的包及其用法</h3><h4 id="起因-2"><a href="#起因-2" class="headerlink" title="起因"></a>起因</h4><ul>
<li>我们不能简单的把几个模块引用过来但不知道其具体作用</li>
</ul>
<h4 id="如何解决？-3"><a href="#如何解决？-3" class="headerlink" title="如何解决？"></a>如何解决？</h4><ul>
<li><p>因此，我另写了篇博客来谈谈爬虫中需要引入的模块和它们的作用</p>
</li>
<li><p><a href="https://jasonxqh.github.io/2020/04/23/爬虫项目中引用的包及其用法/" target="_blank" rel="noopener">爬虫项目中引用的包及其用法</a></p>
</li>
</ul>
<h3 id="5-如何选定一个网站，并模仿老师的代码开始我的爬虫项目？"><a href="#5-如何选定一个网站，并模仿老师的代码开始我的爬虫项目？" class="headerlink" title="5.如何选定一个网站，并模仿老师的代码开始我的爬虫项目？"></a>5.如何选定一个网站，并模仿老师的代码开始我的爬虫项目？</h3><h4 id="起因-3"><a href="#起因-3" class="headerlink" title="起因"></a>起因</h4><p>读懂了老师的代码，才是开始自己爬虫的第一步。那么，是应该选择什么网站来开始我的爬虫项目呢？娱乐网站?新闻网站？购物网站？ 最后，作为练习时长大半年的<del>个人练习生</del> 吧台手和资深键盘咖啡师的我来说，还是选择了什么值得买网站作为我的第一个爬虫项目（想看看大家的开箱报告）</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>因为这里的空间不是很够，所以我会新建一篇博客详细讨论一下我是如何解决的</p>
<p><a href="https://jasonxqh.github.io/2020/04/23/模仿老师的代码开始自己的爬虫项目/" target="_blank" rel="noopener">模仿老师的代码开始自己的爬虫项目</a></p>
<h3 id="6-用JSON格式存储时的重名问题"><a href="#6-用JSON格式存储时的重名问题" class="headerlink" title="6.用JSON格式存储时的重名问题"></a>6.用JSON格式存储时的重名问题</h3><p>我写完代码之后，已经成功地转码了</p>
<ol>
<li>但是却没有.json文件保存下来</li>
<li>存储下来了，但不是JSON文件</li>
</ol>
<h4 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h4><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>问了助教和老师之后，在大家一起努力下，找到了问题并成功解决了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> filename = source_name + <span class="string">"_"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()).toFormat(<span class="string">"YYYY-MM-DD"</span>) +</span><br><span class="line"><span class="string">"_"</span> + myURL.substr(myURL.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>) + <span class="string">".json"</span>;</span><br></pre></td></tr></table></figure>

<p>一开始，我和老师命名文件的时候用的是同一行代码，但是很显然，这个存储方法不是放诸四海皆准的，我们需要结合网站的url和具体作用来具体分析，然后再选择一个不会让文件重名的命名方法.</p>
<p>说白了，就是你怎样通过字符串拼接来给这么多文件取互不相同的名字？？</p>
<p><strong>首先看看中国新闻网的（子网页）URL</strong></p>
<p><a href="http://www.chinanews.com/gn/2020/04-23/9166028.shtml" target="_blank" rel="noopener">http://www.chinanews.com/gn/2020/04-23/9166028.shtml</a></p>
<p> <strong>再来看看什么值得买 (子网页）的URL</strong></p>
<p><a href="https://post.smzdm.com/p/531543/" target="_blank" rel="noopener">https://post.smzdm.com/p/531543/</a></p>
<p>结合老师的命名方法，我们一步一步分析,</p>
<ol>
<li><p>source_name 是我们规定的，在老师的代码里，是”中国新闻网”，在我的代码里是”什么值得买“，到现在，所有文件的命名都是一样的</p>
</li>
<li><p>(new Date()).toFormat(“YYYY-MM-DD”) 是用一个新的Date()对象，然后转码成YYYY-MM-DD的形式，如果在这里我仍然和老师的代码一样，那么到这里，所有的文件命名也还是一样的</p>
</li>
<li><p>最关键的一点，老师的这部分 myURL.substr(myURL.lastIndexOf(‘/‘) + 1)，也就是说，他截取了URL的一部分，那么，是从什么时候开始截取 的呢？</p>
<ol>
<li><p>lastIndexOf()这个api在我的Javascript数组这篇博客中有些到，就是从尾部开始遍历数组或者字符串，返回’/‘出现的第一个索引，然后把他加1</p>
</li>
<li><p>substr是字符串截取函数，这里是从myURL.lastIndexOf(‘/‘) + 1处开始截取，一直到末尾结束</p>
</li>
<li><p>我们可以看到，根据上面那个例子最后一个’/‘+1之后的字符串为9166028.shtml，而这一部分对中国新闻网的每一个页面都是不同的</p>
</li>
</ol>
</li>
<li><p>但是我的URL呢？我们如果用myURL.substr(myURL.lastIndexOf(‘/‘) + 1)这个方法呢？</p>
<ol>
<li>从什么值得买子网页可以看出，最后一个‘/’就是字符串中的最后一位，所以再加一，再截取，那么我们根本截取不到任何东西！！！</li>
</ol>
</li>
<li><p>所以这就出现了问题，老师在这一步已经完成了不同文件的命名，但我这时候所有的文件命名任然是一样的</p>
</li>
<li><p>最后只是加上后缀名’.json’,大家都一样</p>
</li>
</ol>
<ul>
<li><p>那么这就是问题的痛点了。我因为所有的文件名字都一样，所以电脑上更本无法保存，如何修改呢？？</p>
</li>
<li><p>通过老师的点拨，我对代码做了这样的修改</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> filename = source_name + <span class="string">"_"</span> +(<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf()+<span class="string">"_"</span>+<span class="string">".json"</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>我把新的Date()对象，使用了valueOf()的方法（返回的是毫秒数）</p>
</li>
<li><p>因为爬取每个页面的时间精确到毫秒级别，所以单单提取秒数是远远不够的，所以我没有用getSeconds()方法，而用了valueOf()方法</p>
</li>
<li><p>经过再操作，这个问题解决了！</p>
<h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5></li>
</ol>
<p>现在，我已经实现了保存文件，但是，却都是这样的</p>
<p> <img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/2.png" alt="示例"></p>
<p>他没有任何的文件类型，这是啥情况呢</p>
<p><strong>返回代码本身，看看 .json 之前出了什么问题</strong></p>
<p>果然，我们发现了一个多余的下划线，本来是在老师的代码里面连接9166028.shtml用的，我没有把他删掉，这样， 下划线和.json的. 相连接，不符合命名规范。所以无法存储</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> filename = source_name + <span class="string">"_"</span> +(<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf() +<span class="string">".json"</span>;</span><br></pre></td></tr></table></figure>

<p>改成这样后，再运行，就完美了</p>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/3.png" alt="示例"></p>
<h3 id="7-对爬取特定信息的格式问题"><a href="#7-对爬取特定信息的格式问题" class="headerlink" title="7.对爬取特定信息的格式问题"></a>7.对爬取特定信息的格式问题</h3><h4 id="起因-4"><a href="#起因-4" class="headerlink" title="起因"></a>起因</h4><p>我准备爬取一个title和文章的内容，但是一开始只有文章内容被保留了下来，title并没有被爬取到</p>
<h4 id="如何解决？-4"><a href="#如何解决？-4" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>助教一阵见血的指出了我的错误</p>
<ul>
<li>原来，本来我的代码是这样的：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> interface_format = <span class="string">"$('.edit_interface').text()"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然而，网站里的源代码竟然是这样的</li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/4.png" alt="示例"></p>
<p>我们看见&lt;span class=”edit_interface”&gt; &lt;/span&gt; 这一行代码没有任何东西！</p>
<p>所以，我们爬取下来的文件，变成了这样：</p>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/5.png" alt="示例"></p>
<p>当我们改成下面代码的时候，一切都好起来了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> interface_format = <span class="string">"$('h1.item-name').text()"</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/6.png" alt="示例"></p>
<h3 id="8-如何把数据存储到MySql中？"><a href="#8-如何把数据存储到MySql中？" class="headerlink" title="8.如何把数据存储到MySql中？"></a>8.如何把数据存储到MySql中？</h3><h4 id="起因-5"><a href="#起因-5" class="headerlink" title="起因"></a>起因</h4><p>如果说只能把内容存储到json文件中，那管理起来很麻烦。我们可以通过修改一下代码，让内容存储到数据库当中</p>
<h4 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h4><p>看了老师的视频之后，在问过助教之后，最终解决了</p>
<p>具体怎么解决，请看我的子博文：如何把数据存储到MySql中</p>
<p><a href="https://jasonxqh.github.io/2020/04/24/如何把数据存储到MySql中/" target="_blank" rel="noopener">如何把数据存储到MySql中？</a></p>
<h3 id="9-如何用mysql查询已经爬取的数据"><a href="#9-如何用mysql查询已经爬取的数据" class="headerlink" title="9.如何用mysql查询已经爬取的数据"></a>9.如何用mysql查询已经爬取的数据</h3><h4 id="起因-6"><a href="#起因-6" class="headerlink" title="起因"></a>起因</h4><ul>
<li>已经爬取到了那么多数据，并且存放到了Mysql中了，那么怎么才能访问、查询他们呢？</li>
</ul>
<h4 id="如何解决-3"><a href="#如何解决-3" class="headerlink" title="如何解决"></a>如何解决</h4><ul>
<li>大量搜寻： <ul>
<li>select title,url from fetches                 //title，url可以换成任意种类，但这样所有的数据都会呈现</li>
<li>select title,url from fetches limit 20  //这样，呈现的信息就被限制在了20条</li>
<li>因为这样搜索的结果已经在<a href="https://jasonxqh.github.io/2020/04/24/如何把数据存储到MySql中/" target="_blank" rel="noopener">如何把数据存储到MySql中?</a>这篇博文中有所展示，因此不予赘述</li>
</ul>
</li>
<li>关键词搜寻<ul>
<li>select title,author,publish_date from fetches where title like ‘%新冠%’；</li>
<li>结果如下</li>
<li><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/7.png" alt="示例"></li>
<li>select interface_format,url,crawltime from fetches where interface_format like ‘%咖啡%’;</li>
<li>结果如下</li>
<li><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/8.png" alt="示例"></li>
</ul>
</li>
<li>利用js文件搜寻</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'./mysql_coffee.js'</span>);</span><br><span class="line"><span class="keyword">var</span> title = <span class="string">'咖啡'</span>;</span><br><span class="line"><span class="keyword">var</span> select_Sql = <span class="string">"select  interface_format,url,crawltime  from fetches where interface_format like '%"</span> + title + <span class="string">"%'"</span>;</span><br><span class="line"></span><br><span class="line">mysql.query(select_Sql, <span class="function"><span class="keyword">function</span>(<span class="params">qerr, vals, fields</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vals);</span><br><span class="line">&#125;);</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'./mysql.js'</span>);</span><br><span class="line"><span class="keyword">var</span> title = <span class="string">'新冠'</span>;</span><br><span class="line"><span class="keyword">var</span> select_Sql = <span class="string">"select title,author,publish_date from fetches where title like '%"</span> + title + <span class="string">"%'"</span>;</span><br><span class="line"></span><br><span class="line">mysql.query(select_Sql, <span class="function"><span class="keyword">function</span>(<span class="params">qerr, vals, fields</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vals);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一部分是老师的文件，第二部分是我的搜索文件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，是引用的文件不一样，一个是引用了mysql_coffee.js，另一个是mysql.js这决定了查询的数据库不同</span></span><br><span class="line"><span class="comment">其次，我的关键词是咖啡，老师的关键词是新冠</span></span><br><span class="line"><span class="comment">再然，我搜索的是标题、链接和爬取时间，老师搜索的是标题，作者，出版时间</span></span><br><span class="line"><span class="comment">注意： 不管是前面多么不一样 最后的  '%" + title + "%' 始终是一样的，这个title不是存储类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>来看看结果</li>
<li>老师的结果</li>
<li><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/9.png" alt="示例"></li>
<li>我的结果</li>
<li><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/10.png" alt="示例"></li>
</ul>
<h3 id="10-如何用网页发送请求到后端查询"><a href="#10-如何用网页发送请求到后端查询" class="headerlink" title="10.如何用网页发送请求到后端查询"></a>10.如何用网页发送请求到后端查询</h3><h4 id="起因："><a href="#起因：" class="headerlink" title="起因："></a>起因：</h4><ul>
<li>怎么样在网页上查询关键词，并在我的后端返回结果呢？</li>
</ul>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ul>
<li>首先，我们创建一个html前端</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:8080/7.02.html"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span> 标题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>具体样式如下</li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/11.png" alt="示例"></p>
<ul>
<li>随后，我们建立一个后端，这里用了http模块，而没有用其他框架</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'./mysql.js'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="keyword">var</span> params = url.parse(request.url, <span class="literal">true</span>).query; </span><br><span class="line">    <span class="comment">//先去读取文件</span></span><br><span class="line">    fs.readFile(pathname.substr(<span class="number">1</span>), <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=utf-8'</span> &#125;);</span><br><span class="line">        <span class="comment">//如果文件非空，那么先把文件给打印出来</span></span><br><span class="line">        <span class="keyword">if</span> ((params.title === <span class="literal">undefined</span>) &amp;&amp; (data !== <span class="literal">undefined</span>))</span><br><span class="line">            response.write(data.toString());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，我们去数据库寻找，并打印出来</span></span><br><span class="line">            response.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">            <span class="comment">//数据库查找语言：title,author,publish_date这些都是存储的数据类型</span></span><br><span class="line">            <span class="comment">//where title like title就是要查询的关键词所在的数据类型，一般都是title</span></span><br><span class="line">            <span class="comment">// params.title 就是我们在网站上搜寻的关键词</span></span><br><span class="line">            <span class="keyword">var</span> select_Sql = <span class="string">"select title,author,publish_date from fetches where title like '%"</span> +</span><br><span class="line">                params.title + <span class="string">"%'"</span>;</span><br><span class="line">            mysql.query(select_Sql, <span class="function"><span class="keyword">function</span>(<span class="params">qerr, vals, fields</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//把这些打印出来</span></span><br><span class="line">                <span class="built_in">console</span>.log(vals);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        response.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8080/7.02.html'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以看到，老师的代码运行后，在搜索框中写入  新冠 后是这样一个结果</li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/12.png" alt="示例"></p>
<ul>
<li>而我们对这个代码稍加修改，马上可以爬取到自己想要的文件</li>
<li>比如，我想在什么值得买 表格中搜寻 ：咖啡 </li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/13.png" alt="示例"></p>
<ul>
<li>又比如，我想在新浪网 表格上搜寻： 切尔西</li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/14.png" alt="示例"></p>
<ul>
<li>再比如，我想在东方财富 表格上搜寻： 股市</li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/15.png" alt="示例"></p>
<p>可以看出，这个问题就算是解决了。</p>
<h3 id="11-如何用express构建网站访问mysql"><a href="#11-如何用express构建网站访问mysql" class="headerlink" title="11.如何用express构建网站访问mysql"></a>11.如何用express构建网站访问mysql</h3><h4 id="起因-7"><a href="#起因-7" class="headerlink" title="起因"></a>起因</h4><ul>
<li>在后端显示其实意义不大，我们要在前端显示，才能体现搜寻效果，那么怎么才能前端现实呢？</li>
</ul>
<h4 id="如何解决-4"><a href="#如何解决-4" class="headerlink" title="如何解决"></a>如何解决</h4><ul>
<li>我们用express框架来构建</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    //唯一不同的是，把7.02html改成了process_get</span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:8080/process_get"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span> 标题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后我们用express来写后端，虽然功能更丰富，但是代码更为简洁</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'./mysql.js'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//app.use(express.static('public'));</span></span><br><span class="line">app.get(<span class="string">'/7.03.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendFile(__dirname + <span class="string">"/"</span> + <span class="string">"7.03.html"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/process_get'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//先设置编码</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/html;charset=utf-8'</span> &#125;); <span class="comment">//设置res编码为utf-8</span></span><br><span class="line">    <span class="comment">//sql字符串和参数，和上面的代码相同</span></span><br><span class="line">    <span class="keyword">var</span> fetchSql = <span class="string">"select url,source_name,title,author,publish_date from fetches where title like '%"</span> +</span><br><span class="line">        req.query.title + <span class="string">"%'"</span>;</span><br><span class="line">    <span class="comment">//然后把这些参数放到result中</span></span><br><span class="line">    mysql.query(fetchSql, <span class="function"><span class="keyword">function</span>(<span class="params">err, result, fields</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="comment">//json字符串话</span></span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"访问地址为 http://127.0.0.1:8080/7.03.html"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过简单的修改，我们可以查询到自己想要的文件</li>
<li>比如我想再什么值得买中搜寻咖啡</li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/16.png" alt="示例"></p>
<ul>
<li>比如我想在虎扑上搜寻球</li>
</ul>
<p><img src="/2020/04/20/%E7%94%A8nodejs%E6%9D%A5%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%9D%A5%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%BF%A1%E6%81%AF/17.png" alt="示例"></p>
<ul>
<li>到这里，这个问题也解决了</li>
</ul>
<h3 id="12-如何用表格显示查询结果"><a href="#12-如何用表格显示查询结果" class="headerlink" title="12.如何用表格显示查询结果"></a>12.如何用表格显示查询结果</h3><h4 id="起因-8"><a href="#起因-8" class="headerlink" title="起因"></a>起因</h4><p>向上面的那种显示方法，还是缺少美观性，那么我们试试用表格显示查询结果</p>
<h4 id="如何解决？-5"><a href="#如何解决？-5" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>这里的空间不是很够，请移步我的子博文： <a href="https://jasonxqh.github.io/2020/04/26/如何用表格显示查询结果/" target="_blank" rel="noopener">如何用表格显示查询结果</a></p>
<h3 id="13-爬虫定时工作"><a href="#13-爬虫定时工作" class="headerlink" title="13.爬虫定时工作"></a>13.爬虫定时工作</h3><h4 id="起因：-1"><a href="#起因：-1" class="headerlink" title="起因："></a>起因：</h4><p>每次手动爬取太麻烦，怎么样才能定时操控爬虫呢？</p>
<h4 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h4><ul>
<li>引入第三方包 node-schedule;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install node-schedule;</span><br></pre></td></tr></table></figure>

<ul>
<li>爬虫代码中引入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> schedule = <span class="built_in">require</span>(<span class="string">'node-schedule'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时执行</span></span><br><span class="line"><span class="keyword">var</span> rule = <span class="keyword">new</span> schedul.RecurrenceRule();</span><br><span class="line"><span class="keyword">var</span> times = [<span class="number">0</span>,<span class="number">12</span>];<span class="comment">//每天两次自动执行</span></span><br><span class="line"><span class="keyword">var</span> times2 = <span class="number">5</span>		<span class="comment">//分钟</span></span><br><span class="line">rule.hour = times;</span><br><span class="line">rule.minute = times2;</span><br><span class="line"><span class="comment">// 定时执行httpGet()函数</span></span><br><span class="line">schedule.scheduleJob(rule,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   seedget(); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seedget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    request(seedURL, <span class="function"><span class="keyword">function</span>(<span class="params">err, res, body</span>) </span>&#123; <span class="comment">//读取种子页面</span></span><br><span class="line"><span class="comment">//  	.........</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-尝试其他的扩展（留给读者，或者无限期暂停更新）"><a href="#13-尝试其他的扩展（留给读者，或者无限期暂停更新）" class="headerlink" title="13.尝试其他的扩展（留给读者，或者无限期暂停更新）"></a>13.尝试其他的扩展（留给读者，或者无限期暂停更新）</h3><ul>
<li>对查询结果进行分页显示</li>
<li>对查询结果按每个字段进行排序</li>
<li>对多个查询条件进行复合查询</li>
<li>其他功能和性能的提升</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>山再高，也得往上攀。浪波涛，也得去划船。我们在学习过程中需要有程序员精神。就是不断地发现问题，解决问题，虽然水平不高，但是大佬的水平也是在一次次的解决问题中提高的。 曾经自己认为高难度的作业也会一点一点被自己征服。</p>
<p>完成一个比较大的项目，一定要把它拆分成很多小问题，这也是一种很实用的编程思维。分而治之，逐个击破。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(项目未完成) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(出现了问题)</span><br><span class="line">    &#123;</span><br><span class="line">     学习 | | 问老师； </span><br><span class="line">        问题解决了没？ 项目继续：学习+寻求更多帮助；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ul>
<li><p>我初次尝试爬虫项目的时候，是助教高瑞卿学姐热心帮我解答了很多疑难问题，还帮我检查了代码中的错误。所以在博客的最后，特此感谢学姐的无私帮助。</p>
</li>
<li><p>在了解了我们的学习进度之后，王晔老师放宽了ddl，并且在视频中加入了很多在写爬虫时候的细节。并且也解答了我一部分问题，特此感谢。</p>
</li>
<li><p>前人栽树后人乘凉。感谢我的好朋友们，是你们在一些问题上的经验帮我规避了很多难题；感谢一些同学们写的博客，是看了你们的博客之后我才有了这篇博客的思路于灵感。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/04/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="下面是问题"><a href="#下面是问题" class="headerlink" title="下面是问题"></a>下面是问题</h1><p><img src="/2020/04/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/1.png" alt="示例"></p>
<p> 讲人话，就是这个意思</p>
<p><img src="/2020/04/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2.png" alt="示例"></p>
<p>所以他的子问题如下 </p>
<table>
<thead>
<tr>
<th>子问题</th>
<th>条件</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>i=0或w=0</td>
</tr>
<tr>
<td>c[i][w]= c[i-1][w]</td>
<td>wi&gt;w</td>
</tr>
<tr>
<td>max{c[i-1][w-wi]+v,c[i-1][w]}</td>
<td>wi&lt;=w</td>
</tr>
</tbody></table>
<p>PS:0/1背包问题和普通背包的差别就在于(1)物品是否可以重复选择, (2)物品是否可以只选取部分</p>
<p>现在就可用动态规划的方法运用上面的公式来填表求解了.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里把值和重量分开存储了</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; weight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DP;</span><br><span class="line">    <span class="keyword">int</span> Number,maxSize;</span><br><span class="line">    <span class="comment">//Nis the number of items ,V is your capacity</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">cin</span> &gt;&gt; Number &gt;&gt; maxSize )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Number&lt;<span class="number">0</span>&amp;&amp;maxSize&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        value.resize(Number+<span class="number">1</span>);</span><br><span class="line">        weight.resize(maxSize+<span class="number">1</span>);</span><br><span class="line">        DP.<span class="built_in">clear</span>();</span><br><span class="line">        DP.resize(maxSize+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Number; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= maxSize; v++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Number; i++ )<span class="comment">//row</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= maxSize; v++ )<span class="comment">//column</span></span><br><span class="line">            &#123;</span><br><span class="line"><span class="comment">//这里的设计很巧妙，因为现在DP数组都是上一层的值，如果有需要改动的地方，就改动，否则保持原样</span></span><br><span class="line">				<span class="comment">//第1层的dp初始化都是0</span></span><br><span class="line">                <span class="keyword">if</span> ( v &gt;= weight[i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( DP[v-weight[i]] + value[i] &gt;= DP[v] )</span><br><span class="line">                    &#123;</span><br><span class="line">                        DP[v] = DP[v-weight[i]] + value[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%3d"</span>,DP[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; DP[maxSize] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="/2020/04/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/3.png" alt="示例"></p>
<p><img src="/2020/04/27/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/4.png" alt="示例"></p>
]]></content>
      <tags>
        <tag>discrete mathematics</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2020/05/07/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>设待排序的记录存储在数组r[1…n]中，首先从r[1…n]中选择一个关键词最小的记录r[k],r[k]和r[1]交换</li>
<li>第二趟排序，从r[2…n]中选择一个关键词最小的记录r[k],r[k]与r[2]交换</li>
<li>重复上述过程，经过n-1趟排序，得到有序序列</li>
</ol>
<p>冒泡排序是两两交换，但选择排序是找到最小的和当前序列第一个元素交换</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><table>
<thead>
<tr>
<th>原数组</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>2</td>
<td>16</td>
<td>30</td>
<td>28</td>
<td>20</td>
<td>16*</td>
<td>6</td>
<td>10</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第一次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>12</td>
<td>16</td>
<td>30</td>
<td>28</td>
<td>20</td>
<td>16*</td>
<td>6</td>
<td>10</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第二次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>16</td>
<td>30</td>
<td>28</td>
<td>20</td>
<td>16*</td>
<td>12</td>
<td>10</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第三次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>10</td>
<td>30</td>
<td>28</td>
<td>20</td>
<td>16*</td>
<td>12</td>
<td>16</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第四次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>28</td>
<td>20</td>
<td>16*</td>
<td>30</td>
<td>16</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第五次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>16*</td>
<td>20</td>
<td>28</td>
<td>30</td>
<td>16</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第六次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>16*</td>
<td>16</td>
<td>28</td>
<td>30</td>
<td>20</td>
<td>18</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第七次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>16*</td>
<td>16</td>
<td>18</td>
<td>30</td>
<td>20</td>
<td>28</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第八次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>16*</td>
<td>16</td>
<td>18</td>
<td>20</td>
<td>30</td>
<td>28</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第九次</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>16*</td>
<td>16</td>
<td>18</td>
<td>20</td>
<td>28</td>
<td>30</td>
</tr>
</tbody></table>
<ul>
<li><p>16和16*的顺序交换了，说明这个不是稳定的排序方式</p>
</li>
<li><p>这里加一段来自算法可视化网站<a href="https://visualgo.net/zh" target="_blank" rel="noopener">https://visualgo.net/zh</a> 的gif，帮助理解</p>
</li>
</ul>
<p><img src="/2020/05/07/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/1.gif" alt="示例"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SimpleselectSort</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i ,j,k,temp;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		k=i;</span><br><span class="line">		<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(r[j]&lt;r[k])</span><br><span class="line">				k=j;	<span class="comment">//记录最小值的下标</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			temp=r[i];</span><br><span class="line">			r[i]=r[k];</span><br><span class="line">			r[k]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>简单的选择排序需要n-1次排序，每次排序n-i次比较，总的比较次数为$\frac{n(n-1)}{2}$</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>简单选择排序在交换时使用了一个辅助空间temp ，空间复杂度为 $O(1)$</p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>从上面的实例可以看出，16和16*的顺序交换了，说明这个不是稳定的排序方式</p>
<h3 id="源码一览"><a href="#源码一览" class="headerlink" title="源码一览"></a>源码一览</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="keyword">int</span> A[Maxsize];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SimpleselectSort</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,j,k,temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[j]&lt;r[k])</span><br><span class="line">                k=j;	<span class="comment">//记录最小值的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=r[i];</span><br><span class="line">            r[i]=r[k];</span><br><span class="line">            r[k]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"次简单选择排序的结果:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;A[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入数列中的元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入数列中的元素"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleselectSort(A,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/07/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/0.png" alt="示例"></p>
<p><img src="/2020/05/07/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/1.png" alt="示例"></p>
]]></content>
      <tags>
        <tag>Data_structure</tag>
        <tag>Rank</tag>
      </tags>
  </entry>
  <entry>
    <title>链式前项星的概念与应用</title>
    <url>/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h1><p><img src="/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/1.png" alt="示例"></p>
<p><img src="/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/2.png" alt="示例"></p>
<p><img src="/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/3.png" alt="示例"></p>
<p><img src="/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/4.png" alt="示例"></p>
<ul>
<li>链式前向星在存储图时十分有用，特别是当边有权值时。我们用过一道题目了来具体分析一下</li>
</ul>
<p><img src="/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/UVA1599%E9%A2%98%E7%9B%AE.png" alt="示例"></p>
<p>链式前向星只是一种应用，是一种小技巧。所以我们先要构造一个链式前向星来存储数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,cnt;<span class="comment">//全局变量默认为0</span></span><br><span class="line"><span class="keyword">int</span> head[N],dis[N];</span><br><span class="line"><span class="comment">//head数组就是存储头节点的数组，head[i]就是存储以i为起点的第一条边的下标</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//链式前向星的三个空间：to代表这条边连接的另一个方向（因为一个方向就是头节点）</span></span><br><span class="line">    <span class="comment">//c代表权值，在这里就是指颜色</span></span><br><span class="line">    <span class="comment">//next存储的是下一条边的编号，如果没有下一条了，那么就是-1</span></span><br><span class="line">    <span class="keyword">int</span> to,c,next;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这个add函数就是实现头插</span></span><br><span class="line">    <span class="comment">//cnt代表边序号</span></span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].c = c;</span><br><span class="line">    <span class="comment">//这一步，其实就是指向这个头结点指向的第一条边</span></span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    <span class="comment">//然后更新头结点的第一条边，让头结点的第一条边为这条边</span></span><br><span class="line">   <span class="comment">//cnt++就是这条边的序号</span></span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u,v,c;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)<span class="comment">//输入n也就是最后要达到的目标，m也就是下面数据的组数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里，因为我们要存储的是无向图，所以对于每一组数据，都要存储两条边</span></span><br><span class="line">        <span class="comment">//一条从头指向尾，一条反指</span></span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;c;</span><br><span class="line">        add(u,v,c);</span><br><span class="line">        add(v,u,c);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     bfs1();</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;dis[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     bfs2();</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构建好，并存储好后，开始bfs</li>
</ul>
<p><img src="/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/UVA1599%E9%A2%98%E8%A7%A32.png" alt="示例"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关于为什么要逆向标高</span></span><br><span class="line"><span class="comment">//逆向标高是从目标反向遍历，比如我们要从1找到4，那么从4开始反向便利</span></span><br><span class="line"><span class="comment">//这样，4 的深度为0，1的深度为2，那么1-&gt;4 的深度是2</span></span><br><span class="line"><span class="comment">//因为要输出至少经过k条边，那么深度就是边的条数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs1</span><span class="params">()</span><span class="comment">//逆向标高</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="comment">//首先把所有的节点的访问值标为0，在接下来的访问中，凡是访问到，标为1</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="comment">//首先把目标的深度标为0</span></span><br><span class="line">    dis[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队列q1是保存节点号的</span></span><br><span class="line">    q1.push(n);</span><br><span class="line">    <span class="comment">//然后把n设为已经访问</span></span><br><span class="line">    vis[n]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//第一次深度搜索</span></span><br><span class="line">    <span class="keyword">while</span>(!q1.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次u设为队列的头节点，</span></span><br><span class="line">        u = q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        <span class="comment">//把u设为已经访问</span></span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//把头节点出队以后，将这个头结点所有的边连接着的节点入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = head[u];i;i=e[i].next)</span><br><span class="line">        <span class="comment">//因为存储的时候是从1开始的，所以结束条件是i！=0</span></span><br><span class="line">        &#123;            </span><br><span class="line">            v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(vis[v])<span class="comment">//如果v已经被访问过了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//把下一个结点的深度标为出队节点+1</span></span><br><span class="line">            dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//然后把新节点入队</span></span><br><span class="line">            q1.push(v);</span><br><span class="line">            <span class="comment">//把新节点标记为访问</span></span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反向遍历之后，我们需要从1开始正向遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,minc,c;</span><br><span class="line">    <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//刚才vis数组已经有改了，现在是正向遍历，所以要重置</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//从1开始bfs，把1所有连接的节点，而且节点是满足”1的深度“-1的，入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[<span class="number">1</span>];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span>(dis[e[i].to]==dis[<span class="number">1</span>]<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里，入队不仅仅是把节点号入队，也要把颜色入队</span></span><br><span class="line">            q1.push(e[i].to);</span><br><span class="line">            q2.push(e[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q1.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把最小的颜色号初始化为最大值</span></span><br><span class="line">        minc = inf;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//和bfs1一样，先出队，然后把符合条件的全部入队</span></span><br><span class="line">            <span class="comment">//q1，q2同时入队，同时出队，能保证他们之间是一一对应的</span></span><br><span class="line">            v= q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            c= q2.front();</span><br><span class="line">            q2.pop();</span><br><span class="line">            <span class="comment">//q3 用来保存色号最小的关联的临节点号</span></span><br><span class="line">            <span class="comment">//如果发现有比q3中存储的更小的色号，那么直接把q3清空</span></span><br><span class="line">            <span class="comment">//再把现有的色号存储进进q3</span></span><br><span class="line">            <span class="keyword">if</span>(c&lt;minc)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q3.empty())</span><br><span class="line">                    q3.pop();</span><br><span class="line">                minc = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c==minc)</span><br><span class="line">                q3.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first)</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="comment">//这样，每一次输出的都是当前深度下，最小的色号</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;minc;</span><br><span class="line">        <span class="comment">//接下俩这一步就是通过当前q3中存储的这些节点出发，寻找下一层、</span></span><br><span class="line">        <span class="comment">//并且把下一层的节点和色号都入队</span></span><br><span class="line">        <span class="comment">//且能达到清空q3的作用，为下一次循环做准备</span></span><br><span class="line">        <span class="keyword">while</span>(!q3.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            u = q3.front();</span><br><span class="line">            q3.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[u])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[u]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            &#123;</span><br><span class="line">                v=e[i].to;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]==dis[u]<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q1.push(v);</span><br><span class="line">                    q2.push(e[i].c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>小技巧</tag>
        <tag>bfs</tag>
        <tag>Data_structure</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学多元微积分总结</title>
    <url>/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="高等数学多元微积分总结"><a href="#高等数学多元微积分总结" class="headerlink" title="高等数学多元微积分总结"></a>高等数学多元微积分总结</h1><h3 id="（偏）导数，连续函数，全微分之间的关系"><a href="#（偏）导数，连续函数，全微分之间的关系" class="headerlink" title="（偏）导数，连续函数，全微分之间的关系"></a>（偏）导数，连续函数，全微分之间的关系</h3><p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/1.png" alt="示例"></p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><h5 id="函数的连续证明："><a href="#函数的连续证明：" class="headerlink" title="函数的连续证明："></a>函数的连续证明：</h5><ol>
<li>$f(x)在x_0处有定义$</li>
<li>极限$\lim\limits_{x\rightarrow x_0}f(x)$存在</li>
<li>$\lim\limits_{x\rightarrow x_0}f(x)=f(x_0)$</li>
</ol>
<p>三个条件都满足的时候，说明函数连续</p>
<p>偏导数连续是什么意思？</p>
<p>先用定义求出该点的偏导数值c,再用求导公式求出不在该点时的偏导数$f_x(x,y)$,最后求$f_x(x,y)$当(x,y)趋于$(x_0,y_0)$点时的极限,如果$\lim\limits_{x,y\rightarrow x_0,y_0}(x,y)=c$,即偏导数连续,否则不连续.</p>
<h5 id="偏-导数存在的证明"><a href="#偏-导数存在的证明" class="headerlink" title="(偏)导数存在的证明"></a>(偏)导数存在的证明</h5><p>初等函数都是可导的，导数在$x_0$处的定义如下</p>
<p>$f^{‘}(x_0)=\frac{\lim\limits_{Δx→0}f(x_0+Δx)−f(x_0)}{Δx}$</p>
<p>那么以此类推，偏导数的定义就可以给出了</p>
<ul>
<li><p>在$(x_0,y_0)$这个点的偏导数定义</p>
<p>$f_x(x_0,y_0)=\frac{\lim\limits_{Δx→0}f(x_0+Δx,y_0)−f(x_0,y_0)}{Δx}$</p>
</li>
</ul>
<p>如果上面的式子存在，那么说明关于x的偏导数存在。否则就不存在</p>
<p><strong>偏导数存在并不能证明函数可微分，和函数可导一样</strong></p>
<h5 id="函数可微的判断"><a href="#函数可微的判断" class="headerlink" title="函数可微的判断"></a>函数可微的判断</h5><p>$ρ=\sqrt{Δx^2+Δy^2}$</p>
<p>判断 $Δz−AΔx−BΔy=o(ρ)$</p>
<p>即$\lim\limits_{Δx→0,Δy→0}\frac{f(x+Δx,y+Δy)−f(x,y)−\frac{∂z}{∂x}Δx−\frac{∂z}{∂y}Δy}ρ=0$</p>
<ul>
<li>当函数可微，全微分自然存在</li>
</ul>
<p>$dz=AΔx+BΔy+o(ρ)$</p>
<p>如果可微，则$A=\frac{∂z}{∂x}$,$B=\frac{∂z}{∂y}$</p>
<h3 id="多元复合函数求导的注意点"><a href="#多元复合函数求导的注意点" class="headerlink" title="多元复合函数求导的注意点"></a>多元复合函数求导的注意点</h3><ul>
<li>当出现二阶甚至高阶偏导数的时候，我们会感到异常头疼 ，时常漏乘或者漏考虑一些状况，对此我有两点要说</li>
<li>一：在求二阶偏导数时，先求一次导数项，再求二次导数项</li>
<li>二:  再求二阶偏导数的时候，原来的系数放左边，导数符号放中间，新导出的系数放右边</li>
</ul>
<p>求偏导结束的时候，我们还可以自己做一遍检查，主要检查有没有一次导函数，两次导函数($f_{11},f_{22},f_{12}$)等等，$f_{12}$前后保持一致，所以是双倍。</p>
<ul>
<li>多元复合函数常常会考一些证明题</li>
<li><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/2.png" alt="示例"></li>
<li>证明题不难，只要把能化开的全部展开，再合并同类项就行，但是要细，要慢</li>
</ul>
<h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><h4 id="当目标函数为F-x-y-z-0时"><a href="#当目标函数为F-x-y-z-0时" class="headerlink" title="当目标函数为F(x,y,z)=0时"></a>当目标函数为F(x,y,z)=0时</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>$\frac{∂y}{∂x}=−\frac{F_x}{F_y}$</p>
<p>以此类推</p>
<p>在做题的时候不要囫囵吞枣，要细嚼慢咽</p>
<ul>
<li>先求出Fx,Fy</li>
<li>再写上当Fy 不为0 的时候，成立，这样更严谨</li>
<li>最后根据公式计算</li>
</ul>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>对两边求全微分,对dz,dx,dy全部求偏导</p>
<p>获得 $Adz=Bdx+Cdy$</p>
<p>那么 $\frac{dz}{dx} = \frac{B}{A},\frac{dz}{dy} = \frac{C}{A}$</p>
<ul>
<li>注意，在求隐函数二阶偏导的时候，比较复杂。下面是一个例子</li>
</ul>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/3.png" alt="示例"></p>
<p>我们看到在虽然表面上没有x，但是z包含了x，所以对z求导以后还要乘上偏导$\frac{dz}{dx}$并展开</p>
<h4 id="当目标函数为方程组，但不是隐函数时"><a href="#当目标函数为方程组，但不是隐函数时" class="headerlink" title="当目标函数为方程组，但不是隐函数时"></a>当目标函数为方程组，但不是隐函数时</h4><ul>
<li>利用线性代数中的克莱默法则求解</li>
<li>克莱默法则，就是把x1，x2….放在左边，常数项放到右边</li>
<li>先求出D，D就是左边未知数的系数组成的行列式。当D=0的时候，只有唯一解，D不等于0的时候，有多解</li>
<li>一次求出D1，D2…D1行列式就是x1的系数替换成右边的常数，以此类推</li>
<li>最后 $x_1=\frac{D1}{D},x_2=\frac{D2}{D}…..$</li>
</ul>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/4.png" alt="示例"></p>
<p>我们可以拿第一个方程组为例</p>
<ol>
<li>因为要求$\frac{dy}{dx},\frac{dz}{dx}$所以我们知道要两边关于x求导才能出这两个未知数</li>
<li>然后整理过后得到了<img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/5.png" alt="示例"></li>
<li>求出它的系数行列式，也就是$$\begin{bmatrix} 2y&amp;-1 \ 2y&amp;3z \end{bmatrix}$$</li>
<li>依次求出D1,D2，对应$\frac{dy}{dx},\frac{dz}{dx}$</li>
<li>D1= $$\begin{bmatrix} -2x&amp;-1 \ -x&amp;3z \end{bmatrix}$$ D2 = $$\begin{bmatrix} 2y&amp;-2x \ 2y&amp;-x \end{bmatrix}$$</li>
<li>相除即得我们要的结果</li>
</ol>
<ul>
<li>请读者自证第二小题</li>
</ul>
<h4 id="当目标函数为-D-left-begin-aligned-F-x-y-u-v-0-G-x-y-u-v-0-end-aligned-right-时"><a href="#当目标函数为-D-left-begin-aligned-F-x-y-u-v-0-G-x-y-u-v-0-end-aligned-right-时" class="headerlink" title="当目标函数为$$ D:\left{ \begin{aligned} F(x,y,u,v)=0 \G(x,y,u,v)=0 \end{aligned} \right. $$ 时"></a>当目标函数为$$ D:\left{ \begin{aligned} F(x,y,u,v)=0 \G(x,y,u,v)=0 \end{aligned} \right. $$ 时</h4><ul>
<li><p>利用两边对x求导，像上面那种方法做</p>
</li>
<li><p>利用雅可比行列式，本质上还是克莱默行列式的变形</p>
<ul>
<li>首先求出行列式  J  <img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/9.png" alt="示例"></li>
<li>其次开始替换，要求$\frac{du}{dx}$ 那么把u的位置替换成x求行列式的值，要求$\frac{du}{dy}$ 那么就把u的位置换成y，然后乘以 -1 / J</li>
<li>如图 <img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/10.png" alt="示例"></li>
<li>此外，对于$\frac{dv}{dx},\frac{dv}{dy}$也是一样的道理</li>
<li>所以为了方便起见，我们需要先对方程组$$ D:\left{ \begin{aligned} F(x,y,u,v)=0 \G(x,y,u,v)=0 \end{aligned} \right. $$ 做一个拆分，分别求出$F_x,F_y,F_u,F_v,G_x,G_y,G_u,G_v$排列整齐就可以一目了然</li>
</ul>
</li>
</ul>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/6.png" alt="示例"></p>
<p>拿第一个方程组举例</p>
<ol>
<li>此方程组可以确定两个二元隐函数 u= u( x , y );v=v( x , y )</li>
<li>要求$\frac{du}{dx},\frac{dv}{dx}$ 所以我们先要对两端关于x求偏导数</li>
<li>整理得到<img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/7.png" alt="示例"></li>
<li>解除D,D1,D2 那么就解出了最后的答案</li>
</ol>
<p>拿第二个方程组举例</p>
<ol>
<li>当然，这一题也可以向上面那样，两边先对x求导，根据D，D1，D2求解，但是比较繁琐。所以这里用雅可比行列式</li>
<li>首先把它们列成$$ D:\left{ \begin{aligned} F(x,y,u,v)=0 \G(x,y,u,v)=0 \end{aligned} \right. $$的形式<img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/8.png" alt="示例"></li>
<li>然后，我们要求出<img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/11.png" alt="示例"></li>
<li>最后根据题目需求，求出J和一堆行列式<img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/12.png" alt="示例"></li>
</ol>
<h3 id="多元函数的几何应用"><a href="#多元函数的几何应用" class="headerlink" title="多元函数的几何应用"></a>多元函数的几何应用</h3><h4 id="一元向量值函数及其导数"><a href="#一元向量值函数及其导数" class="headerlink" title="一元向量值函数及其导数"></a>一元向量值函数及其导数</h4><p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/23.png" alt="示例"></p>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/24.png" alt="示例"></p>
<h4 id="空间间曲线的切线与法平面"><a href="#空间间曲线的切线与法平面" class="headerlink" title="空间间曲线的切线与法平面"></a>空间间曲线的切线与法平面</h4><h5 id="当曲线为向量形式-Gamma-x-varphi-t-y-psi-t-z-omega-t-t-in-a-b-的时候"><a href="#当曲线为向量形式-Gamma-x-varphi-t-y-psi-t-z-omega-t-t-in-a-b-的时候" class="headerlink" title="当曲线为向量形式$\Gamma: x = \varphi(t) ,y = \psi(t),z=\omega(t),t\in [a,b]$的时候"></a>当曲线为向量形式$\Gamma: x = \varphi(t) ,y = \psi(t),z=\omega(t),t\in [a,b]$的时候</h5><p>根据一元向量值函数的结论，我们知道切向量就是在该点的导数</p>
<p>$\vec{f^{‘}(t)} = (\varphi^{‘}(t),\psi^{‘}(t),\omega^{‘}(t))$</p>
<p>又因为法平面的法向量和该点的切向量平行，那么我们就知道了两者形态是一样的</p>
<p>利用点向量式建立切线方程，利用点法式建立曲线的法平面方程如下</p>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/14.png" alt="示例"></p>
<p>*<em>那么如果是光滑曲线 *</em>$\Gamma: y = \psi(x),z=\omega(x)$呢？</p>
<p>我们把曲线看成 $\Gamma:x=x,y = \psi(x),z=\omega(x)$</p>
<p>然后按照上面的方法可得</p>
<p>$\vec{f^{‘}(t)} = (1,\psi^{‘}(x),\omega^{‘}(x))$ </p>
<p>那么出现$y^2 = 2mx,z^2 = m-x $在点$(x_0,y_0,z_0)$处的切线及法平面方程这种题目怎么解决呢？用全微分的方法来做。</p>
<p>$\vec{T} = (1,\frac{dy}{dx}|_M,\frac{dz}{dx}|_M)$ </p>
<h5 id="当曲线为一般形式的时候-Gamma-left-begin-aligned-F-x-y-z-0-G-x-y-z-0-end-aligned-right-的时候"><a href="#当曲线为一般形式的时候-Gamma-left-begin-aligned-F-x-y-z-0-G-x-y-z-0-end-aligned-right-的时候" class="headerlink" title="当曲线为一般形式的时候$$ \Gamma:\left{ \begin{aligned} F(x,y,z)=0 \G(x,y,z)=0 \end{aligned} \right. $$的时候"></a>当曲线为一般形式的时候$$ \Gamma:\left{ \begin{aligned} F(x,y,z)=0 \G(x,y,z)=0 \end{aligned} \right. $$的时候</h5><p>在点$M(x_0,y_0,z_0)$处的切向量为，记住后面那个</p>
<p> $\vec T= J(1,\frac{1}{J}\frac{∂(F,G)}{∂(z,x)}∣_M,\frac{1}{J}\frac{∂(F,G)}{∂(x,y)}∣_M)=(\frac{∂(F,G)}{∂(y,z)}|_M,\frac{∂(F,G)}{∂(z,x)}∣_M,\frac{∂(F,G)}{∂(x,y)}|_M)$</p>
<p>这是记忆方法，如果求x处的坐标，那么就转两位 <img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/18.png" alt="示例"></p>
<p>所以根据切向量，可以得到斜线方程和法平面方程</p>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/17.png" alt="示例"></p>
<p><strong>两者可以用全微分的方法来做，也可以得到切向量</strong></p>
<p>具体的做法，和隐函数求导一样，两边对x求导，然后根据D，D1，D2解出$\frac{dy}{dx},\frac{dz}{dx}$ 切向量$\vec{T} = (1,\frac{dy}{dx}|_M,\frac{dz}{dx}|_M)$ </p>
<h4 id="曲面的切平面与法线"><a href="#曲面的切平面与法线" class="headerlink" title="曲面的切平面与法线"></a>曲面的切平面与法线</h4><p>曲面$\Sigma$在点M在的法向量，就是法线的线向量和切平面的法向量</p>
<p>求x处法向量，就是曲面$\Sigma$对x的偏导，以此类推</p>
<p>$\vec n = (F_x(x_0,y_0,z_0),F_y(x_0,y_0,z_0),F_z(x_0,y_0,z_0))$</p>
<p>于是可以求出法线方程和切平面方程</p>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/21.png" alt="示例"></p>
<h4 id="几何问题中的几类题"><a href="#几何问题中的几类题" class="headerlink" title="几何问题中的几类题"></a>几何问题中的几类题</h4><ul>
<li>归根到底就是1.找出法向量 2.找向量之间的关系</li>
</ul>
<ol>
<li>告诉你曲线方程，让你求某点的切线和法平面<ol>
<li>$\vec{f^{‘}(t)} = (\varphi^{‘}(t),\psi^{‘}(t),\omega^{‘}(t))$或者$\vec{T} = (1,\frac{dy}{dx}|_M,\frac{dz}{dx}|_M)$ </li>
</ol>
</li>
<li>告诉你曲面方程，让你求某点的切平面和法线<ol>
<li>$\vec n = (F_x(x_0,y_0,z_0),F_y(x_0,y_0,z_0),F_z(x_0,y_0,z_0))$</li>
</ol>
</li>
<li>告诉你曲面方程，让你求某点的切平面与某个面的夹角的余弦值<ol>
<li>找到曲面在该点的法向量</li>
<li>找到某个面的法向量</li>
<li>求这两个法向量的余弦值，就是我们所要的余弦值</li>
</ol>
</li>
<li>让你求一条曲线上平行于某平面的切线，求出该点和该线<ol>
<li>找到曲线一般的切向量</li>
<li>通过该向量*某平面的法向量 = 0 构造方程</li>
<li>解出该方程或者拿到变量之间的关系，回代曲线方程求解</li>
</ol>
</li>
<li>让你求一条曲线上平行于某平面的法平面，求出该点和该面<ol>
<li>找到曲线的一般切向量，也就是该点出法平面的法向量</li>
<li>该切向量和目标平面的法向量平行，得到一个方程</li>
<li>解方程或者回代</li>
</ol>
</li>
<li>让你求一个曲面上平行于某平面的切平面，求出该点和该面<ol>
<li>找到曲面的一般法向量，那么这个就是切平面的法向量</li>
<li>该法向量与目标平面的法向量平行，得到方程</li>
<li>解方程或者回代</li>
</ol>
</li>
<li>让你求一个曲面上平行于某平面的法线，求出该点和该面<ol>
<li>找到曲面的一般法向量，那么这个就是切线的向量</li>
<li>该向量与目标平面的法向量垂直，得到方程</li>
<li>解方程或者回代</li>
</ol>
</li>
<li>或者和某直线平行或者垂直，归根到底就是找向量之间的关系</li>
</ol>
<h3 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h3><h4 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h4><ul>
<li>对于三元函数，如果在点P(x,y,z)处可微，则函数在该店沿任意方向l的方向导数都存在</li>
<li>$\frac{∂f}{∂l}=\frac{∂f}{∂x}\cos\alpha+\frac{∂f}{∂y}\cos\beta+\frac{∂f}{∂z}\cos\gamma$</li>
<li>对于二元函数，在点P(x,y)处沿方向l 的方向导数是</li>
<li>$\frac{∂f}{∂l}=\frac{∂f}{∂x}\cos\alpha+\frac{∂f}{∂y}\cos\beta$</li>
<li>特别的：当l与x轴同向有 $\frac{∂f}{∂l}=\frac{∂f}{∂x}$ </li>
<li>当l与x轴反向向有 $\frac{∂f}{∂l}=-\frac{∂f}{∂x}$ </li>
<li>外法线是正的，内法线为负</li>
</ul>
<h5 id="题形"><a href="#题形" class="headerlink" title="题形"></a>题形</h5><ul>
<li>给你一个函数，让你求在某点沿着一个向量的方向导数<ul>
<li>先计算 向量的方向余弦</li>
<li>把方向余弦分别乘以函数对x,y,z的偏导数</li>
<li>把P点带入后相加</li>
</ul>
</li>
<li>给你一个函数，让你求在某点沿着某一条曲线朝着某个方向增大的方向导数<ul>
<li>先计算某条曲线在该点处的方向向量</li>
<li>计算该方向向量的方向余弦</li>
<li>方向余弦与偏导对应相乘</li>
<li>把P点带入后相加</li>
</ul>
</li>
<li>总之，计算方向导数的题目，我们要找到三个信息<ul>
<li><ol>
<li>就是方向向量，依次求出方向余弦</li>
<li>找到目标函数，对变量求偏导</li>
<li>找到该点，带入</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/26.png" alt="示例"></p>
<p>那么，向量$\vec G$被称为函数 f(P)在P处的梯度，记作grad f(P)  </p>
<p>$gradf(P) = \nabla f(P) = (f_x(P),f_y(P),f_z(P))$</p>
<p>当函数为二元函数f(x,y)在 P（x,y) 处的梯度</p>
<p>$grad f(P) = \nabla f(P) = (f_x(P),f_y(P))$</p>
<h5 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h5><p>函数在同一点的梯度垂直于该点的等值线，指向函数增大的方向</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>方向： f变化率最快的方向</li>
<li>模： f的最大变化率的值</li>
</ol>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p>所以，函数的方向导数为梯度在该方向上的投影：</p>
<p>$\frac{∂f}{∂l} = grad f\cdot\vec {e_l}$</p>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/28.png" alt="示例"></p>
<h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/27.png" alt="示例"></p>
<h5 id="题形-1"><a href="#题形-1" class="headerlink" title="题形"></a>题形</h5><ul>
<li>给你一个函数，要你求出在某点沿增加最快方向的方向导数<ul>
<li>最快方向就是该点的梯度向量</li>
<li>此时方向导数就是该向量的模</li>
<li>特别要注意的是，要你求梯度，求的是一个向量而不是一个模</li>
</ul>
</li>
<li>值得注意的是，变化最快包含了增加最快和减少最快，但是我们常常忽略负的那个</li>
</ul>
<h4 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h4><h3 id="多元函数的极值"><a href="#多元函数的极值" class="headerlink" title="多元函数的极值"></a>多元函数的极值</h3><h4 id="多元函数的极值-1"><a href="#多元函数的极值-1" class="headerlink" title="多元函数的极值"></a>多元函数的极值</h4><ul>
<li>必要条件： 函数 z = f(x,y) 在点$(x_0,y_0)$存在偏导数，且在该点取极值那么我们一定可以得到 $f^{‘}_x(x_0,y_0)= 0,f^{‘}_y(x_0,y_0)= 0$<ul>
<li>需要注意的是， 让偏导数都为0的点被称为驻点，但是驻点不一定是极值点</li>
<li>如 z = xy 有驻点（0，0）但是（0，0) 不是一个极值点</li>
</ul>
</li>
<li>充分条件: 如果函数z =f(x,y)在点$(x_0,y_0)$的某个邻域内具有一阶和二阶连续偏导数，且$f^{‘}<em>x(x_0,y_0)= 0,f^{‘}_y(x_0,y_0)= 0$ 那么，我们再进一步令$A = f</em>{xx}(x_0,y_0),B = f_{xy}(x_0,y_0),C = f_{yy}(x_0,y_0)$<ul>
<li>当 $AC-B^2&gt;0$时，具有极值$$ D:\left{ \begin{aligned} A&lt;0  时取极大值 \A&gt;0  时取极小值 \end{aligned} \right. $$</li>
<li>当$AC-B^2&lt;0$时，没有极值</li>
<li>当$AC-B^2=0$时，不能确定，需要另行讨论</li>
</ul>
</li>
</ul>
<h5 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h5><ul>
<li>这类考察基本概念和定义</li>
</ul>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/29.png" alt="示例"></p>
<ul>
<li>求函数 f(x,y)的极值<ul>
<li>先求出驻点</li>
<li>求出二阶偏导数</li>
<li>判断驻点是否符合极值点条件</li>
</ul>
</li>
</ul>
<h4 id="最值应用问题"><a href="#最值应用问题" class="headerlink" title="最值应用问题"></a>最值应用问题</h4><h4 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h4><ul>
<li>对自变量除了定义域的限制之外，还有其它条件的限制</li>
</ul>
<h5 id="方法1：代入法"><a href="#方法1：代入法" class="headerlink" title="方法1：代入法"></a>方法1：代入法</h5><p>在条件$\varphi(x,y) = 0$下，求出z = f(x,y)的极值 </p>
<ul>
<li>先从条件$\varphi(x,y) = 0$中解处 $y = \psi(x)$</li>
<li>带入函数z = f(x,y)当中</li>
<li>解决一元函数 $z = f(x,\psi(x))$的无条件极值问题</li>
</ul>
<h5 id="方法2-拉格朗日乘数法"><a href="#方法2-拉格朗日乘数法" class="headerlink" title="方法2 : 拉格朗日乘数法"></a>方法2 : 拉格朗日乘数法</h5><p>在条件$\varphi(x,y) = 0$下，求出z = f(x,y)的极值 </p>
<p><img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/31.png" alt="示例"></p>
<p>所以极值点必然满足$$ D:\left{ \begin{aligned} f_x+\lambda\varphi_x=0 \f_y+\lambda\varphi_y=0 \\varphi (x,y)= 0 \end{aligned} \right. $$</p>
<p>引入辅助函数 $F = f(x,y)+\lambda\varphi(x,y)$</p>
<p>那么极值点满足 $$ \left{ \begin{aligned} F_x = f_x+\lambda\varphi_x=0 \ F_y=f_y+\lambda\varphi_y=0 \F_\lambda=\varphi (x,y)= 0 \end{aligned} \right. $$</p>
<p>可以看见下面的关系式就是上面的关系式，于是，辅助函数F的极值点就是 z = f(x,y)的极值点，辅助函数被称为拉格朗日函数。</p>
<p>然后。根据这几个方程找出可疑的极值点，再加以验证</p>
<ul>
<li>推广：<img src="/2020/05/05/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86%E6%80%BB%E7%BB%93/30.png" alt="示例"></li>
</ul>
]]></content>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学重积分</title>
    <url>/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="重积分"><a href="#重积分" class="headerlink" title="重积分"></a>重积分</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>终于等到这一天了，想到几天之后就要quiz的我头皮发麻</li>
<li>本来的笔记再oneNote上，但都是图片之类的。。煞是难看</li>
<li>只保存一些图片根本起不到学习的效果</li>
<li>算了，还是手敲公式⑧</li>
<li>五一结束希望能够写完，只写最重要的公式和例子，废话少说</li>
</ul>
<h3 id="二重积分的计算"><a href="#二重积分的计算" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h3><h4 id="利用直角坐标计算二重积分"><a href="#利用直角坐标计算二重积分" class="headerlink" title="利用直角坐标计算二重积分"></a>利用直角坐标计算二重积分</h4><h5 id="当被积函数-f-x-y-geq0-且在D上连续时，若D为X型区域"><a href="#当被积函数-f-x-y-geq0-且在D上连续时，若D为X型区域" class="headerlink" title="当被积函数$f(x,y)\geq0$且在D上连续时，若D为X型区域"></a><strong>当被积函数$f(x,y)\geq0$且在D上连续时，若D为X型区域</strong></h5><p>$$ D:\left{ \begin{aligned} \varphi_1(x)\leq y\leq \varphi_2(x)\a\leq x\leq b \end{aligned} \right. $$ </p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/1.png" alt="示例"></p>
<p>则</p>
<p> $\iint_D f(x,y)dxdy = \int_a^bdx \int_{\varphi_1(x)}^{\varphi_2(x)}f(x,y)dy$</p>
<h5 id="若D-为Y-形区域"><a href="#若D-为Y-形区域" class="headerlink" title="若D 为Y-形区域"></a><strong>若D 为Y-形区域</strong></h5><p>$$ D:\left{ \begin{aligned} \psi_1(x)\leq x\leq \psi_2(x)\c\leq y\leq d \end{aligned} \right. $$ </p>
<p>则</p>
<p> $\iint_D f(x,y)dxdy = \int_c^ddy \int_{\psi_1(x)}^{\psi_2(x)}f(x,y)dx$\</p>
<h4 id="利用极坐标计算二重积分"><a href="#利用极坐标计算二重积分" class="headerlink" title="利用极坐标计算二重积分"></a>利用极坐标计算二重积分</h4><p>用 $ x = cos\theta和y =\sin\theta$ 带入原方程 </p>
<p>$$ D:\left{ \begin{aligned} \varphi_1(\theta)\leq r\leq \varphi_2(\theta)\\alpha\leq \theta\leq \beta \end{aligned} \right. $$ </p>
<p>则</p>
<p> $\iint_D f(rcos\theta,rsin\theta)rdrd\theta = \int_\alpha^\beta d\theta \int_{\varphi_1(\theta)}^{\varphi_2(\theta)}f(rcos\theta,rsin\theta)rdr$</p>
<p>特别的，对D：$$ D:\left{ \begin{aligned} 0\leq r\leq \varphi(\theta)\0\leq \theta\leq 2\pi \end{aligned} \right. $$ </p>
<p>$\iint_D f(rcos\theta,rsin\theta)rdrd\theta = \int_0^{2\pi} d\theta \int_0^{\varphi(\theta)}f(rcos\theta,rsin\theta)rdr$</p>
<h4 id="交换积分次序"><a href="#交换积分次序" class="headerlink" title="交换积分次序"></a>交换积分次序</h4><ul>
<li>有些积分是超越函数，并没有对应的原函数 。这是交换机分次序显得额外重要！</li>
</ul>
<p>$\int_1^3dx\int_{x-1}^2 \sin y^2 dy$</p>
<h4 id="课本解答"><a href="#课本解答" class="headerlink" title="课本解答"></a>课本解答</h4><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/1.jpg" alt="示例"></p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/2.jpg" alt="示例"></p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/3.jpg" alt="示例"></p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/4.jpg" alt="示例"></p>
<h3 id="三重积分的计算"><a href="#三重积分的计算" class="headerlink" title="三重积分的计算"></a>三重积分的计算</h3><ul>
<li>先看看概念吧</li>
</ul>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/2.png" alt="示例"></p>
<h4 id="利用直角坐标计算三重积分"><a href="#利用直角坐标计算三重积分" class="headerlink" title="利用直角坐标计算三重积分"></a>利用直角坐标计算三重积分</h4><h5 id="投影法（“先1后2”）"><a href="#投影法（“先1后2”）" class="headerlink" title="投影法（“先1后2”）"></a>投影法（“先1后2”）</h5><p>$\Omega:\left{ \begin{aligned} z_1(x.y)\leq r\leq z_2(x,y)\0\leq \theta\leq 2\pi \end{aligned} \right.$</p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/3.png" alt="示例"></p>
<p>那么细长柱体微元的质量为</p>
<p>$(\int_{z_1(z,y)}^{z_2(x,y)}f(x,y,z)dz)dxdy$</p>
<p>该物体的质量就是：</p>
<p>$\iiint_\Omega f(x,y,z)dv = \iint_D(\int_{z_1(z,y)}^{z_2(x,y)}f(x,y,z)dz)dxdy$</p>
<p>就等于 </p>
<p>$\iint_Ddxdy\int_{z_1(z,y)}^{z_2(x,y)}f(x,y,z)dz$</p>
<h5 id="截面法（“先2后1”）"><a href="#截面法（“先2后1”）" class="headerlink" title="截面法（“先2后1”）"></a>截面法（“先2后1”）</h5><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/4.png" alt="示例"></p>
<p>$\Omega:\left{ \begin{aligned}(x,y)\in D_z\0\leq \theta\leq 2\pi \end{aligned} \right.$</p>
<p>以$D_z $为底，dz为高的柱形薄片的质量为</p>
<p>$(\iint_{D_z}f(x,y,z)dxdy)dz$</p>
<p>那么该物体的质量就是</p>
<p>$\int_a^b(\iint_{D_z}f(x,y,z)dxdy)dz = \int_a^bdz\iint_{D_z}f(x,y,z)dxdy$</p>
<h5 id="三次积分法"><a href="#三次积分法" class="headerlink" title="三次积分法"></a>三次积分法</h5><p>区域 $\Omega:\left{ \begin{aligned} z_1(x.y)\leq z\leq z_2(x,y)\D:\left{ \begin{aligned}y_1(x)\leq y \leq y_2(x)\a\leq x\leq b \end{aligned} \right. \end{aligned} \right.$</p>
<p>利用投影法结果，把二重积分转化成二次积分得</p>
<p>$\iiint_\Omega f(x,y,z)dv = \int_a^bdx\int_{y_1(x)}^{y_2(x)}dy\int_{z_1(x,y)}^{z_2(x,y)}f(x,y,z)dz$</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/5.png" alt="示例"></p>
<h4 id="利用柱坐标计算三重积分"><a href="#利用柱坐标计算三重积分" class="headerlink" title="利用柱坐标计算三重积分"></a>利用柱坐标计算三重积分</h4><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/6.png" alt="示例"></p>
<p>在柱面坐标系中得体积元素为</p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/7.png" alt="示例"></p>
<p>$dv = \rho d\rho d\theta dz $</p>
<p>因此 $\iiint_\Omega f(x,y,z)dxdydz =\iiint_\Omega F(\rho,\theta,z)\rho d\rho d\theta dz$</p>
<p><strong>$\theta$摆在前，r摆中间, z 摆最后面</strong></p>
<p>其中，$F(\rho,\theta,z)=f(\rho cos\theta ,\rho sin\theta,z)$</p>
<p>适用范围</p>
<ul>
<li>积分域表面用柱面坐标表示时方程简单</li>
<li>被积函数用柱面坐标表示时变量相互分离</li>
</ul>
<h4 id="利用球坐标计算三重积分"><a href="#利用球坐标计算三重积分" class="headerlink" title="利用球坐标计算三重积分"></a>利用球坐标计算三重积分</h4><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/8.png" alt="示例"></p>
<p>如图所示，在球面坐标系中的体积元素为<img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/9.png" class> </p>
<p>$dv = r^2 sin\varphi dr d\varphi d\theta$</p>
<p>因此有 $\iiint_\Omega f(x,y,z)dxdydz =\iiint_\Omega F(r,\rho,\varphi)r^2sin\varphi d\varphi d\theta dr$</p>
<p><strong>$\theta$摆在前，$\varphi$摆中间,r 摆最后面</strong></p>
<p>其中，$F(r,\theta,\varphi) = f(rsin\varphi cos\theta,rsin\varphi sin\theta,rcos\varphi)$</p>
<p>适用范围</p>
<ul>
<li>积分域表面用球面坐标表示时方程简单</li>
<li>被积函数用球面坐标表示时变量相互分离</li>
</ul>
<h3 id="重积分应用"><a href="#重积分应用" class="headerlink" title="重积分应用"></a>重积分应用</h3><ol>
<li>能运用重积分解决的实际问题的特点<ul>
<li>所求量分布在有界闭区域上的整体量</li>
<li>对区域具有可加性</li>
</ul>
</li>
<li>能用重积分解决问题的方法<ul>
<li>用微元分析法建立积分式</li>
</ul>
</li>
<li>解题要点<ul>
<li>画出积分域</li>
<li>选择坐标系</li>
<li>确定积分序</li>
<li>定出积分限</li>
<li>计算要简便</li>
</ul>
</li>
</ol>
<h4 id="立体体积"><a href="#立体体积" class="headerlink" title="立体体积"></a>立体体积</h4><h5 id="曲顶柱体"><a href="#曲顶柱体" class="headerlink" title="曲顶柱体"></a>曲顶柱体</h5><p>曲顶柱体的顶为连续曲面 $z = f(x,y),(x,y)\in D$</p>
<p>其体积为 $V = \iint_Df(x,y)dxdy$</p>
<h5 id="占有空间有界域-Omega-的立体的体积为"><a href="#占有空间有界域-Omega-的立体的体积为" class="headerlink" title="占有空间有界域$\Omega$的立体的体积为"></a>占有空间有界域$\Omega$的立体的体积为</h5><p>$V = \iiint_\Omega dxdydz$</p>
<h4 id="曲面面积"><a href="#曲面面积" class="headerlink" title="曲面面积"></a>曲面面积</h4><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/10.png" alt="示例"></p>
<p>所以曲面面积公式</p>
<p>$A = \iint_{D_{xy}} \sqrt{1+f_x^2(x,y)+f_y^2(x,y)}d\sigma  $</p>
<p><strong>当光滑曲面的方程为</strong>$z = f(x,y)$ $(x,y) \in D_{xy} $</p>
<p> $A = \iint_{D_{xy}}   \sqrt{1+(\frac{\delta z}{\delta x})^2+(\frac{\delta z}{\delta y})^2}dxdy$</p>
<p><strong>光滑曲面的方程为</strong> $y = f(z,x)$ $(z,x) \in D_{zx} $</p>
<p> $A = \iint_{D_{zx}} \sqrt{1+(\frac{\delta y}{\delta z})^2+(\frac{\delta y}{\delta x})^2}dzdx$</p>
<p><strong>光滑曲面的方程为</strong> $x = f(z,y)$ $(z,y) \in D_{zy} $</p>
<p> $A = \iint_{D_{zy}} \sqrt{1+(\frac{\delta x}{\delta z})^2+(\frac{\delta x}{\delta y})^2}dzdy$</p>
<p>*<em>当光滑曲面方程为隐式 *</em>$F(x,y,z)=0,F_z \neq 0 $</p>
<p>$\frac{\delta z}{\delta x}=-\frac{F_x}{F_z},\frac{\delta z}{\delta y}=-\frac{F_y}{F_z},(x,y)\in D_{xy}$</p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/15.png" alt="示例"></p>
<h4 id="物体的质心"><a href="#物体的质心" class="headerlink" title="物体的质心"></a>物体的质心</h4><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/11.png" alt="示例"></p>
<p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/12.png" alt="示例"></p>
<h5 id="当所求对象是三维立体时"><a href="#当所求对象是三维立体时" class="headerlink" title="当所求对象是三维立体时"></a>当所求对象是三维立体时</h5><p>密度为$\rho(x,y,z)$时</p>
<p>令每个个小区域的最大直径$\lambda \rightarrow 0$</p>
<ul>
<li><p>一般不会让我们全部求。先考虑从对称性出发，把能变成0的都变成0</p>
<p>$ \overline{x} = \frac{\iiint_\Omega x\rho(x,y,z)dxdydz}{\iiint_\Omega \rho(x,y,z)dxdydz}$</p>
<p>$ \overline{y} = \frac{\iiint_\Omega y\rho(x,y,z)dxdydz}{\iiint_\Omega \rho(x,y,z)dxdydz}$</p>
<p>$ \overline{z} = \frac{\iiint_\Omega z\rho(x,y,z)dxdydz}{\iiint_\Omega \rho(x,y,z)dxdydz}$</p>
</li>
</ul>
<h6 id="形心坐标："><a href="#形心坐标：" class="headerlink" title="形心坐标："></a>形心坐标：</h6><p>当  $\rho = 常数$</p>
<p> $ \overline{x} = \frac{\iiint_\Omega x dxdydz}{\iiint_\Omega  dxdydz}$</p>
<p> $ \overline{y} = \frac{\iiint_\Omega y dxdydz}{\iiint_\Omega  dxdydz}$</p>
<p> $ \overline{z} = \frac{\iiint_\Omega z dxdydz}{\iiint_\Omega  dxdydz}$</p>
<p>$ V = \iiint_Omega dxdydz$</p>
<h5 id="当物体时平面薄片时"><a href="#当物体时平面薄片时" class="headerlink" title="当物体时平面薄片时"></a>当物体时平面薄片时</h5><h6 id="密度为-mu-x-y-时"><a href="#密度为-mu-x-y-时" class="headerlink" title="密度为$\mu(x,y)$时"></a>密度为$\mu(x,y)$时</h6><p> $ \overline{x} = \frac{\iint_D x\mu(x,y)dxdy }{\iint_D\mu(x,y)dxdy }=\frac{M_y}{M}$</p>
<p>$ \overline{y} = \frac{\iint_D x\mu(x,y)dxdy }{\iint_D\mu(x,y)dxdy }=\frac{M_x}{M}$</p>
<p><strong>$M_x和M_y$分别时对x轴和对y轴的静矩</strong></p>
<h6 id="形心坐标-当-mu-常数-时"><a href="#形心坐标-当-mu-常数-时" class="headerlink" title="形心坐标 当 $\mu=常数$时"></a>形心坐标 当 $\mu=常数$时</h6><p> $ \overline{x} = \frac{\iint_D x dxdy }{\iint_D dxdy } $</p>
<p>$ \overline{y} = \frac{\iint_D x dxdy }{\iint_D dxdy } $</p>
<p>A = ${\iint_D dxdy }$ A是D的面积</p>
<h4 id="物体的转动惯量"><a href="#物体的转动惯量" class="headerlink" title="物体的转动惯量"></a>物体的转动惯量</h4><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/13.png" alt="示例"></p>
<h6 id="当对象是三维立体时"><a href="#当对象是三维立体时" class="headerlink" title="当对象是三维立体时"></a>当对象是三维立体时</h6><p>密度为$\rho(x,y,z)$时</p>
<p><strong>因此物体对z轴的转动惯量：</strong></p>
<p>$I_z = \iiint_\Omega(x^2+y^2)\rho(x,y,z)dxdydz$</p>
<p><strong>因此物体对x轴的转动惯量：</strong></p>
<p>$I_x = \iiint_\Omega(z^2+y^2)\rho(x,y,z)dxdydz$</p>
<p><strong>因此物体对y轴的转动惯量：</strong></p>
<p>$I_y = \iiint_\Omega(x^2+z^2)\rho(x,y,z)dxdydz$</p>
<p><strong>因此物体原点的转动惯量：</strong></p>
<p>$I_O = \iiint_\Omega(x^2+z^2+z^2)\rho(x,y,z)dxdydz$</p>
<h6 id="如果对象是平面薄片时"><a href="#如果对象是平面薄片时" class="headerlink" title="如果对象是平面薄片时"></a>如果对象是平面薄片时</h6><p>密度为$\mu(x,y)$时</p>
<p><strong>物体对x轴的转动惯量：</strong></p>
<p>$I_x = \iint_Dy^2\rho(x,y)dxdy$</p>
<p><strong>物体对y轴的转动惯量</strong></p>
<p>$I_y = \iint_Dx^2\rho(x,y)dxdy$</p>
<p><strong>物体原点的转动惯量</strong></p>
<p>$I_y = \iint_D(x^2+y^2)\rho(x,y)dxdy$</p>
<h5 id="物体的引力"><a href="#物体的引力" class="headerlink" title="物体的引力"></a>物体的引力</h5><p><img src="/2020/05/01/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E9%87%8D%E7%A7%AF%E5%88%86/14.png" alt="示例"></p>
<h6 id="因此立体对象的引力分量"><a href="#因此立体对象的引力分量" class="headerlink" title="因此立体对象的引力分量"></a>因此立体对象的引力分量</h6><p>密度为$\rho(x,y,z)$</p>
<p>$F_x = G\iiint_\Omega \frac{\rho(x,y,z)(x-x_0)}{r^3}dv$</p>
<p>$F_y = G\iiint_\Omega \frac{\rho(x,y,z)(y-y_0)}{r^3}dv$</p>
<p>$F_z = G\iiint_\Omega \frac{\rho(x,y,z)(z-z_0)}{r^3}dv$</p>
<h6 id="求平面薄片D-的引力分量"><a href="#求平面薄片D-的引力分量" class="headerlink" title="求平面薄片D 的引力分量"></a>求平面薄片D 的引力分量</h6><p>密度为$\mu(x,y)$</p>
<p> $F_x = G\iint_D\frac{\mu(x,y)(x-x_0)}{r^3}d\sigma$</p>
<p> $F_y = G\iint_D\frac{\mu(x,y)(y-y_0)}{r^3}d\sigma$</p>
<p> $F_z = G\iint_D \frac{\mu(x,y)(0-z_0)}{r^3}d\sigma$  假设薄片在xOy平面上</p>
<p><strong>其中G是引力常数，r 是点与点之间的距离</strong></p>
]]></content>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法和主定理</title>
    <url>/2020/05/08/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%BB%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="分治算法和主定理"><a href="#分治算法和主定理" class="headerlink" title="分治算法和主定理"></a>分治算法和主定理</h1><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>$T(n) = 3T(\frac{n}{2})+O(n)$</p>
<p>那么一直分到最底层，也就是第k层，那么k = logn,这颗树的高度就是logn</p>
<p>那么根据$a^{logb_n}=n^{log_ba} -&gt; O(3^{log_2n})= O(n^{log_23})$</p>
<p>所以第一层复杂度是O(n),公比为 3/2 ，到最后一层复杂度为$(n^{log_23})$</p>
<p>累加得 $O(n^{1.59})$</p>
<h3 id="DC与DP的区别"><a href="#DC与DP的区别" class="headerlink" title="DC与DP的区别"></a>DC与DP的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>DC</th>
<th>DP</th>
</tr>
</thead>
<tbody>
<tr>
<td>子问题的相关性</td>
<td>相互独立</td>
<td>相互联系</td>
</tr>
<tr>
<td>例子</td>
<td>二分搜索，归并排序</td>
<td>背包问题，编辑问题</td>
</tr>
<tr>
<td>是否要记笔记</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>方法</td>
<td>Top-down</td>
<td>Bottom-up</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h3><p>如果f满足 $f(n) = af(\frac{n}{b})+c$</p>
<p>那么</p>
<p>当 $a&gt;1$时 $ f(n) = O(n^{log_ba})$</p>
<p>当 $a=1$时 $f(n) = O(log_bn)$</p>
<p>那么，如果当 n = b^k  并且 a != 1,  k 是一个正整数,$f (n) = C_1n^{log_ba} + C_2;$<br>where $C_1 = f (1) + c=(a-1) $and $C_2 = -c/(a - 1)$</p>
<p>那么当在Conquer的时候C不是一个常数，又会怎么样呢？</p>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><img src="/2020/05/08/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%BB%E5%AE%9A%E7%90%86/1.png" alt></p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p><img src="/2020/05/08/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%BB%E5%AE%9A%E7%90%86/1.jpg" alt></p>
<p>我们可以总结出一个规律</p>
<p>$a^kc(n/b^k)^d = cn^d(a/b^d)^k$</p>
<p>因此 </p>
<p>$T(n) = ca^{log_bn}+\sum_{k=0}^{log_b{n-1}}cn^d(\frac{a}{b^d})^k$</p>
<h5 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h5><p>当$a/b^d = 1$的时候，$a=b^d，d= log_ba$</p>
<p>$T(n) = cn^{log_ba}+cn^d\sum_{k=0}^{log_b{a-1}}(\frac{a}{b^d})^k$</p>
<p>$= cn^d+cn^d\sum_{k=0}^{log_bn-1}1=cn^d+cn^dlog_bn$</p>
<p>$= O(n^dlog_n)$</p>
<h5 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h5><p>当$a/b^d &lt; 1$的时候，$a<b^d，d> log_ba$</b^d，d></p>
<p>$T(n) = cn^{log_ba}+cn^d\sum_{k=0}^{log_b{a-1}}(\frac{a}{b^d})^k$</p>
<p>$&lt; cn^d+cn^d\sum_{k=0}^{log_bn-1}(\frac{a}{b^d})^k=cn^d+cn^dlog_bn$</p>
<p>$&lt; cn^d+cn^d\sum_{k=0}^{\infty}(\frac{a}{b^d})^k=cn^d(1+\frac1{1-a/b^d})$</p>
<p>$=O(n^d)$</p>
<h5 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h5><p>当$a/b^d &gt; 1$的时候，$a&gt;b^d，d&lt; log_ba$</p>
<p>$T(n) = cn^{log_ba}+cn^d\sum_{k=0}^{log_b{a-1}}(\frac{a}{b^d})^k &lt; cn^d + cn^d\frac{(a/b^d)^{log_bn}-1}{(a/b^d)-1}$</p>
<p><img src="/2020/05/08/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%BB%E5%AE%9A%E7%90%86/2.png" alt></p>
<p>所以这里有几个例子</p>
<p><img src="/2020/05/08/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%BB%E5%AE%9A%E7%90%86/3.png" alt></p>
<h3 id="作业题选"><a href="#作业题选" class="headerlink" title="作业题选"></a>作业题选</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>Suppose that each person in a group of n people votes for exactly two people from a slate of candidates to fill two positions on a committee. The top two finishers both win positions as long as each receives more than n/2 votes. </p>
<p>​    a) Devise a divide-and-conquer algorithm that determines whether the two candidates who received the most votes each received at least n/2 votes and, if so, determine who these two candidates are.</p>
<p>​     b) Use the master theorem to give a big-O estimate for the number of comparisons needed by the algorithm you devised in part (a).</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>a) Set up a divide-and-conquer recurrence relation for the number of multiplications to compute $x^n$,where x is a real number and n is a positive integer.<br>b) Use the recurrence relation you find in part (a) to construct a big-O estimate for the number of multiplications used to compute $x^n$ using the recursive algorithm.</p>
]]></content>
      <tags>
        <tag>discrete mathematics</tag>
        <tag>divide-and-counquer</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数</title>
    <url>/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Generating-functions"><a href="#Generating-functions" class="headerlink" title="Generating functions"></a>Generating functions</h1><p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/2.png" alt></p>
<h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>$G(x) = a_0+a_1+a_2……a_kx^k+… = \sum_{k=0}^{\infty}a_kx^k$</p>
<p>关于Generating functions 或者叫母函数或生成函数，我们有一些例子</p>
<p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/4.png" alt></p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/1.png" style="zoom: 67%;"></p>
<ul>
<li>怎么证明 ak=k+1时候的结论？</li>
<li>把$\sum_{j=0}^k1看作是 a_j b_{k-j}=1$</li>
<li>原式就是 $f^2(x),f(x)是当 a_k = 1的时候对应的深层函数$</li>
</ul>
<h2 id="Extended-Binomial-Coefficient"><a href="#Extended-Binomial-Coefficient" class="headerlink" title="Extended Binomial Coefficient"></a>Extended Binomial Coefficient</h2><p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/3.png" style="zoom: 50%;"></p>
<p>我们从中可以推断出这个结论</p>
<p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/5.png" style="zoom: 50%;"></p>
<p>那么让 |x|&lt;1并且让u为一个实数. 二项式展开是一样的，只不过u可以实任意一个实数</p>
<p>$(1+x)^u=\sum_{k=0}^{\infty}\tbinom{u}{k}x^k$</p>
<p>有了以上结论我们可以分别求出$(1+x)^{-n}和(1-x)^{-n}$</p>
<p>$(1+x)^{-n}= \sum_{k=0}^{\infty}\tbinom{-n}{k}x^k = \sum_{k=0}^{\infty}(-1)^k\tbinom{n+k-1}{k}x^k$</p>
<p>$(1-x)^{-n}= \sum_{k=0}^{\infty}\tbinom{-n}{k}(-x)^k = \sum_{k=0}^{\infty}(-1)^k\tbinom{n+k-1}{k}(-1)^kx^k=\sum_{k=0}^{\infty} \tbinom{n+k-1}{k}x^k $</p>
<h2 id="Counting-Problems-and-Generating-functions"><a href="#Counting-Problems-and-Generating-functions" class="headerlink" title="Counting Problems and Generating functions"></a>Counting Problems and Generating functions</h2><h3 id="Example-I"><a href="#Example-I" class="headerlink" title="Example I"></a>Example I</h3><p><strong>Question</strong>: Find the number of solutions of e1 +e2 +e3 = 17, where<br>e1,e2, and e3 are nonnegative integers with $2\leq e_1\leq 5,3\leq e_2 \leq 6, 4\leq e_3 \leq 7$</p>
<p><strong>solution</strong>: 构造一个多项式</p>
<p>$(x^2 + x^3 + x^4 + x^5)(x^3 + x^4 + x^5 + x^6)(x^4 + x^5 + x^6 + x^7)$</p>
<p>然后从里面挑，让最后相乘后x的17次方的系数。这就是通过生成函数来构造一个方程的解</p>
<p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/6.png" style="zoom: 50%;"></p>
<h3 id="Example-II"><a href="#Example-II" class="headerlink" title="Example II"></a>Example II</h3><p><strong>Question:</strong>In how many different ways can eight identical cookies be distributed among three distinct children if each child receives at least two cookies and no more than four cookies?</p>
<p><strong>solution:</strong> 转换成 $e_1+e_2+e_3 = 8 ,2\leq e_n\leq 4$</p>
<p>所以这个多项式就是 $(x^2+x^3+x^4)^3$,在里面找x^8 的系数是多少</p>
<p>$(x^2+x^3+x^4)^3=x^6(1+x+x^2)^3$ 也就是从$(1+x+x^2)^3$中找到x^2的系数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Way</th>
<th>#cases</th>
</tr>
</thead>
<tbody>
<tr>
<td>x^2,1,1</td>
<td>$C_3^1$</td>
</tr>
<tr>
<td>x,x,1</td>
<td>$C_3^2$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Example-III"><a href="#Example-III" class="headerlink" title="Example III"></a>Example III</h3><p><strong>Question:</strong>How many positive integers less than 1,000,000 have the sum of there digits equal to 19?</p>
<p><strong>solution:</strong> 相当于一个六位数$\overline{a_1a_2a_3a_4a_5a_6}$ and $a_1+a_2+a_3+a_4+a_5+a_6=19$</p>
<p>其中 $0\leq a_i \leq 9$</p>
<p>所以这个多项式就是  $(1+x^1+x^2+…+x^9)^6$</p>
<p>通过等比序列求和，得到$(\frac{x^{10}-1}{x-1})^6 = (1-x^{10})^6(1-x)^{-6}=(1-x^{10})^6\sum_{k=0}^{\infty}\tbinom{6 + k-1}{k}x^k$</p>
<p>所以相当于这个展开式里面求解x的19次方的系数</p>
<p>如果前面有一个x^10,那么后面只能是9 个x^1,k=9</p>
<p>如果前面没有x^10,那么后面 全是 x^1,k = 19</p>
<h3 id="Example-IV"><a href="#Example-IV" class="headerlink" title="Example IV"></a>Example IV</h3><p><strong>Question:</strong>Please determine # ways to insert tokens worth $1,$2, and$5 into a vending machine that costs r dollars not matter the orders.</p>
<p><strong>solution:</strong></p>
<p>相当于一个多项式$(1+x+x^2…)(1+x^2+x^4…)(1+x^5+x^{10}…)$从中挑选x^r项的系数</p>
<p>也可以表示成这样：$(x+x^2+x^5)^n$n代表的是纸币张数，x代表塞入1$,依次类推，也就是说所有的多项式求和得到</p>
<p>$1+(x+x^2+x^5)+(x+x^2+x^5)^2+(x+x^2+x^5)^3+…= \frac{1}{1-(x+x^2+x^5)}$</p>
<p>在里面求x^r的系数是多少，但是比较麻烦</p>
<h3 id="Example-V"><a href="#Example-V" class="headerlink" title="Example V"></a>Example V</h3><p><strong>Question:</strong>Find # k-combinations of a set with n elements. Assume that the binomial theorem has already been established.在n个元素中找到k个元素组成的一个组合</p>
<p><strong>solution:</strong> 一个元素要么在组合里面要么不落在这个组合里面，所以是$x^0$或$x^1$,如果我们挑1，说明这个数没有被选在我的combination里面，否则说明落在combination里面</p>
<p>可以得到一个 方程 $f(x)=(1+x)^n$，在里面得出x^k的系数，就是我们的答案</p>
<p>那么根据二项式定理可以得出 $f(x)= \sum_{k=0}^{n}\tbinom{n}{k}x^k$</p>
<p>所以 C(n,k) 就是 答案</p>
<h3 id="Example-VI"><a href="#Example-VI" class="headerlink" title="Example VI"></a>Example VI</h3><p><strong>Question:</strong>Find # k-combinations from a set with n elements when repetition of elements is allowed.</p>
<p><strong>solution:</strong> 当选出的元素是可以重复的，那么怎么做呢？</p>
<p>这时多项式就可以写成 $f(x) = (1+x+…+x^k…)^n$</p>
<p>这么写有什么好处呢因为 $x^{k+1}$以后的项的系数，不会和之前的项相乘得到目标x^k,并且，我们这样写，就可以写成 $f(x) = (\frac{1}{1-x})^n = (1-x)^{-n}= \sum_{k=0}^{\infty}\tbinom{-n}{k}(-x)^k$</p>
<p>那么这样的话，x^k 的系数就是 $\tbinom{-n}{k}(-1)^k = (-1)^kC(n+k-1,k)(-1)^k = \tbinom{n+k-1}{r}$</p>
<h3 id="Example-VII"><a href="#Example-VII" class="headerlink" title="Example VII"></a>Example VII</h3><p><strong>Question:</strong>Find # ways to select r objects of n different kinds if we must select at least one object of each kind.</p>
<p><strong>solution:</strong> 当每个元素至少找一个，那么生成函数怎么写，又怎么做呢？</p>
<p>$f (x) = (x + x^2 + ….)^n$中找x^r 的系数 。这就是说，把原来的1去掉了，因为每个元素都至少找一个。从中提取出一个x^n那么就变成了$f(x)= x^n(1+x+x^2+…)^n=\frac{x^n}{(1-x)^n}= x^n(1-x)^{-n}$</p>
<p>根据上面的结论我们可以得到 $f(x)= x^n\sum_{r=0}^{\infty}\tbinom{-n}{r}(-x)^r =\sum_{r=0}^{\infty}\tbinom{-n}{r}x^{n+r}$</p>
<p>令t = n+r 可得</p>
<p>$ =\sum_{t=n}^{\infty}\tbinom{t-1}{t-n}x^t$</p>
<p>那么也就是说有 C(r-1,r-n)种方法</p>
<h2 id="Using-Generating-functions-to-solve-Recurrence-Relaion"><a href="#Using-Generating-functions-to-solve-Recurrence-Relaion" class="headerlink" title="Using Generating functions to solve Recurrence Relaion"></a>Using Generating functions to solve Recurrence Relaion</h2><h3 id="Example-I-1"><a href="#Example-I-1" class="headerlink" title="Example I"></a>Example I</h3><p><strong>Question:</strong>Solve recurrence relation $a_k = 3a_{k-1}$ for k = 1， 2，3;<br>and initial condition $a_0 = 2$.</p>
<p><strong>solution:</strong> 这是用生成函数来求出递推公式</p>
<p>那么为了得到$a_{k-1}$我们可以这样变形$xf(x) = \sum_{k=0}^{\infty}a_kx^{k+1}=\sum_{k=1}^{\infty}a_{k-1}x^k$</p>
<p>所以原递推关系变成了 </p>
<p>$f(x)-3xf(x)=\sum_{k=0}^{\infty}a_kx^k-3\sum_{k=1}^{\infty}a^kx^k = a_0+\sum_{k=1}^{\infty}(a_k-3a_{k-1})x^k = 2$</p>
<p>所以 $f(x)-3xf(x)=2,f(x)=\frac 2{1-3x}$</p>
<p>根据定义 $\frac 1{1-ax}=\sum_{k=0}^{\infty}a^kx^k$我们得到了$f(x)=2\sum_{k=0}^{\infty}3^kx^k$</p>
<p>所以说，$a_k = 2\cdot3^k$</p>
<h3 id="Example-II-1"><a href="#Example-II-1" class="headerlink" title="Example II"></a>Example II</h3><p><strong>Question:</strong>Suppose that a valid codeword is an n-digit number indecimal notation containing an even number of 0s. Let an denote the number of valid codewords of length n. Note that a1 = 9, and the recurrence relation is</p>
<p>$a_n=8a_{n-1}+10^{n-1}$</p>
<p><strong>solution:</strong> 要用生成函数来解决，我们要求出 a0的值，代入得 a0=1</p>
<p>那么$f(x)-1=\sum_{n=1}^{\infty}a_nx^n=\sum_{n=1}^{\infty}(8a_{n-1}x^n+10^{n-1}x^n)$</p>
<p>这边为什么要减去1呢，就是把a0给减掉，剩下的就是从n=1开始的和了</p>
<p>所以继续化简得$=8x\sum_{n=1}^{\infty}a_{n-1}x^{n-1}+x\sum_{n=1}^{\infty}10^nx^n=8xf(x)+\frac{x}{1-10x}$</p>
<p> 所以 $f(x)-1=8xf(x)+\frac{x}{1-10x}$解得$f(x)= \frac{1-9x}{(1-8x)(1-10x)}=\frac{1}{2}(\frac 1{1-8x}+\frac 1{1-10x})$</p>
<p>由定义$\frac 1{1-ax}=\sum_{k=0}^{\infty}a^kx^k$我们得到了$f(x)= \sum_{k=0}^{\infty}\frac 1{2}(8^k+10^k)x^k$</p>
<p>那么自然 $a_n=\frac 1 2(8^k+10^k)$</p>
<h3 id="Example-III-1"><a href="#Example-III-1" class="headerlink" title="Example III"></a>Example III</h3><p><strong>Question:</strong> Using the generating function method to solve $a_n -3a_{n-1} = n , a_0 = 1$</p>
<p><strong>solution:</strong> 要用生成函数来解决，我们令$f(x)= \sum_{k=0}^{\infty}a_kx^k$</p>
<p>注意，这里是$a_{n-1}$那么我们向上面一样写 $xf(x)$，如果是二阶的$a_{n-2}$那么就需要令$x^2f(x)$ </p>
<p>所以 $xf(x)= \sum_{k=0}^{\infty}a_kx^{k+1}= \sum_{k=1}^{\infty}a_{k-1}x^k$</p>
<p>根据递推关系，我们带入可得</p>
<p>$f(x)-3xf(x)=\sum_{k=0}^{\infty}a_kx^k-3\sum_{k=1}^{\infty}a_{k-1}x^k=a_0+\sum_{k=1}^{\infty}(a_k-3a_{k-1})x^k=a_0+\sum_{k=1}^{\infty}kx^k$</p>
<p>对上面的式子进行变形，再根据定义我们可以得到 </p>
<p>$f(x)-3xf(x)=a_0+\sum_{k=0}^{\infty}=1+\sum_{k=1}^{\infty}(k+1)x^k-\sum_{k=0}^{\infty}x^k=1+\frac 1{(1-x)^2}-\frac 1{1-x}=\frac{x^2-x+1}{(1-x)^2}$</p>
<p>合并同类项 最后得出 $f(x)=\frac{x^2-x+1}{(1-3x)(1-x)^2}=\frac{A}{(1-x)^2}+{\frac B{1-3x}}+\frac C{1-x}$</p>
<p>算出来 $A= \frac {-1}{2},B=\frac 7 4,C =\frac {-1}{4} $</p>
<p>根据定义<img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/8.png"></p>
<p>我们得到了 $f(x)= \frac{-1}{2}\sum_{k=0}^{\infty}(k+1)x^k+\frac{7}{4}\sum_{k=0}^{\infty}3^kx^k-\frac{1}{4}\sum_{k= 0}^{\infty}x^k=\sum_{k=0}^{\infty}(\frac 7 4 3^k-\frac k 2-\frac 3 4)x^k$</p>
<p>综上，$a_k = \frac 7 4 3^k-\frac k 2-\frac 3 4$</p>
<h3 id="Example-IV-1"><a href="#Example-IV-1" class="headerlink" title="Example IV"></a>Example IV</h3><p><strong>Question:</strong> Let n is a positive integer, using generating functions to show that</p>
<p>$\sum_{k=0}^nC(n,k)^2=C(2n,n)$</p>
<p><strong>solution:</strong>从2n个对象中取n个，相当于 求 $(1+x)^{2n}$中 $x^n$ 的次数，展开的话我们可得</p>
<p>$(1+x)^{2n}=[(x+1)^n]^2=[C(n,0)+C(n,1)x+C(n,2)x^2…..+C(n,n)x^n]^2$</p>
<p>要看的是 $x^n$的系数，那么要看的就是$\sum_{k=0}^{n}C(n,k)C(n-k)=\sum_{k=0}^nC(n,k)^2$</p>
<p>Because both C(2n,n) andPnk=0 $C(n,k)^2$ represent the coefficient of xn in $(1 + x)^{2n}$, they must be equal.</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/9.png"></p>
<p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/8.png"></p>
<ul>
<li>对照上面的定理就好了，需要注意的是3n，2n+3这类的可以变形成3(n+1)-3和2(n+1)+1这两样，然后分别变成相对应的生成函数</li>
</ul>
<p><img src="/2020/05/08/%E6%B7%B1%E5%B1%82%E5%87%BD%E6%95%B0/10.png"></p>
<ul>
<li><p>对于这种已经知道生成函数，要我们求$a_k$的题目，我的经验就是<strong>有则改之无则加勉</strong></p>
</li>
<li><p>就是说，像$\frac 1{1-5x},\frac{1}{1-x^2}$这类，我们可以通过定理变形成$\sum_{k=0}^{\infty}5^kx^k和\sum_{k=0}^{\infty}(x^2)^k(把原来的x替换成x^2即可)$</p>
</li>
<li>但是像x^2+3x+7这类的，已经把系数$a_k$显示出来了，我们就没有必要再去改动他了，如果后面的分出来 $x_0orx_1$这类的倒是可以合并同类项</li>
<li>此外，要灵活运用变量替换，比如说$\frac{x^4}{1-x^4}-&gt;x^4\sum_{k=0}^{\infty}(x^4)^k-&gt;\sum_{k=0}^{\infty}x^{4k+4}$</li>
<li>然后令k+1 = m 在变量代换可得$\sum_{m=1}^\infty x^{4m}$</li>
</ul>
]]></content>
      <tags>
        <tag>discrete mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>hashtable</title>
    <url>/2020/05/09/hashtable/</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>散列表是根据关键字直接进行访问的数据结构。散列表通过散列韩式将关键字映射到存储地址，建立了关键字和存储地址之间的一种直接映射关系。这里的存储地址可以实数组下标，索引，内存地址等等</p>
<p>例如：关键字key = (17,24,48,25),散列函数H(key) = key%5,散列函数将关键字映射到存储地址的下标，将关键字存储到散列表的对应位置，如图</p>
<img src="/2020/05/09/hashtable/1.png" style="zoom:50%;">

<ul>
<li>这是理想状态，没有任何重复，这样查找时间就是O(1)的时间。如果冲突的话，也有很多处理方法。这种发生冲突的不同关键词（13和48）为同义词。因此，设计散列函数时应<strong>尽量减少冲突</strong>，如果冲突无法避免，则需要处理冲突的方法</li>
</ul>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数又称为哈希函数，是将关键字映射到存储地址的函数。记为 hash(key) = Addr 设计遵循为2个原则</p>
<ol>
<li>散列函数尽可能简单，能够快速计算出任一关键词的散列地址</li>
<li>散列函数映射的地址应该均匀分布整个空间，避免聚集，以减少冲突</li>
</ol>
<p>散列函数设计原则简化为四字箴言：简单，均匀</p>
<h4 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1.直接定址法"></a>1.直接定址法</h4><p>直接提取关键字的某个线性函数作为散列函数，散列函数形式如下：</p>
<p><strong>hash(key) = a*key+b</strong></p>
<p>其中a,b为常数</p>
<p>适用于事先知道关键字，关键字集合不是很大且连续性较好。<strong>关键字如果不连续，则造成大量空位，造成空间浪费</strong></p>
<p>例如，学生的学号{601001，601002，…..601006,….601045，…}，那么可以设计散列函数为 H(key) = key-601000</p>
<p>这样可以将学生的学生好直接迎着到存储地址的下标。符合简单均匀的原则</p>
<h4 id="2-除留余数法"><a href="#2-除留余数法" class="headerlink" title="2.除留余数法"></a>2.除留余数法</h4><ul>
<li>除留余数法 是一种最简单最常用的构造散列函数的方法，并且不需要事先知道关键字的分布，假设散列表的表长为m，取一个不大于表长的最大素数p，设计散列函数为：</li>
</ul>
<p><strong>hash(key) = key%p</strong></p>
<p>为什么要选择p为素数？</p>
<ul>
<li>为了避免冲突。因为在实际应用中，访问往往具有某种周期性，若周期与p有公共的素因子，则冲突的概率急剧上升。例如手表中的齿轮，两个交合齿轮的齿数最好是互质的，否则出现齿轮磨损绞断的概率很大，因此，发生冲突的概率随着p所含的素因子的增多而迅速增大，素因子越多，冲突也就越多</li>
</ul>
<h4 id="3-随机数法"><a href="#3-随机数法" class="headerlink" title="3.随机数法"></a>3.随机数法</h4><ul>
<li>随机可以让关键字分布的更均匀一些，因此可以将关键字随机化，然后再使用除留余数法得到存储地址。散列函数为：</li>
</ul>
<p><strong>hash(key) = rand (key)%p</strong></p>
<ul>
<li>其中 rand()是C和C++中的随机函数 ，rand(n)表示求0~（n-1）的随机数。p的取值和除留余数法相同</li>
</ul>
<h4 id="4-数字分析法"><a href="#4-数字分析法" class="headerlink" title="4.数字分析法"></a>4.数字分析法</h4><ul>
<li>数字分析法根据每个数字在各个位上出现的频率，选择平均分布的若干位，作为散列地址。该方法适用于已经直到关键字几何，通过观察分析得到</li>
</ul>
<img src="/2020/05/09/hashtable/2.png" style="zoom:50%;">

<h4 id="5-平方取中法"><a href="#5-平方取中法" class="headerlink" title="5.平方取中法"></a>5.平方取中法</h4><ul>
<li>对关键字平方后，按照散列表的大小，取中间的若干位作为散列地址（平方后截取）。适用于事先不知道关键字的分布，且关键码的位数不是很大</li>
<li>例如：散列地址为3位，则关键码10123的散列地址为475</li>
</ul>
<p><strong>10123^2 = 102475129</strong></p>
<h4 id="6-折叠法"><a href="#6-折叠法" class="headerlink" title="6.折叠法"></a>6.折叠法</h4><ul>
<li>将关键字从左到右分割成位数相等的及部分，将这几部分叠加求和，取后几位作为散列地址。适用于关键字位数很多，事先不知道关键字的分布。折叠法分为移位折叠和边界折叠两种。<ul>
<li>移位折叠是将分割后的每一个部分的最低为对齐，然后相加求和</li>
<li>边界折叠如同折纸，将相邻部分沿着边界来回折叠，然后对齐相加</li>
</ul>
</li>
</ul>
<img src="/2020/05/09/hashtable/3.png" style="zoom:50%;">

<h4 id="7-基数转换法"><a href="#7-基数转换法" class="headerlink" title="7.基数转换法"></a>7.基数转换法</h4><p>例如，将十进制数转为其他的进制表示，例如345转换成九进制表示为423。另外散列函数大多是基于整数的，如果关键字是浮点数，可以将关键字乘以M并四舍五入得到函数，再使用散列函数活着将关键字表示为二进制数然后再使用散列函数,如果关键字是字符，可以将字符串换成R进制的整数，然后再使用散列函数</p>
<img src="/2020/05/09/hashtable/4.png" style="zoom:50%;">

<img src="/2020/05/09/hashtable/5.png" style="zoom:50%;">



<h4 id="8-全域散列法"><a href="#8-全域散列法" class="headerlink" title="8.全域散列法"></a>8.全域散列法</h4><ul>
<li>如果对关键字了解不多，可以使用全域散列法。即将多种备选的散列函数放在一个集合H中，在实际应用中，随机选择其中一个作为散列函数。如果任意两个不同的关键字key1!=key2,hash(key1) = hash(key2)的散列函数个数最多是 |H|/m,|H|为集合中散列函数的个数，m为表长，则称H是全域的</li>
<li>一般不常写</li>
</ul>
<h3 id="冲突处理方式"><a href="#冲突处理方式" class="headerlink" title="冲突处理方式"></a>冲突处理方式</h3><p>无论如何设计散列函数，都无法避免冲突问题。如果发生冲突，就需要进行冲突处理。 冲突处理的方法为3种，开放地址法、链地址法、建立公共溢出区</p>
<h4 id="1-开放地址法"><a href="#1-开放地址法" class="headerlink" title="1.开放地址法"></a>1.开放地址法</h4><p>开放地址法是在线性存储空间上的解决方案，也称为闭散列。当发生冲突时，采用冲突处理方法在线性存储空间上探测其他的位置</p>
<p>hash’(key) = (hash(key)+d)%m</p>
<p>其中 hash（key)是原散列函数，hash’(key)是探测函数，di是增量序列，m为表长</p>
<p>根据增量序列不同，开放地址法又分为 线性探测，二次探测，随机探测，双倍散列 </p>
<h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p>线性探测法是最简单的开放地址法，线性探测的增量序列为：</p>
<p>$ d_i = 1,2,….m-1 $</p>
<p>例如 ，一组关键字（14,36,42,38,40,15,19,12,51,65,34,25）放到一个长为15的哈希表中，通过visualgo网站的动画我们可以看出线性探测是如何运行的</p>
<img src="/2020/05/09/hashtable/1.gif">

<p>注意：线性探测法很简单，只要有空间，就一定能探测到位置，但是在处理冲突过程中会出现非同义词之间对同一个散列地址争夺的现象，被称为”堆积“ 。向上面的34一项，探测了6次才找到合适的位置。堆积大大降低了查找效率</p>
<p><strong>性能分析：</strong></p>
<p>查找成功的平均查找长度</p>
<p>假设查找的概率均等，(12个关键字，每个关键字查找概率为1/12),查找成功的平均长度等于所有关键字查找成功的比较次数ci乘以查找概率pi的和</p>
<p>$ASL_{succ}=\sum_{i=1}^{n}p_ic_i$</p>
<p>当hash(key)=0的时候，如果该空间为空，则比较1次即可确定查找失败。如果该空间非空，关键字又不相等吗，则继续按照线性探测向后查找。直到遇到空时，才确定查找失败，计算比较次数。类似的，hash(key)=1,….,12也是这样计算的</p>
<img src="/2020/05/09/hashtable/6.png">

<p>那么平均查找长度就是 （1x3+2x3+3+4+5+6+7+8+11)/13=53/13</p>
<h5 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h5><p>二次探测法采用前后跳跃式探测的方法。发生冲突的时候，向前1位探测，向后1位探测，向后2^2位探测，向前2^2位探测，…..,跳跃式探测来避免堆积。</p>
<p>二次探测的增量序列是：$d_i=1^2,-1^2,2^2,-2^2…k^2,-k^2 $</p>
<p>关于二次探测，visualgo上的增量序列是$di=1^2,2^2,3^2..$ 用相同的数据测试时候，会出现探测15次后任然找不到的情况，这时候会报错。可见对于二次探测法也需要科学的增量序列，但是visualgo上的操作也值得借鉴，至少帮我们发现了了一个bug，所以我也展示一下</p>
<img src="/2020/05/09/hashtable/2.gif">

<h5 id="随机探测法"><a href="#随机探测法" class="headerlink" title="随机探测法"></a>随机探测法</h5><p>随即探测法采用伪随机数组进行探测，利用随机化避免堆积，随即探测的增量序列为：</p>
<p>$d_i=伪随机数列$</p>
<h5 id="double-hashing"><a href="#double-hashing" class="headerlink" title="double hashing"></a>double hashing</h5><p>我们来考察最后一个冲突解决方法，双散列（double hashing）。常用的方法是让F（i）= i * hash2( x )，这意思是用第二个散列函数算出x的散列值，然后在距离hash2( x )，2hash2( x )的地方探测。hash2( x )作为关键，必须要合理选取，否则会引起灾难性的后果——各种撞车。这个策略暂时不做过多分析了。</p>
<p>在visualgo上我们也可以看一下模拟情况。这里sec = prime-key%prime</p>
<img src="/2020/05/09/hashtable/3.gif">



<h4 id="2-链地址法"><a href="#2-链地址法" class="headerlink" title="2.链地址法"></a>2.链地址法</h4><p>链地址法又被称为是拉链法。如果不同关键词通过散列函数映射到同一个地址，这些关键字为同义词，将所有的同义词存储在一个线性链表当中，查找，插入，删除操作主要在这个链表中进行，拉链法适用于经常进行插入，删除的情况。</p>
<img src="/2020/05/09/hashtable/7.png" style="zoom:50%;">

<p>visualgo模拟如下</p>
<img src="/2020/05/09/hashtable/4.gif">

<p>链地址法求查找失败也非常容易。</p>
<img src="/2020/05/09/hashtable/8.png" style="zoom:50%;">



<h4 id="3-建立公共溢出区"><a href="#3-建立公共溢出区" class="headerlink" title="3.建立公共溢出区"></a>3.建立公共溢出区</h4><p>除了以上处理冲突方法之外，也可以建立一个公共溢出区，发生冲突的时候，将关键字放入公共溢出区。查找的时候，先根据待查找关键字的散列地址在散列表中查找，如果为空，则查找失败；如果非空且关键字不相等，则到公共溢出区查找，如仍然未找到，则查找失败</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2020/05/09/hashtable/9.png" style="zoom:50%;">

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 15<span class="comment">//哈希表的表长</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY 0<span class="comment">//单元为空的标记</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> HT[m],HC[m];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> key)</span><span class="comment">//哈希函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> key%<span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性探测</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Linedetect</span><span class="params">(<span class="keyword">int</span> HT[],<span class="keyword">int</span> H0,<span class="keyword">int</span> key,<span class="keyword">int</span> &amp;cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Hi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        Hi=(H0+i)%m; <span class="comment">//按照线性探测法计算下一个哈希地址Hi</span></span><br><span class="line">        <span class="keyword">if</span>(HT[Hi]==NULLKEY)</span><br><span class="line">            <span class="keyword">return</span> Hi;	<span class="comment">//若单元Hi为空，则所查元素不存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HT[Hi]==key)</span><br><span class="line">            <span class="keyword">return</span> Hi; <span class="comment">//若单元Hi中元素的关键字为key</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二次探测</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Seconddetect</span><span class="params">(<span class="keyword">int</span> HT[],<span class="keyword">int</span> H0,<span class="keyword">int</span> key,<span class="keyword">int</span> &amp;cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Hi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m/<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i1=i*i;</span><br><span class="line">        <span class="keyword">int</span> i2=-i1;</span><br><span class="line">        cnt++;</span><br><span class="line">        Hi=(H0+i1)%m; <span class="comment">//按照线性探测法计算下一个哈希地址Hi</span></span><br><span class="line">        <span class="keyword">if</span>(HT[Hi]==NULLKEY)<span class="comment">//若单元Hi为空，则所查元素不存在</span></span><br><span class="line">            <span class="keyword">return</span> Hi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HT[Hi]==key)<span class="comment">//若单元Hi中元素的关键字为key</span></span><br><span class="line">            <span class="keyword">return</span> Hi;</span><br><span class="line">        cnt++;</span><br><span class="line">        Hi=(H0+i2)%m; <span class="comment">//按照线性探测法计算下一个哈希地址Hi</span></span><br><span class="line">        <span class="keyword">if</span>(Hi&lt;<span class="number">0</span>)</span><br><span class="line">            Hi+=m;</span><br><span class="line">        <span class="keyword">if</span>(HT[Hi]==NULLKEY)<span class="comment">//若单元Hi为空，则所查元素不存在</span></span><br><span class="line">            <span class="keyword">return</span> Hi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HT[Hi]==key)<span class="comment">//若单元Hi中元素的关键字为key</span></span><br><span class="line">            <span class="keyword">return</span> Hi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchHash</span><span class="params">(<span class="keyword">int</span> HT[],<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在哈希表HT中查找关键字为key的元素，若查找成功，返回哈希表的单元标号，否则返回-1</span></span><br><span class="line">    <span class="keyword">int</span> H0=H(key); <span class="comment">//根据哈希函数H（key）计算哈希地址</span></span><br><span class="line">    <span class="keyword">int</span> Hi,cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(HT[H0]==NULLKEY)<span class="comment">//若单元H0为空，则所查元素不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(HT[H0]==key)<span class="comment">//若单元H0中元素的关键字为key，则查找成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"查找成功，比较次数："</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> H0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Hi=Linedetect(HT,H0,key,cnt);</span><br><span class="line">            <span class="keyword">if</span>(HT[Hi]==key)<span class="comment">//若单元Hi中元素的关键字为key，则查找成功</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"查找成功，比较次数："</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> Hi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//若单元Hi为空，则所查元素不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertHash</span><span class="params">(<span class="keyword">int</span> HT[],<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H0=H(key); <span class="comment">//根据哈希函数H（key）计算哈希地址</span></span><br><span class="line">    <span class="keyword">int</span> Hi=<span class="number">-1</span>,cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(HT[H0]==NULLKEY)</span><br><span class="line">    &#123;</span><br><span class="line">        HC[H0]=<span class="number">1</span>;<span class="comment">//统计比较次数</span></span><br><span class="line">        HT[H0]=key;	<span class="comment">//若单元H0为空，放入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Hi=Linedetect(HT,H0,key,cnt);<span class="comment">//线性探测</span></span><br><span class="line">        <span class="comment">//Hi=Seconddetect(HT,H0,key,cnt);//二次探测</span></span><br><span class="line">        <span class="keyword">if</span>((Hi!=<span class="number">-1</span>)&amp;&amp;(HT[Hi]==NULLKEY))</span><br><span class="line">        &#123;</span><br><span class="line">            HC[Hi]=cnt;</span><br><span class="line">            HT[Hi]=key;<span class="comment">//若单元Hi为空，放入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> HT[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;HT[i]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="built_in">memset</span>(HT,<span class="number">0</span>,<span class="keyword">sizeof</span>(HT));</span><br><span class="line">	<span class="built_in">memset</span>(HC,<span class="number">0</span>,<span class="keyword">sizeof</span>(HC));</span><br><span class="line">	<span class="built_in">print</span>(HT);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入12个关键字，存入哈希表中："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="keyword">if</span>(!InsertHash(HT,x))</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">cout</span>&lt;&lt;<span class="string">"创建哈希表失败！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"输出哈希表："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">print</span>(HT);</span><br><span class="line">	<span class="built_in">print</span>(HC);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入要查找的关键字"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">	<span class="keyword">int</span> result=SearchHash(HT,x);</span><br><span class="line">	<span class="keyword">if</span>(result!=<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"在第"</span>&lt;&lt;result+<span class="number">1</span>&lt;&lt;<span class="string">"位置找到"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"未找到"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14 36 42 38 40 15 19 12 51 65 34 25</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Data_structure</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接矩阵与邻接表</title>
    <url>/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><ul>
<li>树：一对多</li>
<li>图：多对多</li>
<li>线性表：一对一 <img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/17.png" style="zoom:67%;"></li>
</ul>
<ul>
<li>圆括号，是无序对</li>
<li><p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/18.png" style="zoom:67%;"></p>
</li>
<li><p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/19.png" style="zoom:67%;"></p>
</li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/20.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/21.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/22.png" style="zoom:67%;"><br><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/23.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/24.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/25.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/26.png" style="zoom:67%;"><br><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/27.png" style="zoom:67%;"></p>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/1.png" style="zoom: 67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/2.png" style="zoom: 67%;"></p>
<ul>
<li>有向图不一定是对称的</li>
<li>行表示出度</li>
<li>列表示入度</li>
<li>无向图无所谓</li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/3.png" style="zoom:67%;"></p>
<ul>
<li>先初始化为无穷大，然后输入</li>
<li>没有边的地方，就是无穷大</li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/4.png" style="zoom:67%;"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul>
<li><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3></li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/5.png" style="zoom:67%;"></p>
<ul>
<li>有向图，只看出度，入度统计比较麻烦</li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/6.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/7.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/8.png" style="zoom:67%;"></p>
<ul>
<li><strong>如果有权值，那么再加一个节点信息</strong></li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/9.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/10.png" style="zoom:67%;"></p>
<ul>
<li><strong>首先初始化为空</strong></li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/11.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/12.png" style="zoom:67%;"></p>
<ul>
<li>用头插入法，不用记录尾指针！越后面输入，越接近头节点</li>
</ul>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/13.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/14.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/15.png" style="zoom:67%;"></p>
<p><img src="/2020/05/09/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/16.png" style="zoom:67%;"></p>
<ul>
<li><p>有向图是出度，无向图就是他的度</p>
</li>
<li><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><p>见小技巧之<a href="https://jasonxqh.github.io/2020/04/21/%E9%93%BE%E5%BC%8F%E5%89%8D%E9%A1%B9%E6%98%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">链式前向星的概念和应用</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Data_structure</tag>
      </tags>
  </entry>
  <entry>
    <title>对坐标的曲线积分</title>
    <url>/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="对坐标的曲线积分"><a href="#对坐标的曲线积分" class="headerlink" title="对坐标的曲线积分"></a>对坐标的曲线积分</h1><h2 id="概念与性质"><a href="#概念与性质" class="headerlink" title="概念与性质"></a>概念与性质</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/1.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/2.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/3.png" style="zoom: 50%;"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/4.png" style="zoom: 50%;"></p>
<h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/5.png" style="zoom: 50%;"></p>
<p> v</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/7.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/8.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/9.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/10.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/11.png" style="zoom: 50%;"></p>
<h2 id="两类曲线积分之间的关系"><a href="#两类曲线积分之间的关系" class="headerlink" title="两类曲线积分之间的关系"></a>两类曲线积分之间的关系</h2><p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/12.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/09/%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/13.png" style="zoom: 50%;"></p>
]]></content>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
</search>
